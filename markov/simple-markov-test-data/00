require 'openssl/net/telnets'

create_makefile('objspace')
ISO_8859_4_TO_UCS_TBL = [
  ["A0",0xA0],
  ["A1",0x104],
  ["A2",0x138],
  ["A3",0x156],
  ["A4",0xA4],
  ["A5",0x128],
  ["A6",0x13B],
  ["A7",0xA7],
  ["A8",0xA8],
  ["A9",0x160],
  ["AA",0x112],
  ["AB",0x122],
  ["AC",0x166],
  ["AD",0xAD],
  ["AE",0x17D],
  ["AF",0xAF],
  ["B0",0xB0],
  ["B1",0x105],
  ["B2",0x2DB],
  ["B3",0x157],
  ["B4",0xB4],
  ["B5",0x129],
  ["B6",0x13C],
  ["B7",0x2C7],
  ["B8",0xB8],
  ["B9",0x161],
  ["BA",0x113],
  ["BB",0x123],
  ["BC",0x167],
  ["BD",0x14A],
  ["BE",0x17E],
  ["BF",0x14B],
  ["C0",0x100],
  ["C1",0xC1],
  ["C2",0xC2],
  ["C3",0xC3],
  ["C4",0xC4],
  ["C5",0xC5],
  ["C6",0xC6],
  ["C7",0x12E],
  ["C8",0x10C],
  ["C9",0xC9],
  ["CA",0x118],
  ["CB",0xCB],
  ["CC",0x116],
  ["CD",0xCD],
  ["CE",0xCE],
  ["CF",0x12A],
  ["D0",0x110],
  ["D1",0x145],
  ["D2",0x14C],
  ["D3",0x136],
  ["D4",0xD4],
  ["D5",0xD5],
  ["D6",0xD6],
  ["D7",0xD7],
  ["D8",0xD8],
  ["D9",0x172],
  ["DA",0xDA],
  ["DB",0xDB],
  ["DC",0xDC],
  ["DD",0x168],
  ["DE",0x16A],
  ["DF",0xDF],
  ["E0",0x101],
  ["E1",0xE1],
  ["E2",0xE2],
  ["E3",0xE3],
  ["E4",0xE4],
  ["E5",0xE5],
  ["E6",0xE6],
  ["E7",0x12F],
  ["E8",0x10D],
  ["E9",0xE9],
  ["EA",0x119],
  ["EB",0xEB],
  ["EC",0x117],
  ["ED",0xED],
  ["EE",0xEE],
  ["EF",0x12B],
  ["F0",0x111],
  ["F1",0x146],
  ["F2",0x14D],
  ["F3",0x137],
  ["F4",0xF4],
  ["F5",0xF5],
  ["F6",0xF6],
  ["F7",0xF7],
  ["F8",0xF8],
  ["F9",0x173],
  ["FA",0xFA],
  ["FB",0xFB],
  ["FC",0xFC],
  ["FD",0x169],
  ["FE",0x16B],
  ["FF",0x2D9],
]
require 'spec_helper'

describe "OffersController" do
  before do
    get "/"
  end

  # it "returns hello world" do
  #   last_response.body.should == "Hello World"
  # end
end
require File.expand_path('../../../../spec_helper', __FILE__)
require File.expand_path('../../fixtures/classes', __FILE__)
require File.expand_path('../../shared/pack_sockaddr', __FILE__)

describe "Socket#sockaddr_un" do
  it_behaves_like :socket_pack_sockaddr_un, :sockaddr_un
end
require File.expand_path('../../../spec_helper', __FILE__)
require 'thread'

describe "Mutex#synchronize" do
  it "wraps the lock/unlock pair in an ensure" do
    m1 = Mutex.new
    m2 = Mutex.new
    m2.lock

    th = Thread.new do
      lambda do
        m1.synchronize do
          m2.lock
          raise Exception
        end
      end.should raise_error(Exception)
    end

    Thread.pass while th.status and th.status != "sleep"

    m1.locked?.should be_true
    m2.unlock
    th.join
    m1.locked?.should be_false
  end
end
require 'test/unit'
require 'delegate'

class TestDelegateClass < Test::Unit::TestCase
  module M
    attr_reader :m
  end

  def test_extend
    obj = DelegateClass(Array).new([])
    obj.instance_eval { @m = :m }
    obj.extend M
    assert_equal(:m, obj.m, "[ruby-dev:33116]")
  end

  def test_systemcallerror_eq
    e = SystemCallError.new(0)
    assert((SimpleDelegator.new(e) == e) == (e == SimpleDelegator.new(e)), "[ruby-dev:34808]")
  end

  class Myclass < DelegateClass(Array);end

  def test_delegateclass_class
    myclass=Myclass.new([])
    assert_equal(Myclass,myclass.class)
    assert_equal(Myclass,myclass.dup.class,'[ruby-dev:40313]')
    assert_equal(Myclass,myclass.clone.class,'[ruby-dev:40313]')
  end

  def test_simpledelegator_class
    simple=SimpleDelegator.new([])
    assert_equal(SimpleDelegator,simple.class)
    assert_equal(SimpleDelegator,simple.dup.class)
    assert_equal(SimpleDelegator,simple.clone.class)
  end

  class Object
    def m
      :o
    end
    private
    def delegate_test_m
      :o
    end
  end

  class Foo
    def m
      :m
    end
    def delegate_test_m
      :m
    end
  end

  class Bar < DelegateClass(Foo)
  end

  def test_override
    foo = Foo.new
    foo2 = SimpleDelegator.new(foo)
    bar = Bar.new(foo)
    assert_equal(:o, Object.new.m)
    assert_equal(:m, foo.m)
    assert_equal(:m, foo2.m)
    assert_equal(:m, bar.m)
    bug = '[ruby-dev:39154]'
    assert_equal(:m, foo2.send(:delegate_test_m), bug)
    assert_equal(:m, bar.send(:delegate_test_m), bug)
  end

  class IV < DelegateClass(Integer)
    attr_accessor :var

    def initialize
      @var = 1
      super(0)
    end
  end

  def test_marshal
    bug1744 = '[ruby-core:24211]'
    c = IV.new
    assert_equal(1, c.var)
    d = Marshal.load(Marshal.dump(c))
    assert_equal(1, d.var, bug1744)
  end

  def test_copy_frozen
    bug2679 = '[ruby-dev:40242]'
    a = [42, :hello].freeze
    d = SimpleDelegator.new(a)
    assert_nothing_raised(bug2679) {d.dup[0] += 1}
    assert_raise(RuntimeError) {d.clone[0] += 1}
    d.freeze
    assert(d.clone.frozen?)
    assert(!d.dup.frozen?)
  end

  def test_frozen
    d = SimpleDelegator.new([1, :foo])
    d.freeze
    assert_raise(RuntimeError, '[ruby-dev:40314]#1') {d.__setobj__("foo")}
    assert_equal([1, :foo], d)
  end

  def test_instance_method
    s = SimpleDelegator.new("foo")
    m = s.method("upcase")
    s.__setobj__([1,2,3])
    assert_raise(NoMethodError, '[ruby-dev:40314]#3') {m.call}
  end

  class Foo
    private
    def delegate_test_private
      :m
    end
  end

  def test_private_method
    foo = Foo.new
    d = SimpleDelegator.new(foo)
    assert_raise(NoMethodError) {foo.delegate_test_private}
    assert_equal(:m, foo.send(:delegate_test_private))
    assert_raise(NoMethodError, '[ruby-dev:40314]#4') {d.delegate_test_private}
    assert_raise(NoMethodError, '[ruby-dev:40314]#5') {d.send(:delegate_test_private)}
  end
end
require File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../fixtures/classes.rb', __FILE__)

describe "String#+" do
  it "returns a new string containing the given string concatenated to self" do
    ("" + "").should == ""
    ("" + "Hello").should == "Hello"
    ("Hello" + "").should == "Hello"
    ("Ruby !" + "= Rubinius").should == "Ruby != Rubinius"
  end

  it "converts any non-String argument with #to_str" do
    c = mock 'str'
    c.should_receive(:to_str).any_number_of_times.and_return(' + 1 = 2')

    ("1" + c).should == '1 + 1 = 2'
  end

  it "raises a TypeError when given any object that fails #to_str" do
    lambda { "" + Object.new }.should raise_error(TypeError)
    lambda { "" + 65 }.should raise_error(TypeError)
  end

  it "doesn't return subclass instances" do
    (StringSpecs::MyString.new("hello") + "").should be_kind_of(String)
    (StringSpecs::MyString.new("hello") + "foo").should be_kind_of(String)
    (StringSpecs::MyString.new("hello") + StringSpecs::MyString.new("foo")).should be_kind_of(String)
    (StringSpecs::MyString.new("hello") + StringSpecs::MyString.new("")).should be_kind_of(String)
    (StringSpecs::MyString.new("") + StringSpecs::MyString.new("")).should be_kind_of(String)
    ("hello" + StringSpecs::MyString.new("foo")).should be_kind_of(String)
    ("hello" + StringSpecs::MyString.new("")).should be_kind_of(String)
  end

  it "taints the result when self or other is tainted" do
    strs = ["", "OK", StringSpecs::MyString.new(""), StringSpecs::MyString.new("OK")]
    strs += strs.map { |s| s.dup.taint }

    strs.each do |str|
      strs.each do |other|
        (str + other).tainted?.should == (str.tainted? | other.tainted?)
      end
    end
  end
end
# encoding: UTF-8
require File.dirname(__FILE__) + '/helper'
require 'erb'

class BaseTest < Test::Unit::TestCase
  setup do
    @base = Sinatra.new(Sinatra::Base)
    @base.set :views, File.dirname(__FILE__) + "/views"
  end

  it 'allows unicode strings in ascii templates per default (1.9)' do
    next unless defined? Encoding
    @base.new.erb(File.read(@base.views + "/ascii.erb").encode("ASCII"), {}, :value => "Ã¥kej")
  end

  it 'allows ascii strings in unicode templates per default (1.9)' do
    next unless defined? Encoding
    @base.new.erb(:utf8, {}, :value => "Some Lyrics".encode("ASCII"))
  end
end
require File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../fixtures/classes', __FILE__)

describe "Enumerable#find_index" do  
  ruby_version_is "1.8.7" do
    before :each do
      @elements = [2, 4, 6, 8, 10]
      @numerous = EnumerableSpecs::Numerous.new(*@elements)
    end

    it "passes each entry in enum to block while block when block is false" do
      visited_elements = []
      @numerous.find_index do |element|
        visited_elements << element
        false
      end
      visited_elements.should == @elements
    end

    it "returns nil when the block is false" do
      @numerous.find_index {|e| false }.should == nil
    end

    it "returns the first index for which the block is not false" do
      @elements.each_with_index do |element, index|
        @numerous.find_index {|e| e > element - 1 }.should == index
      end
    end

    it "returns the first index found" do
      repeated = [10, 11, 11, 13, 11, 13, 10, 10, 13, 11]
      numerous_repeat = EnumerableSpecs::Numerous.new(*repeated)
      repeated.each do |element|
        numerous_repeat.find_index(element).should == element - 10
      end
    end

    it "returns nil when the element not found" do
      @numerous.find_index(-1).should == nil
    end

    it "ignores the block if an argument is given" do
      @numerous.find_index(-1) {|e| true }.should == nil
    end
    
    ruby_version_is '1.8.7' do
      it 'returns an Enumerator if no block given' do
        @numerous.find_index.should be_an_instance_of(enumerator_class)
      end
    end

  end

end
class Pantry

  def initialize
    @items = {}
  end

  def add(food_name, count)
    @items[food_name] ||= 0
    @items[food_name] += count.to_i
  end

  def remove(food_name, count)
    @items[food_name] -= count.to_i
  end

  def count(food_name)
    @items[food_name]
  end

end
require 'sass/script/css_parser'

module Sass
  module SCSS
    # This is a subclass of {Parser} which only parses plain CSS.
    # It doesn't support any Sass extensions, such as interpolation,
    # parent references, nested selectors, and so forth.
    # It does support all the same CSS hacks as the SCSS parser, though.
    class CssParser < StaticParser
      private

      def parent_selector; nil; end
      def interpolation; nil; end
      def interp_string; tok(STRING); end
      def interp_ident(ident = IDENT); tok(ident); end
      def use_css_import?; true; end

      def special_directive(name)
        return unless name == 'media' || name == 'import'
        super
      end

      def block_child(context)
        case context
        when :ruleset
          declaration
        when :stylesheet
          directive || ruleset
        when :directive
          directive || declaration_or_ruleset
        end
      end

      def nested_properties!(node, space)
        expected('expression (e.g. 1px, bold)');
      end

      @sass_script_parser = Class.new(Sass::Script::CssParser)
      @sass_script_parser.send(:include, ScriptParser)
    end
  end
end
require File.expand_path(File.dirname(__FILE__) + '/helper')

class TestMigrationGenerator < Test::Unit::TestCase
  def setup
    @apptmp = "#{Dir.tmpdir}/padrino-tests/#{UUID.new.generate}"
    `mkdir -p #{@apptmp}`
  end

  def teardown
    `rm -rf #{@apptmp}`
  end

  context 'the migration generator' do
    should "fail outside app root" do
      output = silence_logger { generate(:migration, 'add_email_to_users', '-r=/tmp') }
      assert_match(/not at the root/, output)
      assert_no_file_exists("#{@apptmp}/db/migrate")
    end

    should "fail if we don't use an adapter" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon') }
      assert_raise(SystemExit) { silence_logger { generate(:migration, 'AddEmailToUsers', "-r=#{@apptmp}/sample_project") } }
    end

    should "generate migration inside app root" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=activerecord') }
      response_success = silence_logger { generate(:migration, 'AddEmailToUsers', "-r=#{@apptmp}/sample_project") }
      migration_file_path = "#{@apptmp}/sample_project/db/migrate/001_add_email_to_users.rb"
      assert_match_in_file(/class AddEmailToUser/m, migration_file_path)
    end

    should "generate migration inside app root with lowercase migration argument" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=activerecord') }
      response_success = silence_logger { generate(:migration, 'add_email_to_users', "-r=#{@apptmp}/sample_project") }
      migration_file_path = "#{@apptmp}/sample_project/db/migrate/001_add_email_to_users.rb"
      assert_match_in_file(/class AddEmailToUsers/m, migration_file_path)
    end

    should "generate migration inside app root with singular table" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=activerecord') }
      silence_logger { generate(:migration, 'add_email_to_user', "email:string", "-r=#{@apptmp}/sample_project") }
      migration_file_path = "#{@apptmp}/sample_project/db/migrate/001_add_email_to_user.rb"
      assert_match_in_file(/class AddEmailToUser/m, migration_file_path)
      assert_match_in_file(/t.string :email/, migration_file_path)
      assert_match_in_file(/t.remove :email/, migration_file_path)
    end

    should "properly calculate version number" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=sequel') }
      silence_logger { generate(:migration, 'add_email_to_person', "email:string", "-r=#{@apptmp}/sample_project") }
      silence_logger { generate(:migration, 'add_name_to_person', "email:string", "-r=#{@apptmp}/sample_project") }
      silence_logger { generate(:migration, 'add_age_to_user', "email:string", "-r=#{@apptmp}/sample_project") }
      assert_match_in_file(/class AddEmailToPerson/m, "#{@apptmp}/sample_project/db/migrate/001_add_email_to_person.rb")
      assert_match_in_file(/class AddNameToPerson/m, "#{@apptmp}/sample_project/db/migrate/002_add_name_to_person.rb")
      assert_match_in_file(/class AddAgeToUser/m, "#{@apptmp}/sample_project/db/migrate/003_add_age_to_user.rb")
    end
  end

  context 'the migration generator for activerecord' do
    should "generate migration for generic needs" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=activerecord') }
      response_success = silence_logger { generate(:migration, 'ModifyUserFields', "-r=#{@apptmp}/sample_project") }
      migration_file_path = "#{@apptmp}/sample_project/db/migrate/001_modify_user_fields.rb"
      assert_match_in_file(/class ModifyUserFields/m, migration_file_path)
      assert_match_in_file(/def self\.up\s+end/m, migration_file_path)
      assert_match_in_file(/def self\.down\s+end/m, migration_file_path)
    end

    should "generate migration for adding columns" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=activerecord') }
      migration_params = ['AddEmailToUsers', "email:string", "age:integer", "-r=#{@apptmp}/sample_project"]
      response_success = silence_logger { generate(:migration, *migration_params) }
      migration_file_path = "#{@apptmp}/sample_project/db/migrate/001_add_email_to_users.rb"
      assert_match_in_file(/class AddEmailToUsers/m, migration_file_path)
      assert_match_in_file(/change_table :users.*?t\.string :email/m, migration_file_path)
      assert_match_in_file(/t\.integer :age/m, migration_file_path)
      assert_match_in_file(/change_table :users.*?t\.remove :email/m, migration_file_path)
      assert_match_in_file(/t\.remove :age/m, migration_file_path)
    end

    should "generate migration for removing columns" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=activerecord') }
      migration_params = ['RemoveEmailFromUsers', "email:string", "age:integer", "-r=#{@apptmp}/sample_project"]
      response_success = silence_logger { generate(:migration, *migration_params) }
      migration_file_path = "#{@apptmp}/sample_project/db/migrate/001_remove_email_from_users.rb"
      assert_match_in_file(/class RemoveEmailFromUsers/m, migration_file_path)
      assert_match_in_file(/change_table :users.*?t\.remove :email/m, migration_file_path)
      assert_match_in_file(/t\.remove :age/m, migration_file_path)
      assert_match_in_file(/change_table :users.*?t\.string :email/m, migration_file_path)
      assert_match_in_file(/t\.integer :age/m, migration_file_path)
    end
  end

  context 'the migration generator for datamapper' do
    should "generate migration for generic needs" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=datamapper') }
      response_success = silence_logger { generate(:migration, 'ModifyUserFields', "-r=#{@apptmp}/sample_project") }
      migration_file_path = "#{@apptmp}/sample_project/db/migrate/001_modify_user_fields.rb"
      assert_match_in_file(/migration\s1.*?:modify_user_fields/m, migration_file_path)
      assert_match_in_file(/up\sdo\s+end/m, migration_file_path)
      assert_match_in_file(/down\sdo\s+end/m, migration_file_path)
    end

    should "generate migration for adding columns" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=datamapper') }
      migration_params = ['AddEmailToUsers', "email:string", "age:integer", "-r=#{@apptmp}/sample_project"]
      response_success = silence_logger { generate(:migration, *migration_params) }
      migration_file_path = "#{@apptmp}/sample_project/db/migrate/001_add_email_to_users.rb"
      assert_match_in_file(/migration\s1.*?:add_email_to_users/m, migration_file_path)
      assert_match_in_file(/modify_table :users.*?add_column :email, String/m, migration_file_path)
      assert_match_in_file(/add_column :age, Integer/m, migration_file_path)
      assert_match_in_file(/modify_table :users.*?drop_column :email/m, migration_file_path)
      assert_match_in_file(/drop_column :age/m, migration_file_path)
    end

    should "generate migration for removing columns" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=datamapper') }
      migration_params = ['RemoveEmailFromUsers', "email:string", "age:integer", "-r=#{@apptmp}/sample_project"]
      response_success = silence_logger { generate(:migration, *migration_params) }
      migration_file_path = "#{@apptmp}/sample_project/db/migrate/001_remove_email_from_users.rb"
      assert_match_in_file(/migration\s1.*?:remove_email_from_users/m, migration_file_path)
      assert_match_in_file(/modify_table :users.*?drop_column :email/m, migration_file_path)
      assert_match_in_file(/drop_column :age/m, migration_file_path)
      assert_match_in_file(/modify_table :users.*?add_column :email, String/m, migration_file_path)
      assert_match_in_file(/add_column :age, Integer/m, migration_file_path)
    end

    should "properly version migration files" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=datamapper') }
      response_success = silence_logger { generate(:migration, 'ModifyUserFields', "-r=#{@apptmp}/sample_project") }
      response_success = silence_logger { generate(:migration, 'ModifyUserFields2', "-r=#{@apptmp}/sample_project") }
      response_success = silence_logger { generate(:migration, 'ModifyUserFields3', "-r=#{@apptmp}/sample_project") }
      assert_match_in_file(/migration\s1.*?:modify_user_fields/m, "#{@apptmp}/sample_project/db/migrate/001_modify_user_fields.rb")
      assert_match_in_file(/migration\s2.*?:modify_user_fields2/m, "#{@apptmp}/sample_project/db/migrate/002_modify_user_fields2.rb")
      assert_match_in_file(/migration\s3.*?:modify_user_fields3/m, "#{@apptmp}/sample_project/db/migrate/003_modify_user_fields3.rb")
    end
  end

  context 'the migration generator for sequel' do
    should "generate migration for generic needs" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=sequel') }
      response_success = silence_logger { generate(:migration, 'ModifyUserFields', "-r=#{@apptmp}/sample_project") }
      migration_file_path = "#{@apptmp}/sample_project/db/migrate/001_modify_user_fields.rb"
      assert_match_in_file(/class ModifyUserFields/m, migration_file_path)
      assert_match_in_file(/def\sup\s+end/m, migration_file_path)
      assert_match_in_file(/def\sdown\s+end/m, migration_file_path)
    end

    should "generate migration for adding columns" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=sequel') }
      migration_params = ['AddEmailToUsers', "email:string", "age:integer", "-r=#{@apptmp}/sample_project"]
      response_success = silence_logger { generate(:migration, *migration_params) }
      migration_file_path = "#{@apptmp}/sample_project/db/migrate/001_add_email_to_users.rb"
      assert_match_in_file(/class AddEmailToUsers/m, migration_file_path)
      assert_match_in_file(/alter_table :users.*?add_column :email, String/m, migration_file_path)
      assert_match_in_file(/add_column :age, Integer/m, migration_file_path)
      assert_match_in_file(/alter_table :users.*?drop_column :email/m, migration_file_path)
      assert_match_in_file(/drop_column :age/m, migration_file_path)
    end

    should "generate migration for removing columns" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=sequel') }
      migration_params = ['RemoveEmailFromUsers', "email:string", "age:integer", "-r=#{@apptmp}/sample_project"]
      response_success = silence_logger { generate(:migration, *migration_params) }
      migration_file_path = "#{@apptmp}/sample_project/db/migrate/001_remove_email_from_users.rb"
      assert_match_in_file(/class RemoveEmailFromUsers/m, migration_file_path)
      assert_match_in_file(/alter_table :users.*?drop_column :email/m, migration_file_path)
      assert_match_in_file(/drop_column :age/m, migration_file_path)
      assert_match_in_file(/alter_table :users.*?add_column :email, String/m, migration_file_path)
      assert_match_in_file(/add_column :age, Integer/m, migration_file_path)
    end
  end

  context "the migration destroy option" do

    should "destroy the migration files" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=sequel') }
      migration_params = ['RemoveEmailFromUsers', "email:string", "age:integer", "-r=#{@apptmp}/sample_project"]
      silence_logger { generate(:migration, *migration_params) }
      silence_logger { generate(:migration, 'RemoveEmailFromUsers', "-r=#{@apptmp}/sample_project",'-d') }
      assert_no_file_exists("#{@apptmp}/sample_project/db/migrate/001_remove_email_from_users.rb")
    end

    should "destroy the migration file regardless of number" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon', '-d=sequel') }
      migration_params = ['RemoveEmailFromUsers', "email:string", "age:integer", "-r=#{@apptmp}/sample_project"]
      migration_param2 = ['AddEmailFromUsers', "email:string", "age:integer", "-r=#{@apptmp}/sample_project"]
      silence_logger { generate(:migration, *migration_param2) }
      silence_logger { generate(:migration, *migration_params) }
      silence_logger { generate(:migration, 'RemoveEmailFromUsers', "-r=#{@apptmp}/sample_project",'-d') }
      assert_no_file_exists("#{@apptmp}/sample_project/db/migrate/002_remove_email_from_users.rb")
    end
  end
endrequire File.dirname(__FILE__) + '/setup'

sizes_and_iterations.each do |max, iterations|
  h = new_hash
  (0...max).each do
    h[get_key(max)] = 0
  end

  Bench.run iterations do |n|
    n.times do
      (0...max).each do
        a = h[get_key(max)]
      end
    end
  end
end
# encoding: utf-8
module Mail
  module VERSION
    
    version = {}
    File.read(File.join(File.dirname(__FILE__), '../', 'VERSION')).each_line do |line|
      type, value = line.chomp.split(":")
      next if type =~ /^\s+$/  || value =~ /^\s+$/
      version[type] = value
    end
    
    MAJOR = version['major']
    MINOR = version['minor']
    PATCH = version['patch']
    BUILD = version['build']

    STRING = [MAJOR, MINOR, PATCH, BUILD].compact.join('.')
    
    def self.version
      STRING
    end
    
  end
end
require 'stringio'
require 'fileutils'
require 'gherkin'
require 'gherkin/formatter/pretty_formatter'
require 'gherkin/formatter/json_formatter'
require 'gherkin/json_parser'

module PrettyPlease
  
  def pretty_machinery(gherkin, feature_path)
    io        = StringIO.new
    formatter = Gherkin::Formatter::PrettyFormatter.new(io, true, false)
    parser    = Gherkin::Parser::Parser.new(formatter, true)
    parse(parser, gherkin, feature_path)
    io.string
  end

  def json_machinery(gherkin, feature_path)
    json                = StringIO.new
    json_formatter      = Gherkin::Formatter::JSONFormatter.new(json)
    gherkin_parser      = Gherkin::Parser::Parser.new(json_formatter, true)
    parse(gherkin_parser, gherkin, feature_path)

    io                  = StringIO.new
    pretty_formatter    = Gherkin::Formatter::PrettyFormatter.new(io, true, false)
    json_parser         = Gherkin::JSONParser.new(pretty_formatter)
    json_parser.parse(json.string, "#{feature_path}.json", 0)
    
    io.string
  end
  
  def parse(parser, gherkin, feature_path)
    begin
      parser.parse(gherkin, feature_path, 0)
    rescue => e
      if e.message =~ /Lexing error/
        FileUtils.mkdir "tmp" unless File.directory?("tmp")
        written_path = "tmp/#{File.basename(feature_path)}"
        File.open(written_path, "w") {|io| io.write(gherkin)}
        e.message << "\nSee #{written_path}"
      end
      raise e
    end
  end
end

World(PrettyPlease)

Given /^I have Cucumber's source code next to Gherkin's$/ do
  @cucumber_home = File.dirname(__FILE__) + '/../../../cucumber'
  raise "No Cucumber source in #{@cucumber_home}" unless File.file?(@cucumber_home + '/bin/cucumber')
end

Given /^I find all of the \.feature files$/ do
  @feature_paths = Dir["#{@cucumber_home}/**/*.feature"].sort
end

When /^I send each prettified original through the "([^"]*)" machinery$/ do |machinery|
  @error = false
  @feature_paths.each do |feature_path|
    begin
      original = pretty_machinery(IO.read(feature_path), feature_path)
      via_machinery = self.__send__("#{machinery}_machinery", original, feature_path)
      via_machinery.should == original
    rescue RSpec::Expectations::ExpectationNotMetError => e
      announce "=========="
      announce feature_path
      if(e.message =~ /(@@.*)/m)
        announce $1
        @error = true
      else
        announce "Identical, except for newlines"
      end
    rescue => e
      e.message << "\nFatal error happened when parsing #{feature_path}."
      raise e
    end
  end
end

Then /^the machinery output should be identical to the prettified original$/ do
  raise "Some features didn't make it through the machinery" if @error
end
require 'mspec/guards/guard'

# If a spec depends on STDOUT being a tty, use this guard. For specs that may
# block if run as a background process, see BackgroundGuard.

class TTYGuard < SpecGuard
  def match?
    STDOUT.tty?
  end
end

class Object
  def with_tty
    g = TTYGuard.new
    g.name = :with_tty
    yield if g.yield?
  ensure
    g.unregister
  end
end
module Cucumber
  class Broadcaster #:nodoc:
    def initialize(receivers = [])
      @receivers = receivers
    end

    def method_missing(method_name, *args)
      @receivers.map do |receiver|
        receiver.__send__(method_name, *args)
      end
    end
  end
end
module Compass
  module AppIntegration
    module StandAlone
      module ConfigurationDefaults
        def default_project_type
          :stand_alone
        end

        def sass_dir_without_default
          "src"
        end

        def javascripts_dir_without_default
          "javascripts"
        end

        def css_dir_without_default
          "stylesheets"
        end

        def images_dir_without_default
          "images"
        end

        def default_cache_dir
          ".sass-cache"
        end
      end

    end
  end
end
require File.expand_path(File.dirname(__FILE__) + '/helper')

class TestAppGenerator < Test::Unit::TestCase
  def setup
    @apptmp = "#{Dir.tmpdir}/padrino-tests/#{UUID.new.generate}"
    `mkdir -p #{@apptmp}`
  end

  def teardown
    `rm -rf #{@apptmp}`
  end

  context 'the app generator' do
    should "fail outside app root" do
      output = silence_logger { generate(:app, 'demo_root', "-r=#{@apptmp}") }
      assert_match(/not at the root/, output)
      assert_no_file_exists("#{@apptmp}/demo_root")
    end

    should "create correctly a new padrino application" do
      assert_nothing_raised { silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}") } }
      assert_nothing_raised { silence_logger { generate(:app, 'demo', "--root=#{@apptmp}/sample_project") } }
      assert_file_exists("#{@apptmp}/sample_project")
      assert_file_exists("#{@apptmp}/sample_project/demo")
      assert_file_exists("#{@apptmp}/sample_project/demo/app.rb")
      assert_file_exists("#{@apptmp}/sample_project/demo/controllers")
      assert_file_exists("#{@apptmp}/sample_project/demo/helpers")
      assert_file_exists("#{@apptmp}/sample_project/demo/views")
      assert_file_exists("#{@apptmp}/sample_project/demo/views/layouts")
      assert_dir_exists("#{@apptmp}/sample_project/public/demo")
      assert_match_in_file 'Padrino.mount("Demo").to("/demo")', "#{@apptmp}/sample_project/config/apps.rb"
      assert_match_in_file 'class Demo < Padrino::Application', "#{@apptmp}/sample_project/demo/app.rb"
    end

    should "generate tiny app skeleton" do
      assert_nothing_raised { silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}") } }
      assert_nothing_raised { silence_logger { generate(:app, 'demo','--tiny',"--root=#{@apptmp}/sample_project") } }
      assert_file_exists("#{@apptmp}/sample_project")
      assert_file_exists("#{@apptmp}/sample_project/demo")
      assert_file_exists("#{@apptmp}/sample_project/demo/helpers.rb")
      assert_file_exists("#{@apptmp}/sample_project/demo/controllers.rb")
      assert_file_exists("#{@apptmp}/sample_project/demo/mailers.rb")
      assert_dir_exists("#{@apptmp}/sample_project/demo/views/mailers")
      assert_dir_exists("#{@apptmp}/sample_project/public/demo")
      assert_match_in_file(/:notifier/,"#{@apptmp}/sample_project/demo/mailers.rb")
      assert_no_file_exists("#{@apptmp}/sample_project/demo/helpers")
      assert_no_file_exists("#{@apptmp}/sample_project/demo/controllers")
    end

    should "correctly create a new controller inside a padrino application" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}") }
      silence_logger { generate(:app, 'demo', "--root=#{@apptmp}/sample_project") }
      silence_logger { generate(:controller, 'demo_items', "-r=#{@apptmp}/sample_project", '-a=demo') }
      assert_match_in_file(/Demo.controllers :demo_items do/m, "#{@apptmp}/sample_project/demo/controllers/demo_items.rb")
      assert_match_in_file(/Demo.helpers do/m, "#{@apptmp}/sample_project/demo/helpers/demo_items_helper.rb")
      assert_file_exists("#{@apptmp}/sample_project/demo/views/demo_items")
    end

    should "correctly create a new mailer inside a padrino application" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}", '--script=none', '-t=bacon') }
      silence_logger { generate(:app, 'demo_app', "--root=#{@apptmp}/sample_project") }
      silence_logger { generate(:mailer, 'demo', "-r=#{@apptmp}/sample_project", '-a=demo_app') }
      assert_match_in_file(/DemoApp.mailer :demo/m, "#{@apptmp}/sample_project/demo_app/mailers/demo.rb")
      assert_dir_exists("#{@apptmp}/sample_project/demo_app/views/mailers/demo")
    end

    # only destroys what it generated.
    # hence, the folder will still exists if other changes were made to it.
    should "destroys itself" do
      silence_logger { generate(:project, 'sample_project', "--root=#{@apptmp}") }
      silence_logger { generate(:app, 'demo', "--root=#{@apptmp}/sample_project") }
      output = silence_logger { generate(:app, 'demo', "--root=#{@apptmp}/sample_project", '-d') }
      assert_no_match(/has been mounted/, output)
      assert_no_dir_exists("#{@apptmp}/sample_project/public/demo")
      assert_no_file_exists("#{@apptmp}/sample_project/demo/app.rb")
      assert_no_dir_exists("#{@apptmp}/sample_project/demo/controllers")
      assert_no_dir_exists("#{@apptmp}/sample_project/demo/helpers")
      assert_no_dir_exists("#{@apptmp}/sample_project/demo/views")
      assert_no_match_in_file(/Padrino\.mount\("Demo"\).to\("\/demo"\)/,"#{@apptmp}/sample_project/config/apps.rb")
    end
  end
endrequire "spec_helper"

describe Mongoid::Config::ReplsetDatabase do

  let(:replset_config) do
    File.join(File.dirname(__FILE__), "..", "..", "..", "config", "mongoid.replset.yml")
  end

  describe "#configure" do

    let(:options) do
      YAML.load(ERB.new(File.new(replset_config).read).result)
    end

    let(:replica_set) do
      described_class.new(options['test']).configure
    end

    it "returns a replica set connection" do
      replica_set[0].connection.should be_a(Mongo::ReplSetConnection)
    end

    it "sets slave ok to true" do
      replica_set[0].connection.slave_ok?.should be_true
    end

    it "does not configure specific slaves" do
      replica_set[1].should be_nil
    end
  end
end
# $Id: test_nowrite.rb 11708 2007-02-12 23:01:19Z shyouhei $

require 'fileutils'
require 'fileasserts'
require 'tmpdir'
require 'test/unit'

class TestFileUtilsNoWrite < Test::Unit::TestCase

  include FileUtils::NoWrite

  def test_visibility
    FileUtils::METHODS.each do |m|
      assert_equal true, FileUtils::NoWrite.respond_to?(m, true),
                   "FileUtils::NoWrite.#{m} is not defined"
      assert_equal true, FileUtils::NoWrite.respond_to?(m, false),
                   "FileUtils::NoWrite.#{m} is not public"
    end
    FileUtils::METHODS.each do |m|
      assert_equal true, respond_to?(m, true),
                   "FileUtils::NoWrite\##{m} is not defined"
      assert_equal true, FileUtils::NoWrite.private_method_defined?(m),
                   "FileUtils::NoWrite\##{m} is not private"
    end
  end

  def my_rm_rf(path)
    if File.exist?('/bin/rm')
      system %Q[/bin/rm -rf "#{path}"]
    else
      FileUtils.rm_rf path
    end
  end

  SRC  = 'data/src'
  COPY = 'data/copy'

  def setup
    @prevdir = Dir.pwd
    tmproot = "#{Dir.tmpdir}/fileutils.rb.#{$$}"
    Dir.mkdir tmproot unless File.directory?(tmproot)
    Dir.chdir tmproot
    my_rm_rf 'data'; Dir.mkdir 'data'
    my_rm_rf 'tmp'; Dir.mkdir 'tmp'
    File.open(SRC,  'w') {|f| f.puts 'dummy' }
    File.open(COPY, 'w') {|f| f.puts 'dummy' }
  end

  def teardown
    tmproot = Dir.pwd
    Dir.chdir @prevdir
    my_rm_rf tmproot
  end

  def test_cp
    cp SRC, 'tmp/cp'
    check 'tmp/cp'
  end

  def test_mv
    mv SRC, 'tmp/mv'
    check 'tmp/mv'
  end

  def check(dest)
    assert_file_not_exist dest
    assert_file_exist SRC
    assert_same_file SRC, COPY
  end

  def test_rm
    rm SRC
    assert_file_exist SRC
    assert_same_file SRC, COPY
  end

  def test_rm_f
    rm_f SRC
    assert_file_exist SRC
    assert_same_file SRC, COPY
  end

  def test_rm_rf
    rm_rf SRC
    assert_file_exist SRC
    assert_same_file SRC, COPY
  end

  def test_mkdir
    mkdir 'dir'
    assert_file_not_exist 'dir'
  end

  def test_mkdir_p
    mkdir 'dir/dir/dir'
    assert_file_not_exist 'dir'
  end

end
require "cgi"
require "rexml/document"

require "rss-testcase"

require "rss/1.0"
require "rss/2.0"
require "rss/trackback"

module RSS
  class TestTrackBack < TestCase

    def setup
      @prefix = "trackback"
      @uri = "http://madskills.com/public/xml/rss/module/trackback/"

      @parents = %w(item)

      @elems = {
        :ping => "http://bar.com/tb.cgi?tb_id=rssplustrackback",
        :about => "http://foo.com/trackback/tb.cgi?tb_id=20020923",
      }

      @content_nodes = @elems.collect do |name, value|
        "<#{@prefix}:#{name} rdf:resource=\"#{CGI.escapeHTML(value.to_s)}\"/>"
      end.join("\n")

      @content_nodes2 = @elems.collect do |name, value|
        "<#{@prefix}:#{name}>#{CGI.escapeHTML(value.to_s)}</#{@prefix}:#{name}>"
      end.join("\n")

      @rss_source = make_RDF(<<-EOR, {@prefix =>  @uri})
#{make_channel()}
#{make_image()}
#{make_item(@content_nodes)}
#{make_textinput()}
EOR

      @rss = Parser.parse(@rss_source)

      @rss20_source = make_rss20(nil, {@prefix =>  @uri}) do
        make_channel20(nil) do
          make_item20(@content_nodes2)
        end
      end

      @rss20 = Parser.parse(@rss20_source, false)
    end

    def test_parser

      assert_nothing_raised do
        Parser.parse(@rss_source)
      end

      @elems.find_all{|k, v| k == :ping}.each do |tag, value|
        assert_too_much_tag(tag.to_s, "item") do
          Parser.parse(make_RDF(<<-EOR, {@prefix => @uri}))
#{make_channel()}
#{make_item(("<" + @prefix + ":" + tag.to_s + " rdf:resource=\"" +
  CGI.escapeHTML(value.to_s) +
  "\"/>") * 2)}
EOR
        end
      end

      @elems.find_all{|k, v| k == :about}.each do |tag, value|
        assert_missing_tag("trackback:ping", "item") do
          Parser.parse(make_RDF(<<-EOR, {@prefix => @uri}))
#{make_channel()}
#{make_item(("<" + @prefix + ":" + tag.to_s + " rdf:resource=\"" +
  CGI.escapeHTML(value.to_s) +
  "\"/>") * 2)}
EOR
        end

      end

    end

    def test_accessor

      new_value = {
        :ping => "http://baz.com/trackback/tb.cgi?tb_id=20030808",
        :about => "http://hoge.com/trackback/tb.cgi?tb_id=90030808",
      }

      @elems.each do |name, value|
        @parents.each do |parent|
          accessor = "#{RSS::TRACKBACK_PREFIX}_#{name}"
          target = @rss.__send__(parent)
          target20 = @rss20.channel.__send__(parent, -1)
          assert_equal(value, target.__send__(accessor))
          assert_equal(value, target20.__send__(accessor))
          if name == :about
            # abount is zero or more
            target.__send__("#{accessor}=", 0, new_value[name].to_s)
            target20.__send__("#{accessor}=", 0, new_value[name].to_s)
          else
            target.__send__("#{accessor}=", new_value[name].to_s)
            target20.__send__("#{accessor}=", new_value[name].to_s)
          end
          assert_equal(new_value[name], target.__send__(accessor))
          assert_equal(new_value[name], target20.__send__(accessor))
        end
      end

    end

    def test_to_s

      @elems.each do |name, value|
        excepted = %Q!<#{@prefix}:#{name} rdf:resource="#{CGI.escapeHTML(value)}"/>!
        @parents.each do |parent|
          meth = "#{RSS::TRACKBACK_PREFIX}_#{name}_element"
          meth << "s" if name == :about
          assert_equal(excepted, @rss.__send__(parent).__send__(meth))
        end
      end

      REXML::Document.new(@rss_source).root.each_element do |parent|
        if @parents.include?(parent.name)
          parent.each_element do |elem|
            if elem.namespace == @uri
              assert_equal(elem.attributes["resource"], @elems[elem.name.intern])
            end
          end
        end
      end

    end

  end
end

$LOAD_PATH.unshift(File.dirname(__FILE__))
$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))
require 'rubygems'
require 'warden_oauth'
require 'spec'
require 'fakeweb'
require 'spec/autorun'

require File.dirname(__FILE__) + "/application_scenario"

Spec::Runner.configure do |config|
  config.before(:all) do
    FakeWeb.allow_net_connect = false
  end
end
ENV['PADRINO_ENV'] = 'test'
PADRINO_ROOT = File.dirname(__FILE__) unless defined? PADRINO_ROOT

require File.expand_path('../../../load_paths', __FILE__)
require File.join(File.dirname(__FILE__), '..', '..', 'padrino-core', 'test', 'helper')
require 'padrino-cache'
require 'fileutils'
require 'uuid'

class Test::Unit::TestCase

  def executable_on_path(binary)
    @matches = []

    ENV['PATH'].split(":").each do |path|
      bintest = File.executable?("#{path}/#{binary}")
      pathmatch = "#{path}/#{binary}"
      @matches << pathmatch if bintest == true
    end

    @matches.length == 1 ? @matches.first : false

  end
end
require File.dirname(__FILE__) + '/../../spec_helper'
require 'mspec/runner/actions/tagpurge'
require 'mspec/runner/mspec'
require 'mspec/runner/example'
require 'mspec/runner/tag'

describe TagPurgeAction, "#start" do
  before :each do
    @stdout = $stdout
    $stdout = IOStub.new
  end

  after :each do
    $stdout = @stdout
  end

  it "prints a banner" do
    action = TagPurgeAction.new
    action.start
    $stdout.should == "\nRemoving tags not matching any specs\n\n"
  end
end

describe TagPurgeAction, "#load" do
  before :each do
    @t1 = SpecTag.new "fails:I fail"
    @t2 = SpecTag.new "unstable:I'm unstable"
  end

  it "creates a MatchFilter for all tags" do
    MSpec.should_receive(:read_tags).and_return([@t1, @t2])
    MatchFilter.should_receive(:new).with(nil, "I fail", "I'm unstable")
    TagPurgeAction.new.load
  end
end

describe TagPurgeAction, "#after" do
  before :each do
    @state = mock("ExampleState")
    @state.stub!(:description).and_return("str")

    @action = TagPurgeAction.new
  end

  it "does not save the description if the filter does not match" do
    @action.should_receive(:===).with("str").and_return(false)
    @action.after @state
    @action.matching.should == []
  end

  it "saves the description if the filter matches" do
    @action.should_receive(:===).with("str").and_return(true)
    @action.after @state
    @action.matching.should == ["str"]
  end
end

describe TagPurgeAction, "#unload" do
  before :each do
    @stdout = $stdout
    $stdout = IOStub.new

    @t1 = SpecTag.new "fails:I fail"
    @t2 = SpecTag.new "unstable:I'm unstable"
    @t3 = SpecTag.new "fails:I'm unstable"

    MSpec.stub!(:read_tags).and_return([@t1, @t2, @t3])
    MSpec.stub!(:write_tags)

    @state = mock("ExampleState")
    @state.stub!(:description).and_return("I'm unstable")

    @action = TagPurgeAction.new
    @action.load
    @action.after @state
  end

  after :each do
    $stdout = @stdout
  end

  it "does not rewrite any tags if there were no tags for the specs" do
    MSpec.should_receive(:read_tags).and_return([])
    MSpec.should_receive(:delete_tags)
    MSpec.should_not_receive(:write_tags)

    @action.load
    @action.after @state
    @action.unload

    $stdout.should == ""
  end

  it "rewrites tags that were matched" do
    MSpec.should_receive(:write_tags).with([@t2, @t3])
    @action.unload
  end

  it "prints tags that were not matched" do
    @action.unload
    $stdout.should == "I fail\n"
  end
end

describe TagPurgeAction, "#unload" do
  before :each do
    @stdout = $stdout
    $stdout = IOStub.new

    MSpec.stub!(:read_tags).and_return([])

    @state = mock("ExampleState")
    @state.stub!(:description).and_return("I'm unstable")

    @action = TagPurgeAction.new
    @action.load
    @action.after @state
  end

  after :each do
    $stdout = @stdout
  end

  it "deletes the tag file if no tags were found" do
    MSpec.should_not_receive(:write_tags)
    MSpec.should_receive(:delete_tags)
    @action.unload
    $stdout.should == ""
  end
end

describe TagPurgeAction, "#register" do
  before :each do
    MSpec.stub!(:register)
    @action = TagPurgeAction.new
  end

  it "registers itself with MSpec for the :unload event" do
    MSpec.should_receive(:register).with(:unload, @action)
    @action.register
  end
end

describe TagPurgeAction, "#unregister" do
  before :each do
    MSpec.stub!(:unregister)
    @action = TagPurgeAction.new
  end

  it "unregisters itself with MSpec for the :unload event" do
    MSpec.should_receive(:unregister).with(:unload, @action)
    @action.unregister
  end
end
#
#  select demo  ---  called from demo.rb
#
unless Object.const_defined?('DemoVar')
  fail RuntimeError, "This is NOT a stand alone script. This script is called from 'demo.rb'. "
end

module DemoSelect
  @@var = TkVariable.new_hash

  def self.create(nb)
    frame = nb.insert('end', 'demoSelect', :text=>'Spin & Combo')

    titf1 = Tk::BWidget::TitleFrame.new(frame, :text=>'SpinBox')
    subf = titf1.get_frame
    spin = Tk::BWidget::SpinBox.new(subf, :range=>[1, 100, 1],
                                    :textvariable=>@@var.ref('spin', 'var'),
                                    :helptext=>'This is the SpinBox')
    ent = Tk::BWidget::LabelEntry.new(subf, :label=>'Linked var',
                                      :labelwidth=>10, :labelanchor=>:w,
                                      :textvariable=>@@var.ref('spin', 'var'),
                                      :editable=>0,
                                      :helptext=>"This is an Entry reflecting\nthe linked var of SpinBox")
    labf = Tk::BWidget::LabelFrame.new(subf, :text=>'Options',
                                       :side=>:top, :anchor=>:w,
                                       :relief=>:sunken, :borderwidth=>1,
                                       :helptext=>'Modify some options of SpinBox')
    subf = labf.get_frame
    chk1 = TkCheckbutton.new(subf, :text=>'Non editable',
                             :variable=>@@var.ref('spin', 'editable'),
                             :onvalue=>false, :offvalue=>true,
                             :command=>proc{
                               spin.editable(@@var['spin', 'editable'])
                             })
    chk2 = TkCheckbutton.new(subf, :text=>'Disabled',
                             :variable=>@@var.ref('spin', 'state'),
                             :onvalue=>'disabled', :offvalue=>'normal',
                             :command=>proc{
                               spin.state(@@var['spin', 'state'])
                             })
    Tk.pack(chk1, chk2, :side=>:left, :anchor=>:w)
    Tk.pack(spin, ent, labf, :pady=>4, :fill=>:x)
    titf1.pack

    titf2 = Tk::BWidget::TitleFrame.new(frame, :text=>'ComboBox')
    subf = titf2.get_frame
    combo = Tk::BWidget::ComboBox.new(subf,
                                      :textvariable=>@@var.ref('combo', 'var'),
                                      :values=>[
                                        'first value', 'second value',
                                        'third value', 'fourth value',
                                        'fifth value'
                                      ],
                                      :helptext=>'This is the ComboBox')
    ent = Tk::BWidget::LabelEntry.new(subf, :label=>'Linked var',
                                      :labelwidth=>10, :labelanchor=>:w,
                                      :textvariable=>@@var.ref('combo', 'var'),
                                      :editable=>0, :helptext=>"This is an Entry reflecting\nthe linked var of ComboBox")
    labf = Tk::BWidget::LabelFrame.new(subf, :text=>'Options', :side=>:top,
                                       :anchor=>:w, :relief=>:sunken,
                                       :borderwidth=>1, :helptext=>'Modify some options of ComboBox')
    subf = labf.get_frame
    chk1 = TkCheckbutton.new(subf, :text=>'Non editable',
                             :variable=>@@var.ref('combo', 'editable'),
                             :onvalue=>false, :offvalue=>true,
                             :command=>proc{
                               combo.editable(@@var['combo', 'editable'])
                             })
    chk2 = TkCheckbutton.new(subf, :text=>'Disabled',
                             :variable=>@@var.ref('combo', 'state'),
                             :onvalue=>'disabled', :offvalue=>'normal',
                             :command=>proc{
                               combo.state(@@var['combo', 'state'])
                             })

    Tk.pack(chk1, chk2, :side=>:left, :anchor=>:w)
    Tk.pack(combo, ent, labf, :pady=>4, :fill=>:x)
    Tk.pack(titf1, titf2, :pady=>4)

    frame
  end
end
require 'rubygems/installer_test_case'

class TestGemInstaller < Gem::InstallerTestCase

  def test_app_script_text
    @spec.version = 2
    util_make_exec @spec, ''

    expected = <<-EOF
#!#{Gem.ruby}
#
# This file was generated by RubyGems.
#
# The application 'a' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'

version = \">= 0\"

if ARGV.first =~ /^_(.*)_$/ and Gem::Version.correct? $1 then
  version = $1
  ARGV.shift
end

gem 'a', version
load Gem.bin_path('a', 'executable', version)
    EOF

    wrapper = @installer.app_script_text 'executable'
    assert_equal expected, wrapper
  end

  def test_build_extensions_none
    use_ui @ui do
      @installer.build_extensions
    end

    assert_equal '', @ui.output
    assert_equal '', @ui.error

    refute File.exist?('gem_make.out')
  end

  def test_build_extensions_extconf_bad
    @spec.extensions << 'extconf.rb'

    e = assert_raises Gem::Installer::ExtensionBuildError do
      use_ui @ui do
        @installer.build_extensions
      end
    end

    assert_match(/\AERROR: Failed to build gem native extension.$/, e.message)

    assert_equal "Building native extensions.  This could take a while...\n",
                 @ui.output
    assert_equal '', @ui.error

    gem_make_out = File.join @gemhome, 'gems', @spec.full_name, 'gem_make.out'

    assert_match %r%#{Regexp.escape Gem.ruby} extconf\.rb%,
                 File.read(gem_make_out)
    assert_match %r%#{Regexp.escape Gem.ruby}: No such file%,
                 File.read(gem_make_out)
  end

  def test_build_extensions_unsupported
    gem_make_out = File.join @gemhome, 'gems', @spec.full_name, 'gem_make.out'
    @spec.extensions << nil

    e = assert_raises Gem::Installer::ExtensionBuildError do
      use_ui @ui do
        @installer.build_extensions
      end
    end

    assert_match(/^\s*No builder for extension ''$/, e.message)

    assert_equal "Building native extensions.  This could take a while...\n",
                 @ui.output
    assert_equal '', @ui.error

    assert_equal "No builder for extension ''\n", File.read(gem_make_out)
  ensure
    FileUtils.rm_f gem_make_out
  end

  def test_ensure_dependency
    dep = Gem::Dependency.new 'a', '>= 2'
    assert @installer.ensure_dependency(@spec, dep)

    dep = Gem::Dependency.new 'b', '> 2'
    e = assert_raises Gem::InstallError do
      @installer.ensure_dependency @spec, dep
    end

    assert_equal 'a requires b (> 2)', e.message
  end

  def test_extract_files
    format = Object.new
    def format.file_entries
      [[{'size' => 7, 'mode' => 0400, 'path' => 'thefile'}, 'thefile']]
    end

    @installer.format = format

    @installer.extract_files

    thefile_path = File.join(util_gem_dir, 'thefile')
    assert_equal 'thefile', File.read(thefile_path)

    unless Gem.win_platform? then
      assert_equal 0400, File.stat(thefile_path).mode & 0777
    end
  end

  def test_extract_files_bad_dest
    @installer.gem_dir = 'somedir'
    @installer.format = nil
    e = assert_raises ArgumentError do
      @installer.extract_files
    end

    assert_equal 'format required to extract from', e.message
  end

  def test_extract_files_relative
    format = Object.new
    def format.file_entries
      [[{'size' => 10, 'mode' => 0644, 'path' => '../thefile'}, '../thefile']]
    end

    @installer.format = format

    e = assert_raises Gem::InstallError do
      @installer.extract_files
    end

    assert_equal "attempt to install file into \"../thefile\" under #{util_gem_dir.inspect}",
                 e.message
    assert_equal false, File.file?(File.join(@tempdir, '../thefile')),
                 "You may need to remove this file if you broke the test once"
  end

  def test_extract_files_absolute
    format = Object.new
    def format.file_entries
      [[{'size' => 8, 'mode' => 0644, 'path' => '/thefile'}, '/thefile']]
    end

    @installer.format = format

    e = assert_raises Gem::InstallError do
      @installer.extract_files
    end

    assert_equal 'attempt to install file into "/thefile"', e.message
    assert_equal false, File.file?(File.join('/thefile')),
                 "You may need to remove this file if you broke the test once"
  end

  def test_generate_bin_bindir
    @installer.wrappers = true

    @spec.executables = %w[executable]
    @spec.bindir = '.'

    exec_file = @installer.formatted_program_filename 'executable'
    exec_path = File.join util_gem_dir(@spec), exec_file
    File.open exec_path, 'w' do |f|
      f.puts '#!/usr/bin/ruby'
    end

    @installer.gem_dir = util_gem_dir

    @installer.generate_bin

    assert_equal true, File.directory?(util_inst_bindir)
    installed_exec = File.join(util_inst_bindir, 'executable')
    assert_equal true, File.exist?(installed_exec)
    assert_equal(0100755, File.stat(installed_exec).mode) unless win_platform?

    wrapper = File.read installed_exec
    assert_match %r|generated by RubyGems|, wrapper
  end

  def test_generate_bin_script
    @installer.wrappers = true
    util_make_exec
    @installer.gem_dir = util_gem_dir

    @installer.generate_bin
    assert_equal true, File.directory?(util_inst_bindir)
    installed_exec = File.join(util_inst_bindir, 'executable')
    assert_equal true, File.exist?(installed_exec)
    assert_equal(0100755, File.stat(installed_exec).mode) unless win_platform?

    wrapper = File.read installed_exec
    assert_match %r|generated by RubyGems|, wrapper
  end

  def test_generate_bin_script_format
    @installer.format_executable = true
    @installer.wrappers = true
    util_make_exec
    @installer.gem_dir = util_gem_dir

    Gem::Installer.exec_format = 'foo-%s-bar'
    @installer.generate_bin
    assert_equal true, File.directory?(util_inst_bindir)
    installed_exec = File.join util_inst_bindir, 'foo-executable-bar'
    assert_equal true, File.exist?(installed_exec)
  ensure
    Gem::Installer.exec_format = nil
  end

  def test_generate_bin_script_format_disabled
    @installer.wrappers = true
    util_make_exec
    @installer.gem_dir = util_gem_dir

    Gem::Installer.exec_format = 'foo-%s-bar'
    @installer.generate_bin
    assert_equal true, File.directory?(util_inst_bindir)
    installed_exec = File.join util_inst_bindir, 'executable'
    assert_equal true, File.exist?(installed_exec)
  ensure
    Gem::Installer.exec_format = nil
  end

  def test_generate_bin_script_install_dir
    @installer.wrappers = true
    @spec.executables = %w[executable]

    gem_dir = File.join "#{@gemhome}2", 'gems', @spec.full_name
    gem_bindir = File.join gem_dir, 'bin'
    FileUtils.mkdir_p gem_bindir
    File.open File.join(gem_bindir, 'executable'), 'w' do |f|
      f.puts "#!/bin/ruby"
    end

    @installer.gem_home = "#{@gemhome}2"
    @installer.gem_dir = gem_dir

    @installer.generate_bin

    installed_exec = File.join("#{@gemhome}2", 'bin', 'executable')
    assert_equal true, File.exist?(installed_exec)
    assert_equal(0100755, File.stat(installed_exec).mode) unless win_platform?

    wrapper = File.read installed_exec
    assert_match %r|generated by RubyGems|, wrapper
  end

  def test_generate_bin_script_no_execs
    util_execless

    @installer.wrappers = true
    @installer.generate_bin

    refute File.exist?(util_inst_bindir), 'bin dir was created when not needed'
  end

  def test_generate_bin_script_no_perms
    @installer.wrappers = true
    util_make_exec

    Dir.mkdir util_inst_bindir

    if win_platform?
      skip('test_generate_bin_script_no_perms skipped on MS Windows')
    else
      File.chmod 0000, util_inst_bindir

      assert_raises Gem::FilePermissionError do
        @installer.generate_bin
      end
    end
  ensure
    File.chmod 0700, util_inst_bindir unless $DEBUG
  end

  def test_generate_bin_script_no_shebang
    @installer.wrappers = true
    @spec.executables = %w[executable]

    gem_dir = File.join @gemhome, 'gems', @spec.full_name
    gem_bindir = File.join gem_dir, 'bin'
    FileUtils.mkdir_p gem_bindir
    File.open File.join(gem_bindir, 'executable'), 'w' do |f|
      f.puts "blah blah blah"
    end

    @installer.generate_bin

    installed_exec = File.join @gemhome, 'bin', 'executable'
    assert_equal true, File.exist?(installed_exec)
    assert_equal 0100755, File.stat(installed_exec).mode unless win_platform?

    wrapper = File.read installed_exec
    assert_match %r|generated by RubyGems|, wrapper
    # HACK some gems don't have #! in their executables, restore 2008/06
    #assert_no_match %r|generated by RubyGems|, wrapper
  end

  def test_generate_bin_script_wrappers
    @installer.wrappers = true
    util_make_exec
    @installer.gem_dir = util_gem_dir
    installed_exec = File.join(util_inst_bindir, 'executable')

    real_exec = File.join util_gem_dir, 'bin', 'executable'

    # fake --no-wrappers for previous install
    unless Gem.win_platform? then
      FileUtils.mkdir_p File.dirname(installed_exec)
      FileUtils.ln_s real_exec, installed_exec
    end

    @installer.generate_bin
    assert_equal true, File.directory?(util_inst_bindir)
    assert_equal true, File.exist?(installed_exec)
    assert_equal(0100755, File.stat(installed_exec).mode) unless win_platform?

    assert_match %r|generated by RubyGems|, File.read(installed_exec)

    refute_match %r|generated by RubyGems|, File.read(real_exec),
                 'real executable overwritten'
  end

  def test_generate_bin_symlink
    return if win_platform? #Windows FS do not support symlinks

    @installer.wrappers = false
    util_make_exec
    @installer.gem_dir = util_gem_dir

    @installer.generate_bin
    assert_equal true, File.directory?(util_inst_bindir)
    installed_exec = File.join(util_inst_bindir, 'executable')
    assert_equal true, File.symlink?(installed_exec)
    assert_equal(File.join(util_gem_dir, 'bin', 'executable'),
                 File.readlink(installed_exec))
  end

  def test_generate_bin_symlink_no_execs
    util_execless

    @installer.wrappers = false
    @installer.generate_bin

    refute File.exist?(util_inst_bindir)
  end

  def test_generate_bin_symlink_no_perms
    @installer.wrappers = false
    util_make_exec
    @installer.gem_dir = util_gem_dir

    Dir.mkdir util_inst_bindir

    if win_platform?
      skip('test_generate_bin_symlink_no_perms skipped on MS Windows')
    else
      File.chmod 0000, util_inst_bindir

      assert_raises Gem::FilePermissionError do
        @installer.generate_bin
      end
    end
  ensure
    File.chmod 0700, util_inst_bindir unless $DEBUG
  end

  def test_generate_bin_symlink_update_newer
    return if win_platform? #Windows FS do not support symlinks

    @installer.wrappers = false
    util_make_exec
    @installer.gem_dir = util_gem_dir

    @installer.generate_bin
    installed_exec = File.join(util_inst_bindir, 'executable')
    assert_equal(File.join(util_gem_dir, 'bin', 'executable'),
                 File.readlink(installed_exec))

    @spec = Gem::Specification.new do |s|
      s.files = ['lib/code.rb']
      s.name = "a"
      s.version = "3"
      s.summary = "summary"
      s.description = "desc"
      s.require_path = 'lib'
    end

    @spec.version = 3
    util_make_exec
    @installer.gem_dir = File.join util_gem_dir @spec
    @installer.generate_bin
    installed_exec = File.join(util_inst_bindir, 'executable')
    assert_equal(File.join(util_gem_bindir(@spec), 'executable'),
                 File.readlink(installed_exec),
                 "Ensure symlink moved to latest version")
  end

  def test_generate_bin_symlink_update_older
    return if win_platform? #Windows FS do not support symlinks

    @installer.wrappers = false
    util_make_exec
    @installer.gem_dir = util_gem_dir

    @installer.generate_bin
    installed_exec = File.join(util_inst_bindir, 'executable')
    assert_equal(File.join(util_gem_dir, 'bin', 'executable'),
                 File.readlink(installed_exec))

    spec = Gem::Specification.new do |s|
      s.files = ['lib/code.rb']
      s.name = "a"
      s.version = "1"
      s.summary = "summary"
      s.description = "desc"
      s.require_path = 'lib'
    end

    util_make_exec
    one = @spec.dup
    one.version = 1
    @installer.gem_dir = util_gem_dir one
    @installer.spec = spec

    @installer.generate_bin

    installed_exec = File.join(util_inst_bindir, 'executable')
    assert_equal(File.join(util_gem_dir, 'bin', 'executable'),
                 File.readlink(installed_exec),
                 "Ensure symlink not moved")
  end

  def test_generate_bin_symlink_update_remove_wrapper
    return if win_platform? #Windows FS do not support symlinks

    @installer.wrappers = true
    util_make_exec
    @installer.gem_dir = util_gem_dir

    @installer.generate_bin
    installed_exec = File.join(util_inst_bindir, 'executable')
    assert_equal true, File.exist?(installed_exec)

    @spec = Gem::Specification.new do |s|
      s.files = ['lib/code.rb']
      s.name = "a"
      s.version = "3"
      s.summary = "summary"
      s.description = "desc"
      s.require_path = 'lib'
    end

    @installer.wrappers = false
    @spec.version = 3
    util_make_exec
    @installer.gem_dir = util_gem_dir
    @installer.generate_bin
    installed_exec = File.join(util_inst_bindir, 'executable')
    assert_equal(File.join(util_gem_dir, 'bin', 'executable'),
                 File.readlink(installed_exec),
                 "Ensure symlink moved to latest version")
  end

  def test_generate_bin_symlink_win32
    old_win_platform = Gem.win_platform?
    Gem.win_platform = true
    @installer.wrappers = false
    util_make_exec
    @installer.gem_dir = util_gem_dir

    use_ui @ui do
      @installer.generate_bin
    end

    assert_equal true, File.directory?(util_inst_bindir)
    installed_exec = File.join(util_inst_bindir, 'executable')
    assert_equal true, File.exist?(installed_exec)

    assert_match(/Unable to use symlinks on Windows, installing wrapper/i,
                 @ui.error)

    wrapper = File.read installed_exec
    assert_match(/generated by RubyGems/, wrapper)
  ensure
    Gem.win_platform = old_win_platform
  end

  def test_generate_bin_uses_default_shebang
    return if win_platform? #Windows FS do not support symlinks

    @installer.wrappers = true
    util_make_exec

    @installer.generate_bin

    default_shebang = Gem.ruby
    shebang_line = open("#{@gemhome}/bin/executable") { |f| f.readlines.first }
    assert_match(/\A#!/, shebang_line)
    assert_match(/#{default_shebang}/, shebang_line)
  end

  def test_initialize
    spec = quick_spec 'a' do |s| s.platform = Gem::Platform.new 'mswin32' end
    gem = File.join @tempdir, spec.file_name

    Dir.mkdir util_inst_bindir
    util_build_gem spec
    FileUtils.mv Gem.cache_gem(spec.file_name, @gemhome), @tempdir

    installer = Gem::Installer.new gem

    assert_equal File.join(@gemhome, 'gems', spec.full_name), installer.gem_dir
  end

  def test_install
    Dir.mkdir util_inst_bindir
    util_setup_gem
    util_clear_gems

    gemdir     = File.join @gemhome, 'gems', @spec.full_name
    cache_file = Gem.cache_gem(@spec.file_name, @gemhome)
    stub_exe   = File.join @gemhome, 'bin', 'executable'
    rakefile   = File.join gemdir, 'ext', 'a', 'Rakefile'

    Gem.pre_install do |installer|
      refute File.exist?(cache_file), 'cache file must not exist yet'
      true
    end

    Gem.post_build do |installer|
      assert File.exist?(gemdir), 'gem install dir must exist'
      assert File.exist?(rakefile), 'gem executable must exist'
      refute File.exist?(stub_exe), 'gem executable must not exist'
      true
    end

    Gem.post_install do |installer|
      assert File.exist?(cache_file), 'cache file must exist'
    end

    build_rake_in do
      use_ui @ui do
        assert_equal @spec, @installer.install
      end
    end

    assert File.exist? gemdir
    assert File.exist?(stub_exe), 'gem executable must exist'

    exe = File.join gemdir, 'bin', 'executable'
    assert File.exist? exe

    exe_mode = File.stat(exe).mode & 0111
    assert_equal 0111, exe_mode, "0%o" % exe_mode unless win_platform?

    assert File.exist?(File.join(gemdir, 'lib', 'code.rb'))

    assert File.exist? rakefile

    spec_file = File.join(@gemhome, 'specifications', @spec.spec_name)

    assert_equal spec_file, @spec.loaded_from
    assert File.exist?(spec_file)

    assert_same @installer, @post_build_hook_arg
    assert_same @installer, @post_install_hook_arg
    assert_same @installer, @pre_install_hook_arg
  end

  def test_install_with_no_prior_files
    Dir.mkdir util_inst_bindir
    util_clear_gems

    util_setup_gem
    build_rake_in do
      use_ui @ui do
        assert_equal @spec, @installer.install
      end
    end

    gemdir = File.join(@gemhome, 'gems', @spec.full_name)
    assert File.exist?(File.join(gemdir, 'lib', 'code.rb'))

    util_setup_gem
    # Morph spec to have lib/other.rb instead of code.rb and recreate
    @spec.files = File.join('lib', 'other.rb')
    Dir.chdir @tempdir do
      File.open File.join('lib', 'other.rb'), 'w' do |f| f.puts '1' end
      use_ui ui do
        FileUtils.rm @gem
        Gem::Builder.new(@spec).build
      end
    end
    @installer = Gem::Installer.new @gem
    build_rake_in do
      use_ui @ui do
        assert_equal @spec, @installer.install
      end
    end

    assert File.exist?(File.join(gemdir, 'lib', 'other.rb'))
    refute(File.exist?(File.join(gemdir, 'lib', 'code.rb')),
           "code.rb from prior install of same gem shouldn't remain here")
  end

  def test_install_bad_gem
    gem = nil

    use_ui @ui do
      Dir.chdir @tempdir do Gem::Builder.new(@spec).build end
      gem = File.join @tempdir, @spec.file_name
    end

    gem_data = File.open gem, 'rb' do |fp| fp.read 1024 end
    File.open gem, 'wb' do |fp| fp.write gem_data end

    e = assert_raises Gem::InstallError do
      use_ui @ui do
        @installer = Gem::Installer.new gem
        @installer.install
      end
    end

    assert_equal "invalid gem format for #{gem}", e.message
  end

  def test_install_check_dependencies
    @spec.add_dependency 'b', '> 5'
    util_setup_gem

    use_ui @ui do
      assert_raises Gem::InstallError do
        @installer.install
      end
    end
  end

  def test_install_check_dependencies_install_dir
    gemhome2 = "#{@gemhome}2"
    @spec.add_dependency 'b'

    b2 = quick_spec 'b', 2

    FileUtils.mv @gemhome, gemhome2
    Gem.source_index.gems.delete b2.full_name
    source_index = Gem::SourceIndex.from_gems_in File.join(gemhome2,
                                                           'specifications')

    util_setup_gem

    @installer = Gem::Installer.new @gem, :install_dir => gemhome2,
                                    :source_index => source_index

    build_rake_in do
      use_ui @ui do
        @installer.install
      end
    end

    assert File.exist?(File.join(gemhome2, 'gems', @spec.full_name))
  end

  def test_install_force
    use_ui @ui do
      installer = Gem::Installer.new old_ruby_required, :force => true
      installer.install
    end

    gem_dir = File.join(@gemhome, 'gems', 'old_ruby_required-1')
    assert File.exist?(gem_dir)
  end

  def test_install_ignore_dependencies
    Dir.mkdir util_inst_bindir
    @spec.add_dependency 'b', '> 5'
    util_setup_gem
    @installer.ignore_dependencies = true

    build_rake_in do
      use_ui @ui do
        assert_equal @spec, @installer.install
      end
    end

    gemdir = File.join @gemhome, 'gems', @spec.full_name
    assert File.exist?(gemdir)

    exe = File.join(gemdir, 'bin', 'executable')
    assert File.exist?(exe)
    exe_mode = File.stat(exe).mode & 0111
    assert_equal 0111, exe_mode, "0%o" % exe_mode unless win_platform?
    assert File.exist?(File.join(gemdir, 'lib', 'code.rb'))

    assert File.exist?(File.join(@gemhome, 'specifications', @spec.spec_name))
  end

  def test_install_missing_dirs
    FileUtils.rm_f Gem.cache_dir
    FileUtils.rm_f File.join(Gem.dir, 'docs')
    FileUtils.rm_f File.join(Gem.dir, 'specifications')

    use_ui @ui do
      Dir.chdir @tempdir do Gem::Builder.new(@spec).build end

      @installer.install
    end

    File.directory? Gem.cache_dir
    File.directory? File.join(Gem.dir, 'docs')
    File.directory? File.join(Gem.dir, 'specifications')

    assert File.exist?(Gem.cache_gem(@spec.file_name, @gemhome))
    assert File.exist?(File.join(@gemhome, 'specifications', @spec.spec_name))
  end

  def test_install_post_build_false
    util_clear_gems

    Gem.post_build do
      false
    end

    use_ui @ui do
      e = assert_raises Gem::InstallError do
        @installer.install
      end

      location = "#{__FILE__}:#{__LINE__ - 9}"

      assert_equal "post-build hook at #{location} failed for a-2", e.message
    end

    spec_file = File.join @gemhome, 'specifications', @spec.spec_name
    refute File.exist? spec_file

    gem_dir = File.join @gemhome, 'gems', @spec.full_name
    refute File.exist? gem_dir
  end

  def test_install_post_build_nil
    util_clear_gems

    Gem.post_build do
      nil
    end

    use_ui @ui do
      @installer.install
    end

    spec_file = File.join @gemhome, 'specifications', @spec.spec_name
    assert File.exist? spec_file

    gem_dir = File.join @gemhome, 'gems', @spec.full_name
    assert File.exist? gem_dir
  end

  def test_install_pre_install_false
    util_clear_gems

    Gem.pre_install do
      false
    end

    use_ui @ui do
      e = assert_raises Gem::InstallError do
        @installer.install
      end

      location = "#{__FILE__}:#{__LINE__ - 9}"

      assert_equal "pre-install hook at #{location} failed for a-2", e.message
    end

    spec_file = File.join @gemhome, 'specifications', @spec.spec_name
    refute File.exist? spec_file
  end

  def test_install_pre_install_nil
    util_clear_gems

    Gem.pre_install do
      nil
    end

    use_ui @ui do
      @installer.install
    end

    spec_file = File.join @gemhome, 'specifications', @spec.spec_name
    assert File.exist? spec_file
  end

  def test_install_with_message
    @spec.post_install_message = 'I am a shiny gem!'

    use_ui @ui do
      Dir.chdir @tempdir do Gem::Builder.new(@spec).build end

      @installer.install
    end

    assert_match %r|I am a shiny gem!|, @ui.output
  end

  def test_install_wrong_ruby_version
    use_ui @ui do
      installer = Gem::Installer.new old_ruby_required
      e = assert_raises Gem::InstallError do
        installer.install
      end
      assert_equal 'old_ruby_required requires Ruby version = 1.4.6.',
                   e.message
    end
  end

  def test_install_wrong_rubygems_version
    spec = quick_spec 'old_rubygems_required', '1' do |s|
      s.required_rubygems_version = '< 0'
    end

    util_build_gem spec

    gem = Gem.cache_gem(spec.file_name, @gemhome)

    use_ui @ui do
      @installer = Gem::Installer.new gem
      e = assert_raises Gem::InstallError do
        @installer.install
      end
      assert_equal 'old_rubygems_required requires RubyGems version < 0. ' +
        "Try 'gem update --system' to update RubyGems itself.", e.message
    end
  end

  def test_installation_satisfies_dependency_eh
    dep = Gem::Dependency.new 'a', '>= 2'
    assert @installer.installation_satisfies_dependency?(dep)

    dep = Gem::Dependency.new 'a', '> 2'
    refute @installer.installation_satisfies_dependency?(dep)
  end

  def test_shebang
    util_make_exec @spec, "#!/usr/bin/ruby"

    shebang = @installer.shebang 'executable'

    assert_equal "#!#{Gem.ruby}", shebang
  end

  def test_shebang_arguments
    util_make_exec @spec, "#!/usr/bin/ruby -ws"

    shebang = @installer.shebang 'executable'

    assert_equal "#!#{Gem.ruby} -ws", shebang
  end

  def test_shebang_empty
    util_make_exec @spec, ''

    shebang = @installer.shebang 'executable'
    assert_equal "#!#{Gem.ruby}", shebang
  end

  def test_shebang_env
    util_make_exec @spec, "#!/usr/bin/env ruby"

    shebang = @installer.shebang 'executable'

    assert_equal "#!#{Gem.ruby}", shebang
  end

  def test_shebang_env_arguments
    util_make_exec @spec, "#!/usr/bin/env ruby -ws"

    shebang = @installer.shebang 'executable'

    assert_equal "#!#{Gem.ruby} -ws", shebang
  end

  def test_shebang_env_shebang
    util_make_exec @spec, ''
    @installer.env_shebang = true

    shebang = @installer.shebang 'executable'

    env_shebang = "/usr/bin/env" unless Gem.win_platform?

    assert_equal("#!#{env_shebang} #{Gem::ConfigMap[:ruby_install_name]}",
                 shebang)
  end

  def test_shebang_nested
    util_make_exec @spec, "#!/opt/local/ruby/bin/ruby"

    shebang = @installer.shebang 'executable'

    assert_equal "#!#{Gem.ruby}", shebang
  end

  def test_shebang_nested_arguments
    util_make_exec @spec, "#!/opt/local/ruby/bin/ruby -ws"

    shebang = @installer.shebang 'executable'

    assert_equal "#!#{Gem.ruby} -ws", shebang
  end

  def test_shebang_version
    util_make_exec @spec, "#!/usr/bin/ruby18"

    shebang = @installer.shebang 'executable'

    assert_equal "#!#{Gem.ruby}", shebang
  end

  def test_shebang_version_arguments
    util_make_exec @spec, "#!/usr/bin/ruby18 -ws"

    shebang = @installer.shebang 'executable'

    assert_equal "#!#{Gem.ruby} -ws", shebang
  end

  def test_shebang_version_env
    util_make_exec @spec, "#!/usr/bin/env ruby18"

    shebang = @installer.shebang 'executable'

    assert_equal "#!#{Gem.ruby}", shebang
  end

  def test_shebang_version_env_arguments
    util_make_exec @spec, "#!/usr/bin/env ruby18 -ws"

    shebang = @installer.shebang 'executable'

    assert_equal "#!#{Gem.ruby} -ws", shebang
  end

  def test_unpack
    util_setup_gem

    dest = File.join @gemhome, 'gems', @spec.full_name

    @installer.unpack dest

    assert File.exist?(File.join(dest, 'lib', 'code.rb'))
    assert File.exist?(File.join(dest, 'bin', 'executable'))
  end

  def test_write_spec
    spec_dir = File.join @gemhome, 'specifications'
    spec_file = File.join spec_dir, @spec.spec_name
    FileUtils.rm spec_file
    refute File.exist?(spec_file)

    @installer.spec = @spec
    @installer.gem_home = @gemhome

    @installer.write_spec

    assert File.exist?(spec_file)
    assert_equal @spec, eval(File.read(spec_file))
  end

  def test_write_spec_writes_cached_spec
    spec_dir = File.join @gemhome, 'specifications'
    spec_file = File.join spec_dir, @spec.spec_name
    FileUtils.rm spec_file
    refute File.exist?(spec_file)

    @spec.files = %w[a.rb b.rb c.rb]

    @installer.spec = @spec
    @installer.gem_home = @gemhome

    @installer.write_spec

    # cached specs have no file manifest:
    @spec.files = []

    assert_equal @spec, eval(File.read(spec_file))
  end

  def old_ruby_required
    spec = quick_spec 'old_ruby_required', '1' do |s|
      s.required_ruby_version = '= 1.4.6'
    end

    util_build_gem spec

    Gem.cache_gem(spec.file_name, @gemhome)
  end

  def util_execless
    @spec = quick_spec 'z'

    gem = File.join @tempdir, @spec.file_name

    @installer = util_installer @spec, gem, @gemhome
  end

end

class Developer < User
  has_and_belongs_to_many :projects, :include => :topics, :order => 'projects.name'

  def self.with_poor_ones(&block)
    with_scope :find => { :conditions => ['salary <= ?', 80000], :order => 'salary' } do
      yield
    end
  end

  scope :poor, :conditions => ['salary <= ?', 80000], :order => 'salary'

  def self.per_page() 10 end
end
require File.expand_path('../../fixtures/classes', __FILE__)

# This group of specs may ONLY contain specs that do successfully create
# an IO instance from the file descriptor returned by #new_fd helper.
describe :io_new, :shared => true do
  before :each do
    @name = tmp("io_new.txt")
    @fd = new_fd @name
  end

  after :each do
    @io.close if @io and !@io.closed?
    rm_r @name
  end

  it "creates an IO instance from a Fixnum argument" do
    @io = IO.send(@method, @fd, "w")
    @io.should be_an_instance_of(IO)
  end

  it "calls #to_int on an object to convert to a Fixnum" do
    obj = mock("file descriptor")
    obj.should_receive(:to_int).and_return(@fd)
    @io = IO.send(@method, obj, "w")
    @io.should be_an_instance_of(IO)
  end

  ruby_version_is "1.9" do
    it "uses the external encoding specified in the mode argument" do
      @io = IO.send(@method, @fd, 'w:utf-8')
      @io.external_encoding.to_s.should == 'UTF-8'
    end

    it "uses the external and the internal encoding specified in the mode argument" do
      @io = IO.send(@method, @fd, 'w:utf-8:ISO-8859-1')
      @io.external_encoding.to_s.should == 'UTF-8'
      @io.internal_encoding.to_s.should == 'ISO-8859-1'
    end

    it "uses the external encoding specified via the :external_encoding option" do
      @io = IO.send(@method, @fd, 'w', {:external_encoding => 'utf-8'})
      @io.external_encoding.to_s.should == 'UTF-8'
    end

    it "uses the internal encoding specified via the :internal_encoding option" do
      @io = IO.send(@method, @fd, 'w', {:internal_encoding => 'iso-8859-1'})
      @io.internal_encoding.to_s.should == 'ISO-8859-1'
    end

    it "uses the colon-separated encodings specified via the :encoding option" do
      @io = IO.send(@method, @fd, 'w', {:encoding => 'utf-8:ISO-8859-1'})
      @io.external_encoding.to_s.should == 'UTF-8'
      @io.internal_encoding.to_s.should == 'ISO-8859-1'
    end

    it "ingores the :encoding option when the :external_encoding option is present" do
      @io = IO.send(@method, @fd, 'w', {:external_encoding => 'utf-8', :encoding => 'iso-8859-1:iso-8859-1'})
      @io.external_encoding.to_s.should == 'UTF-8'
    end

    it "ingores the :encoding option when the :internal_encoding option is present" do
      @io = IO.send(@method, @fd, 'w', {:internal_encoding => 'iso-8859-1', :encoding => 'iso-8859-1:iso-8859-1'})
      @io.internal_encoding.to_s.should == 'ISO-8859-1'
    end

    it "uses the encoding specified via the :mode option hash" do
      @io = IO.send(@method, @fd, {:mode => 'w:utf-8:ISO-8859-1'})
      @io.external_encoding.to_s.should == 'UTF-8'
      @io.internal_encoding.to_s.should == 'ISO-8859-1'
    end

    it "ignores the :internal_encoding option when the same as the external encoding" do
      @io = IO.send(@method, @fd, 'w', {:external_encoding => 'utf-8', :internal_encoding => 'utf-8'})
      @io.external_encoding.to_s.should == 'UTF-8'
      @io.internal_encoding.to_s.should == ''
    end
  end
end

# This group of specs may ONLY contain specs that do not actually create
# an IO instance from the file descriptor returned by #new_fd helper.
describe :io_new_errors, :shared => true do
  before :each do
    @name = tmp("io_new.txt")
    @fd = new_fd @name
  end

  after :each do
    IO.new(@fd, "w").close
    rm_r @name
  end

  it "raises an Errno::EBADF if the file descriptor is not valid" do
    lambda { IO.send(@method, -1, "w") }.should raise_error(Errno::EBADF)
  end

  it "raises an IOError if passed a closed stream" do
    lambda { IO.send(@method, IOSpecs.closed_io.fileno, 'w') }.should raise_error(IOError)
  end

  it "raises an Errno::EINVAL if the new mode is not compatible with the descriptor's current mode" do
    lambda { IO.send(@method, @fd, "r") }.should raise_error(Errno::EINVAL)
  end
end
DIR = File.dirname(__FILE__)

def fib(n)
  return 1 if n <= 1
  fib(n-1) + fib(n-2)
end

def wait(seconds)
  n = (seconds / 0.01).to_i
  n.times do
    sleep(0.01)
    #File.read(DIR + '/yahoo.html')
  end
end

class SimpleApp
  @@responses = {}

  def initialize
    @count = 0
  end

  def deferred?(env)
    false
  end

  def call(env)
    path = env['PATH_INFO'] || env['REQUEST_URI']
    commands = path.split('/')

    @count += 1
    if commands.include?('periodical_activity') and @count % 10 != 1
      return [200, {'Content-Type'=>'text/plain'}, "quick response!\r\n"]
    end

    if commands.include?('fibonacci')
      n = commands.last.to_i
      raise "fibonacci called with n <= 0" if n <= 0
      body = (1..n).to_a.map { |i| fib(i).to_s }.join(' ')
      status = 200

    elsif commands.include?('wait')
      n = commands.last.to_f
      raise "wait called with n <= 0" if n <= 0
      wait(n)
      body = "waited about #{n} seconds"
      status = 200

    elsif commands.include?('bytes')
      n = commands.last.to_i
      raise "bytes called with n <= 0" if n <= 0
      body = @@responses[n] || "C"*n
      status = 200

    elsif commands.include?('fixed')
      n = 20 * 1024;
      body = @@responses[n] || "C"*n
      status = 200

    elsif commands.include?('test_post_length')
      input_body = ""
      while chunk = env['rack.input'].read(512)
        input_body << chunk
      end
      if env['CONTENT_LENGTH'].to_i == input_body.length
        body = "Content-Length matches input length"
        status = 200
      else
        body = "Content-Length doesn't matches input length!
          content_length = #{env['CONTENT_LENGTH'].to_i}
          input_body.length = #{input_body.length}"
        status = 500
      end
    else
      status = 404
      body = "Undefined url"
    end

    body += "\r\n"
    headers = {'Content-Type' => 'text/plain', 'Content-Length' => body.length.to_s }
    [status, headers, [body]]
  end
end


if $0 == __FILE__
  #require DIR + '/../lib/ebb'
  require 'rubygems'
  require 'rack'
  require 'thin'
  require 'ebb'
#  Rack::Handler::Mongrel.run(SimpleApp.new, :Port => 8000)
  Thin::Server.start("0.0.0.0", 8000, SimpleApp.new)
#  Ebb::start_server(SimpleApp.new, :port => 8000)
end
require "rexml/child"
module REXML
	module DTD
		class ElementDecl < Child
			START = "<!ELEMENT"
			START_RE = /^\s*#{START}/um
			PATTERN_RE = /^\s*(#{START}.*?)>/um
			PATTERN_RE = /^\s*#{START}\s+((?:[:\w_][-\.\w_]*:)?[-!\*\.\w_]*)(.*?)>/
			#\s*((((["']).*?\5)|[^\/'">]*)*?)(\/)?>/um, true)

			def initialize match
				@name = match[1]
				@rest = match[2]
			end
		end
	end
end
#
#  tkextlib/bwidget/separator.rb
#                               by Hidetoshi NAGAI (nagai@ai.kyutech.ac.jp)
#

require 'tk'
require 'tkextlib/bwidget.rb'

module Tk
  module BWidget
    class Separator < TkWindow
    end
  end
end

class Tk::BWidget::Separator
  TkCommandNames = ['Separator'.freeze].freeze
  WidgetClassName = 'Separator'.freeze
  WidgetClassNames[WidgetClassName] ||= self
end
class Tree
  include Mongoid::Document

  field :name
  field :evergreen, :type => Boolean

  scope :verdant, where(:evergreen => true)
  default_scope asc(:name)
end
require 'spec_helper'

describe Mongoid::DefaultScope do

  before do
    [ Person, Tree ].each(&:delete_all)
  end

  context "when providing a default scope on root documents" do

    let!(:fir) do
      Tree.create(:name => "Fir",   :evergreen => true )
    end

    let!(:pine) do
      Tree.create(:name => "Pine",  :evergreen => true )
    end

    let!(:birch) do
      Tree.create(:name => "Birch", :evergreen => false)
    end

    it "returns them in the correct order" do
      Tree.all.entries.should == [ birch, fir, pine ]
    end

    it "respects other scopes" do
      Tree.verdant.entries.should == [ fir, pine ]
    end
  end

  context "when providing a default scope on an embedded document" do

    let!(:person) do
      Person.create(:ssn => "111-11-1111")
    end

    let!(:tron) do
      person.videos.create(:title => "Tron")
    end

    let!(:bladerunner) do
      person.videos.create(:title => "Bladerunner")
    end

    it "respects the default scope" do
      person.reload.videos.all.should == [ bladerunner, tron ]
    end
  end
end
require File.expand_path('../../../shared/kernel/singleton_method_undefined', __FILE__)

ruby_version_is "1.9" do
  describe "BasicObject#singleton_method_undefined" do
    it_behaves_like(:singleton_method_undefined, :singleton_method_undefined, BasicObject)
  end
end
require File.dirname(__FILE__) + '/../spec_helper'
require 'mspec/expectations/expectations'
require 'mspec/matchers/equal'

describe EqualMatcher do
  it "matches when actual is equal? to expected" do
    EqualMatcher.new(1).matches?(1).should == true
    EqualMatcher.new(:blue).matches?(:blue).should == true
    EqualMatcher.new(Object).matches?(Object).should == true

    o = Object.new
    EqualMatcher.new(o).matches?(o).should == true
  end

  it "does not match when actual is not a equal? to expected" do
    EqualMatcher.new(1).matches?(1.0).should == false
    EqualMatcher.new(1.5).matches?(1.5).should == false
    EqualMatcher.new("blue").matches?("blue").should == false
    EqualMatcher.new(Hash).matches?(Object).should == false
  end

  it "provides a useful failure message" do
    matcher = EqualMatcher.new("red")
    matcher.matches?("red")
    matcher.failure_message.should == ["Expected \"red\"\n", "to be identical to \"red\"\n"]
  end

  it "provides a useful negative failure message" do
    matcher = EqualMatcher.new(1)
    matcher.matches?(1)
    matcher.negative_failure_message.should == ["Expected 1\n", "not to be identical to 1\n"]
  end
end
class ::Object #:nodoc:
  def meta_class
    class << self; self end
  end
end

#!/usr/bin/env ruby
require 'tk'
require 'tkextlib/blt'

graph = Tk::BLT::Graph.new.pack
plot = graph.element_create
plot.configure(:linewidth=>0, :label=>'foo', 
               :data=>[[1.0, 3.4], [1.1, 2.8], [1.2, 3.1], [1.4, 2.9]].flatten)

Tk.mainloop
module Git
  class Author
    attr_accessor :name, :email, :date
    
    def initialize(author_string)
      if m = /(.*?) <(.*?)> (\d+) (.*)/.match(author_string)
        @name = m[1]
        @email = m[2]
        @date = Time.at(m[3].to_i)
      end
    end
    
  end
endclass MockObject
  def initialize(name, options={})
    @name = name
    @null = options[:null_object]
  end

  def method_missing(sym, *args, &block)
    @null ? self : super
  end
  private :method_missing
end

class NumericMockObject < Numeric
  def initialize(name, options={})
    @name = name
    @null = options[:null_object]
  end

  def method_missing(sym, *args, &block)
    @null ? self : super
  end

  def singleton_method_added(val)
  end
end

class MockProxy
  attr_reader :raising, :yielding

  def initialize(type=nil)
    @multiple_returns = nil
    @returning = nil
    @raising   = nil
    @yielding  = []
    @arguments = :any_args
    @type      = type || :mock
  end

  def mock?
    @type == :mock
  end

  def stub?
    @type == :stub
  end

  def count
    @count ||= mock? ? [:exactly, 1] : [:any_number_of_times, 0]
  end

  def arguments
    @arguments
  end

  def returning
    if @multiple_returns
      if @returning.size == 1
        @multiple_returns = false
        return @returning = @returning.shift
      end
      return @returning.shift
    end
    @returning
  end

  def times
    self
  end

  def calls
    @calls ||= 0
  end

  def called
    @calls = calls + 1
  end

  def exactly(n)
    @count = [:exactly, n_times(n)]
    self
  end

  def at_least(n)
    @count = [:at_least, n_times(n)]
    self
  end

  def at_most(n)
    @count = [:at_most, n_times(n)]
    self
  end

  def once
    exactly 1
  end

  def twice
    exactly 2
  end

  def any_number_of_times
    @count = [:any_number_of_times, 0]
    self
  end

  def with(*args)
    raise ArgumentError, "you must specify the expected arguments" if args.empty?
    @arguments = *args
    behaves_like_ruby_1_9 = *[]
    if (behaves_like_ruby_1_9)
      @arguments = @arguments.first if @arguments.length <= 1
    end
    self
  end

  def and_return(*args)
    case args.size
    when 0
      @returning = nil
    when 1
      @returning = args[0]
    else
      @multiple_returns = true
      @returning = args
      count[1] = args.size if count[1] < args.size
    end
    self
  end

  def and_raise(exception)
    if exception.kind_of? String
      @raising = RuntimeError.new exception
    else
      @raising = exception
    end
  end

  def raising?
    @raising != nil
  end

  def and_yield(*args)
    @yielding << args
    self
  end

  def yielding?
    !@yielding.empty?
  end

  private

  def n_times(n)
    case n
    when :once
      1
    when :twice
      2
    else
      Integer n
    end
  end
end

# line 1 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
require 'gherkin/lexer/i18n_lexer'

module Gherkin
  module RbLexer
    class Tr #:nodoc:
      
# line 127 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"

 
      def initialize(listener)
        @listener = listener
        
# line 16 "lib/gherkin/rb_lexer/tr.rb"
class << self
	attr_accessor :_lexer_actions
	private :_lexer_actions, :_lexer_actions=
end
self._lexer_actions = [
	0, 1, 0, 1, 1, 1, 2, 1, 
	3, 1, 4, 1, 5, 1, 6, 1, 
	7, 1, 8, 1, 9, 1, 10, 1, 
	11, 1, 14, 1, 15, 1, 16, 1, 
	17, 1, 18, 1, 19, 1, 20, 1, 
	21, 2, 2, 16, 2, 11, 0, 2, 
	12, 13, 2, 15, 0, 2, 15, 1, 
	2, 15, 14, 2, 15, 17, 2, 16, 
	4, 2, 16, 5, 2, 16, 6, 2, 
	16, 7, 2, 16, 8, 2, 16, 14, 
	2, 18, 19, 2, 20, 0, 2, 20, 
	1, 2, 20, 14, 2, 20, 17, 3, 
	3, 12, 13, 3, 9, 12, 13, 3, 
	10, 12, 13, 3, 11, 12, 13, 3, 
	12, 13, 16, 3, 15, 12, 13, 4, 
	2, 12, 13, 16, 4, 15, 0, 12, 
	13
]

class << self
	attr_accessor :_lexer_key_offsets
	private :_lexer_key_offsets, :_lexer_key_offsets=
end
self._lexer_key_offsets = [
	0, 0, 20, 21, 23, 24, 25, 26, 
	27, 28, 29, 30, 31, 32, 39, 41, 
	43, 45, 47, 49, 51, 53, 55, 74, 
	93, 94, 95, 99, 104, 109, 114, 119, 
	123, 127, 129, 130, 131, 132, 133, 134, 
	135, 136, 137, 138, 139, 140, 141, 142, 
	143, 144, 145, 146, 148, 153, 160, 165, 
	166, 167, 168, 169, 170, 171, 172, 173, 
	174, 175, 176, 177, 178, 179, 180, 181, 
	182, 183, 184, 185, 186, 187, 188, 189, 
	190, 191, 192, 193, 194, 210, 212, 214, 
	216, 218, 220, 222, 224, 226, 228, 230, 
	232, 234, 236, 238, 240, 242, 244, 246, 
	248, 250, 252, 254, 256, 258, 260, 262, 
	264, 266, 268, 270, 272, 274, 276, 278, 
	280, 282, 284, 286, 288, 290, 292, 294, 
	296, 298, 300, 302, 304, 306, 308, 310, 
	312, 314, 316, 318, 321, 323, 325, 327, 
	329, 331, 333, 335, 337, 339, 341, 342, 
	343, 344, 345, 346, 347, 348, 349, 350, 
	351, 352, 353, 355, 356, 357, 358, 359, 
	360, 361, 362, 363, 364, 365, 366, 367, 
	383, 385, 387, 389, 391, 393, 395, 397, 
	399, 401, 403, 405, 407, 409, 411, 413, 
	415, 417, 419, 421, 423, 425, 427, 429, 
	431, 433, 435, 437, 439, 441, 443, 445, 
	447, 449, 451, 453, 455, 457, 459, 461, 
	463, 465, 467, 469, 471, 473, 475, 477, 
	479, 481, 483, 485, 487, 489, 491, 493, 
	494, 495, 512, 514, 516, 518, 520, 522, 
	524, 526, 528, 530, 532, 534, 536, 538, 
	540, 542, 544, 546, 548, 550, 552, 554, 
	556, 558, 560, 562, 564, 566, 568, 570, 
	572, 574, 576, 578, 580, 582, 584, 586, 
	588, 590, 592, 594, 596, 598, 600, 602, 
	604, 606, 608, 610, 612, 614, 616, 618, 
	620, 622, 624, 626, 628, 630, 632, 634, 
	637, 639, 641, 643, 645, 647, 649, 651, 
	653, 655, 657, 658, 662, 668, 671, 673, 
	679, 698, 699, 700, 701, 702, 703, 704, 
	705, 706, 716, 718, 721, 723, 725, 727, 
	729, 731, 733, 735, 737, 739, 741, 743, 
	745, 747, 749, 751, 753, 755, 757, 759, 
	761, 763, 765, 767, 769, 771, 773, 775, 
	777, 779, 781, 783, 785, 787, 789, 791, 
	793, 795, 797, 799, 802, 804, 806, 808, 
	810, 812, 814, 816, 818, 820, 821, 822
]

class << self
	attr_accessor :_lexer_trans_keys
	private :_lexer_trans_keys, :_lexer_trans_keys=
end
self._lexer_trans_keys = [
	-61, -17, 10, 32, 34, 35, 37, 42, 
	64, 65, 68, 69, 70, 71, 79, 83, 
	86, 124, 9, 13, -106, 114, 122, 110, 
	101, 107, 108, 101, 114, 58, 10, 10, 
	-61, 10, 32, 35, 124, 9, 13, -106, 
	10, 10, 122, 10, 101, 10, 108, 10, 
	108, 10, 105, 10, 107, 10, 58, -61, 
	10, 32, 34, 35, 37, 42, 64, 65, 
	68, 69, 70, 71, 79, 83, 86, 124, 
	9, 13, -61, 10, 32, 34, 35, 37, 
	42, 64, 65, 68, 69, 70, 71, 79, 
	83, 86, 124, 9, 13, 34, 34, 10, 
	32, 9, 13, 10, 32, 34, 9, 13, 
	10, 32, 34, 9, 13, 10, 32, 34, 
	9, 13, 10, 32, 34, 9, 13, 10, 
	32, 9, 13, 10, 32, 9, 13, 10, 
	13, 10, 95, 70, 69, 65, 84, 85, 
	82, 69, 95, 69, 78, 68, 95, 37, 
	32, 10, 10, 13, 13, 32, 64, 9, 
	10, 9, 10, 13, 32, 64, 11, 12, 
	10, 32, 64, 9, 13, 109, 97, 105, 
	121, 101, 108, 105, 109, 32, 107, 105, 
	-60, -97, 101, 114, 97, 107, 97, 116, 
	101, -61, -89, 109, 105, -59, -97, 58, 
	10, 10, -61, 10, 32, 35, 37, 42, 
	64, 65, 68, 69, 70, 79, 83, 86, 
	9, 13, -106, 10, 10, 122, 10, 101, 
	10, 108, 10, 108, 10, 105, 10, 107, 
	10, 58, 10, 95, 10, 70, 10, 69, 
	10, 65, 10, 84, 10, 85, 10, 82, 
	10, 69, 10, 95, 10, 69, 10, 78, 
	10, 68, 10, 95, 10, 37, 10, 32, 
	10, 109, 10, 97, 10, 105, 10, 121, 
	10, 101, 10, 108, 10, 105, 10, 109, 
	10, 32, 10, 107, 10, 105, -60, 10, 
	-97, 10, 10, 101, 10, 114, 10, 97, 
	10, 107, 10, 97, 10, 116, 10, 32, 
	10, 122, 10, 97, 10, 109, 10, 97, 
	10, 110, 10, 101, 10, 110, 10, 97, 
	10, 114, 10, 121, 10, 111, 10, 32, 
	58, 10, 116, 10, 97, 10, 115, 10, 
	108, 10, 97, -60, 10, -97, 10, -60, 
	10, -79, 10, 10, 101, 32, 122, 97, 
	109, 97, 110, 101, 110, 97, 114, 121, 
	111, 32, 58, 116, 97, 115, 108, 97, 
	-60, -97, -60, -79, 58, 10, 10, -61, 
	10, 32, 35, 37, 42, 64, 65, 68, 
	69, 70, 79, 83, 86, 9, 13, -106, 
	10, 10, 122, 10, 101, 10, 108, 10, 
	108, 10, 105, 10, 107, 10, 58, 10, 
	95, 10, 70, 10, 69, 10, 65, 10, 
	84, 10, 85, 10, 82, 10, 69, 10, 
	95, 10, 69, 10, 78, 10, 68, 10, 
	95, 10, 37, 10, 32, 10, 109, 10, 
	97, 10, 105, 10, 121, 10, 101, 10, 
	108, 10, 105, 10, 109, 10, 32, 10, 
	107, 10, 105, -60, 10, -97, 10, 10, 
	101, 10, 114, 10, 97, 10, 107, 10, 
	97, 10, 116, 10, 32, 10, 122, 10, 
	97, 10, 109, 10, 97, 10, 110, 10, 
	101, 10, 110, 10, 97, 10, 114, 10, 
	121, 10, 111, 10, 101, 10, 10, -61, 
	10, 32, 35, 37, 42, 64, 65, 68, 
	69, 70, 71, 79, 83, 86, 9, 13, 
	-106, 10, 10, 122, 10, 101, 10, 108, 
	10, 108, 10, 105, 10, 107, 10, 58, 
	10, 95, 10, 70, 10, 69, 10, 65, 
	10, 84, 10, 85, 10, 82, 10, 69, 
	10, 95, 10, 69, 10, 78, 10, 68, 
	10, 95, 10, 37, 10, 32, 10, 109, 
	10, 97, 10, 105, 10, 121, 10, 101, 
	10, 108, 10, 105, 10, 109, 10, 32, 
	10, 107, 10, 105, -60, 10, -97, 10, 
	10, 101, 10, 114, 10, 97, 10, 107, 
	10, 97, 10, 116, 10, 101, -61, 10, 
	-89, 10, 10, 109, 10, 105, -59, 10, 
	-97, 10, 10, 32, 10, 122, 10, 97, 
	10, 109, 10, 97, 10, 110, 10, 101, 
	10, 110, 10, 97, 10, 114, 10, 121, 
	10, 111, 10, 32, 58, 10, 116, 10, 
	97, 10, 115, 10, 108, 10, 97, -60, 
	10, -97, 10, -60, 10, -79, 10, 10, 
	101, 101, 32, 124, 9, 13, 10, 32, 
	92, 124, 9, 13, 10, 92, 124, 10, 
	92, 10, 32, 92, 124, 9, 13, -61, 
	10, 32, 34, 35, 37, 42, 64, 65, 
	68, 69, 70, 71, 79, 83, 86, 124, 
	9, 13, 101, 108, 108, 105, 107, 58, 
	10, 10, -61, 10, 32, 35, 37, 64, 
	71, 83, 9, 13, -106, 10, 10, 114, 
	122, 10, 110, 10, 101, 10, 107, 10, 
	108, 10, 101, 10, 114, 10, 58, 10, 
	101, 10, 108, 10, 108, 10, 105, 10, 
	107, 10, 95, 10, 70, 10, 69, 10, 
	65, 10, 84, 10, 85, 10, 82, 10, 
	69, 10, 95, 10, 69, 10, 78, 10, 
	68, 10, 95, 10, 37, 10, 101, -61, 
	10, -89, 10, 10, 109, 10, 105, -59, 
	10, -97, 10, 10, 101, 10, 110, 10, 
	97, 10, 114, 10, 121, 10, 111, 10, 
	32, 58, 10, 116, 10, 97, 10, 115, 
	10, 108, 10, 97, -60, 10, -97, 10, 
	-60, 10, -79, 10, -69, -65, 0
]

class << self
	attr_accessor :_lexer_single_lengths
	private :_lexer_single_lengths, :_lexer_single_lengths=
end
self._lexer_single_lengths = [
	0, 18, 1, 2, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 5, 2, 2, 
	2, 2, 2, 2, 2, 2, 17, 17, 
	1, 1, 2, 3, 3, 3, 3, 2, 
	2, 2, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 2, 3, 5, 3, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 14, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 3, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 2, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 14, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 1, 
	1, 15, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 3, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 1, 2, 4, 3, 2, 4, 
	17, 1, 1, 1, 1, 1, 1, 1, 
	1, 8, 2, 3, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 3, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 1, 1, 0
]

class << self
	attr_accessor :_lexer_range_lengths
	private :_lexer_range_lengths, :_lexer_range_lengths=
end
self._lexer_range_lengths = [
	0, 1, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 0, 0, 
	0, 0, 0, 0, 0, 0, 1, 1, 
	0, 0, 1, 1, 1, 1, 1, 1, 
	1, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 1, 1, 1, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 1, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 1, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 1, 0, 0, 1, 
	1, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0
]

class << self
	attr_accessor :_lexer_index_offsets
	private :_lexer_index_offsets, :_lexer_index_offsets=
end
self._lexer_index_offsets = [
	0, 0, 20, 22, 25, 27, 29, 31, 
	33, 35, 37, 39, 41, 43, 50, 53, 
	56, 59, 62, 65, 68, 71, 74, 93, 
	112, 114, 116, 120, 125, 130, 135, 140, 
	144, 148, 151, 153, 155, 157, 159, 161, 
	163, 165, 167, 169, 171, 173, 175, 177, 
	179, 181, 183, 185, 188, 193, 200, 205, 
	207, 209, 211, 213, 215, 217, 219, 221, 
	223, 225, 227, 229, 231, 233, 235, 237, 
	239, 241, 243, 245, 247, 249, 251, 253, 
	255, 257, 259, 261, 263, 279, 282, 285, 
	288, 291, 294, 297, 300, 303, 306, 309, 
	312, 315, 318, 321, 324, 327, 330, 333, 
	336, 339, 342, 345, 348, 351, 354, 357, 
	360, 363, 366, 369, 372, 375, 378, 381, 
	384, 387, 390, 393, 396, 399, 402, 405, 
	408, 411, 414, 417, 420, 423, 426, 429, 
	432, 435, 438, 441, 445, 448, 451, 454, 
	457, 460, 463, 466, 469, 472, 475, 477, 
	479, 481, 483, 485, 487, 489, 491, 493, 
	495, 497, 499, 502, 504, 506, 508, 510, 
	512, 514, 516, 518, 520, 522, 524, 526, 
	542, 545, 548, 551, 554, 557, 560, 563, 
	566, 569, 572, 575, 578, 581, 584, 587, 
	590, 593, 596, 599, 602, 605, 608, 611, 
	614, 617, 620, 623, 626, 629, 632, 635, 
	638, 641, 644, 647, 650, 653, 656, 659, 
	662, 665, 668, 671, 674, 677, 680, 683, 
	686, 689, 692, 695, 698, 701, 704, 707, 
	709, 711, 728, 731, 734, 737, 740, 743, 
	746, 749, 752, 755, 758, 761, 764, 767, 
	770, 773, 776, 779, 782, 785, 788, 791, 
	794, 797, 800, 803, 806, 809, 812, 815, 
	818, 821, 824, 827, 830, 833, 836, 839, 
	842, 845, 848, 851, 854, 857, 860, 863, 
	866, 869, 872, 875, 878, 881, 884, 887, 
	890, 893, 896, 899, 902, 905, 908, 911, 
	915, 918, 921, 924, 927, 930, 933, 936, 
	939, 942, 945, 947, 951, 957, 961, 964, 
	970, 989, 991, 993, 995, 997, 999, 1001, 
	1003, 1005, 1015, 1018, 1022, 1025, 1028, 1031, 
	1034, 1037, 1040, 1043, 1046, 1049, 1052, 1055, 
	1058, 1061, 1064, 1067, 1070, 1073, 1076, 1079, 
	1082, 1085, 1088, 1091, 1094, 1097, 1100, 1103, 
	1106, 1109, 1112, 1115, 1118, 1121, 1124, 1127, 
	1130, 1133, 1136, 1139, 1143, 1146, 1149, 1152, 
	1155, 1158, 1161, 1164, 1167, 1170, 1172, 1174
]

class << self
	attr_accessor :_lexer_trans_targs
	private :_lexer_trans_targs, :_lexer_trans_targs=
end
self._lexer_trans_targs = [
	2, 373, 23, 23, 24, 33, 35, 49, 
	52, 55, 57, 66, 70, 74, 150, 156, 
	306, 307, 23, 0, 3, 0, 4, 313, 
	0, 5, 0, 6, 0, 7, 0, 8, 
	0, 9, 0, 10, 0, 11, 0, 13, 
	12, 13, 12, 14, 13, 13, 23, 23, 
	13, 12, 15, 13, 12, 13, 16, 12, 
	13, 17, 12, 13, 18, 12, 13, 19, 
	12, 13, 20, 12, 13, 21, 12, 13, 
	22, 12, 2, 23, 23, 24, 33, 35, 
	49, 52, 55, 57, 66, 70, 74, 150, 
	156, 306, 307, 23, 0, 2, 23, 23, 
	24, 33, 35, 49, 52, 55, 57, 66, 
	70, 74, 150, 156, 306, 307, 23, 0, 
	25, 0, 26, 0, 27, 26, 26, 0, 
	28, 28, 29, 28, 28, 28, 28, 29, 
	28, 28, 28, 28, 30, 28, 28, 28, 
	28, 31, 28, 28, 23, 32, 32, 0, 
	23, 32, 32, 0, 23, 34, 33, 23, 
	0, 36, 0, 37, 0, 38, 0, 39, 
	0, 40, 0, 41, 0, 42, 0, 43, 
	0, 44, 0, 45, 0, 46, 0, 47, 
	0, 48, 0, 375, 0, 50, 0, 0, 
	51, 23, 34, 51, 0, 0, 0, 0, 
	53, 54, 23, 54, 54, 52, 53, 53, 
	23, 54, 52, 54, 0, 56, 0, 49, 
	0, 58, 0, 59, 0, 60, 0, 61, 
	0, 62, 0, 63, 0, 64, 0, 65, 
	0, 49, 0, 67, 0, 68, 0, 69, 
	0, 63, 0, 71, 0, 72, 0, 73, 
	0, 49, 0, 75, 0, 76, 0, 77, 
	0, 78, 0, 79, 0, 80, 0, 81, 
	0, 82, 0, 84, 83, 84, 83, 85, 
	84, 84, 23, 93, 107, 23, 108, 110, 
	119, 123, 127, 133, 149, 84, 83, 86, 
	84, 83, 84, 87, 83, 84, 88, 83, 
	84, 89, 83, 84, 90, 83, 84, 91, 
	83, 84, 92, 83, 84, 22, 83, 84, 
	94, 83, 84, 95, 83, 84, 96, 83, 
	84, 97, 83, 84, 98, 83, 84, 99, 
	83, 84, 100, 83, 84, 101, 83, 84, 
	102, 83, 84, 103, 83, 84, 104, 83, 
	84, 105, 83, 84, 106, 83, 84, 23, 
	83, 84, 22, 83, 84, 109, 83, 84, 
	107, 83, 84, 111, 83, 84, 112, 83, 
	84, 113, 83, 84, 114, 83, 84, 115, 
	83, 84, 116, 83, 84, 117, 83, 84, 
	118, 83, 84, 107, 83, 120, 84, 83, 
	121, 84, 83, 84, 122, 83, 84, 116, 
	83, 84, 124, 83, 84, 125, 83, 84, 
	126, 83, 84, 107, 83, 84, 128, 83, 
	84, 129, 83, 84, 130, 83, 84, 131, 
	83, 84, 132, 83, 84, 107, 83, 84, 
	134, 83, 84, 135, 83, 84, 136, 83, 
	84, 137, 83, 84, 138, 83, 84, 139, 
	83, 84, 140, 22, 83, 84, 141, 83, 
	84, 142, 83, 84, 143, 83, 84, 144, 
	83, 84, 145, 83, 146, 84, 83, 147, 
	84, 83, 148, 84, 83, 92, 84, 83, 
	84, 107, 83, 151, 0, 152, 0, 153, 
	0, 154, 0, 155, 0, 49, 0, 157, 
	0, 158, 0, 159, 0, 160, 0, 161, 
	0, 162, 0, 163, 231, 0, 164, 0, 
	165, 0, 166, 0, 167, 0, 168, 0, 
	169, 0, 170, 0, 171, 0, 172, 0, 
	173, 0, 175, 174, 175, 174, 176, 175, 
	175, 23, 184, 198, 23, 199, 201, 210, 
	214, 218, 224, 230, 175, 174, 177, 175, 
	174, 175, 178, 174, 175, 179, 174, 175, 
	180, 174, 175, 181, 174, 175, 182, 174, 
	175, 183, 174, 175, 22, 174, 175, 185, 
	174, 175, 186, 174, 175, 187, 174, 175, 
	188, 174, 175, 189, 174, 175, 190, 174, 
	175, 191, 174, 175, 192, 174, 175, 193, 
	174, 175, 194, 174, 175, 195, 174, 175, 
	196, 174, 175, 197, 174, 175, 23, 174, 
	175, 22, 174, 175, 200, 174, 175, 198, 
	174, 175, 202, 174, 175, 203, 174, 175, 
	204, 174, 175, 205, 174, 175, 206, 174, 
	175, 207, 174, 175, 208, 174, 175, 209, 
	174, 175, 198, 174, 211, 175, 174, 212, 
	175, 174, 175, 213, 174, 175, 207, 174, 
	175, 215, 174, 175, 216, 174, 175, 217, 
	174, 175, 198, 174, 175, 219, 174, 175, 
	220, 174, 175, 221, 174, 175, 222, 174, 
	175, 223, 174, 175, 198, 174, 175, 225, 
	174, 175, 226, 174, 175, 227, 174, 175, 
	228, 174, 175, 229, 174, 175, 183, 174, 
	175, 198, 174, 233, 232, 233, 232, 234, 
	233, 233, 23, 242, 256, 23, 257, 259, 
	268, 272, 276, 283, 289, 305, 233, 232, 
	235, 233, 232, 233, 236, 232, 233, 237, 
	232, 233, 238, 232, 233, 239, 232, 233, 
	240, 232, 233, 241, 232, 233, 22, 232, 
	233, 243, 232, 233, 244, 232, 233, 245, 
	232, 233, 246, 232, 233, 247, 232, 233, 
	248, 232, 233, 249, 232, 233, 250, 232, 
	233, 251, 232, 233, 252, 232, 233, 253, 
	232, 233, 254, 232, 233, 255, 232, 233, 
	23, 232, 233, 22, 232, 233, 258, 232, 
	233, 256, 232, 233, 260, 232, 233, 261, 
	232, 233, 262, 232, 233, 263, 232, 233, 
	264, 232, 233, 265, 232, 233, 266, 232, 
	233, 267, 232, 233, 256, 232, 269, 233, 
	232, 270, 233, 232, 233, 271, 232, 233, 
	265, 232, 233, 273, 232, 233, 274, 232, 
	233, 275, 232, 233, 256, 232, 233, 277, 
	232, 278, 233, 232, 279, 233, 232, 233, 
	280, 232, 233, 281, 232, 282, 233, 232, 
	241, 233, 232, 233, 284, 232, 233, 285, 
	232, 233, 286, 232, 233, 287, 232, 233, 
	288, 232, 233, 256, 232, 233, 290, 232, 
	233, 291, 232, 233, 292, 232, 233, 293, 
	232, 233, 294, 232, 233, 295, 232, 233, 
	296, 22, 232, 233, 297, 232, 233, 298, 
	232, 233, 299, 232, 233, 300, 232, 233, 
	301, 232, 302, 233, 232, 303, 233, 232, 
	304, 233, 232, 241, 233, 232, 233, 256, 
	232, 49, 0, 307, 308, 307, 0, 312, 
	311, 310, 308, 311, 309, 0, 310, 308, 
	309, 0, 310, 309, 312, 311, 310, 308, 
	311, 309, 2, 312, 312, 24, 33, 35, 
	49, 52, 55, 57, 66, 70, 74, 150, 
	156, 306, 307, 312, 0, 314, 0, 315, 
	0, 316, 0, 317, 0, 318, 0, 319, 
	0, 321, 320, 321, 320, 322, 321, 321, 
	23, 336, 23, 350, 357, 321, 320, 323, 
	321, 320, 321, 324, 331, 320, 321, 325, 
	320, 321, 326, 320, 321, 327, 320, 321, 
	328, 320, 321, 329, 320, 321, 330, 320, 
	321, 22, 320, 321, 332, 320, 321, 333, 
	320, 321, 334, 320, 321, 335, 320, 321, 
	330, 320, 321, 337, 320, 321, 338, 320, 
	321, 339, 320, 321, 340, 320, 321, 341, 
	320, 321, 342, 320, 321, 343, 320, 321, 
	344, 320, 321, 345, 320, 321, 346, 320, 
	321, 347, 320, 321, 348, 320, 321, 349, 
	320, 321, 23, 320, 321, 351, 320, 352, 
	321, 320, 353, 321, 320, 321, 354, 320, 
	321, 355, 320, 356, 321, 320, 330, 321, 
	320, 321, 358, 320, 321, 359, 320, 321, 
	360, 320, 321, 361, 320, 321, 362, 320, 
	321, 363, 320, 321, 364, 22, 320, 321, 
	365, 320, 321, 366, 320, 321, 367, 320, 
	321, 368, 320, 321, 369, 320, 370, 321, 
	320, 371, 321, 320, 372, 321, 320, 330, 
	321, 320, 374, 0, 23, 0, 0, 0
]

class << self
	attr_accessor :_lexer_trans_actions
	private :_lexer_trans_actions, :_lexer_trans_actions=
end
self._lexer_trans_actions = [
	25, 0, 47, 0, 3, 1, 0, 25, 
	1, 25, 25, 25, 25, 25, 25, 25, 
	25, 31, 0, 39, 0, 39, 0, 0, 
	39, 0, 39, 0, 39, 0, 39, 0, 
	39, 0, 39, 0, 39, 0, 39, 124, 
	50, 47, 0, 77, 47, 0, 74, 74, 
	0, 0, 0, 47, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	17, 0, 56, 115, 27, 53, 50, 27, 
	56, 50, 56, 56, 56, 56, 56, 56, 
	56, 56, 59, 27, 39, 25, 47, 0, 
	3, 1, 0, 25, 1, 25, 25, 25, 
	25, 25, 25, 25, 25, 31, 0, 39, 
	0, 39, 0, 39, 47, 0, 0, 39, 
	119, 41, 41, 41, 5, 111, 29, 29, 
	29, 0, 111, 29, 29, 29, 0, 111, 
	29, 0, 29, 0, 95, 7, 7, 39, 
	47, 0, 0, 39, 103, 21, 0, 47, 
	39, 0, 39, 0, 39, 0, 39, 0, 
	39, 0, 39, 0, 39, 0, 39, 0, 
	39, 0, 39, 0, 39, 0, 39, 0, 
	39, 0, 39, 0, 39, 0, 39, 39, 
	50, 99, 19, 0, 39, 39, 39, 39, 
	0, 23, 107, 23, 23, 44, 23, 0, 
	47, 0, 1, 0, 39, 0, 39, 0, 
	39, 0, 39, 0, 39, 0, 39, 0, 
	39, 0, 39, 0, 39, 0, 39, 0, 
	39, 0, 39, 0, 39, 0, 39, 0, 
	39, 0, 39, 0, 39, 0, 39, 0, 
	39, 0, 39, 0, 39, 0, 39, 0, 
	39, 0, 39, 0, 39, 0, 39, 0, 
	39, 0, 39, 124, 50, 47, 0, 77, 
	47, 0, 65, 29, 77, 65, 77, 77, 
	77, 77, 77, 77, 77, 0, 0, 0, 
	47, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 11, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 11, 
	0, 47, 11, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 0, 47, 0, 
	0, 47, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 11, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	47, 0, 0, 0, 39, 0, 39, 0, 
	39, 0, 39, 0, 39, 0, 39, 0, 
	39, 0, 39, 0, 39, 0, 39, 0, 
	39, 0, 39, 0, 0, 39, 0, 39, 
	0, 39, 0, 39, 0, 39, 0, 39, 
	0, 39, 0, 39, 0, 39, 0, 39, 
	0, 39, 124, 50, 47, 0, 77, 47, 
	0, 71, 29, 77, 71, 77, 77, 77, 
	77, 77, 77, 77, 0, 0, 0, 47, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 15, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 15, 0, 
	47, 15, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 0, 47, 0, 0, 
	47, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 124, 50, 47, 0, 77, 
	47, 0, 68, 29, 77, 68, 77, 77, 
	77, 77, 77, 77, 77, 77, 0, 0, 
	0, 47, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 13, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	13, 0, 47, 13, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 0, 47, 
	0, 0, 47, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 0, 47, 0, 0, 47, 0, 47, 
	0, 0, 47, 0, 0, 0, 47, 0, 
	0, 47, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 13, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 47, 0, 
	0, 0, 39, 0, 0, 0, 39, 47, 
	33, 33, 80, 33, 33, 39, 0, 35, 
	0, 39, 0, 0, 47, 0, 0, 35, 
	0, 0, 89, 47, 0, 86, 83, 37, 
	89, 83, 89, 89, 89, 89, 89, 89, 
	89, 89, 92, 0, 39, 0, 39, 0, 
	39, 0, 39, 0, 39, 0, 39, 0, 
	39, 124, 50, 47, 0, 77, 47, 0, 
	62, 29, 62, 77, 77, 0, 0, 0, 
	47, 0, 47, 0, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 9, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 47, 0, 
	0, 47, 9, 0, 47, 0, 0, 0, 
	47, 0, 0, 47, 0, 47, 0, 0, 
	47, 0, 0, 0, 47, 0, 0, 47, 
	0, 47, 0, 0, 47, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 9, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 47, 0, 0, 0, 47, 
	0, 0, 47, 0, 0, 47, 0, 0, 
	47, 0, 0, 39, 0, 39, 0, 0
]

class << self
	attr_accessor :_lexer_eof_actions
	private :_lexer_eof_actions, :_lexer_eof_actions=
end
self._lexer_eof_actions = [
	0, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39
]

class << self
	attr_accessor :lexer_start
end
self.lexer_start = 1;
class << self
	attr_accessor :lexer_first_final
end
self.lexer_first_final = 375;
class << self
	attr_accessor :lexer_error
end
self.lexer_error = 0;

class << self
	attr_accessor :lexer_en_main
end
self.lexer_en_main = 1;


# line 132 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
      end
 
      def scan(data)
        data = (data + "\n%_FEATURE_END_%").unpack("c*") # Explicit EOF simplifies things considerably
        eof = pe = data.length
 
        @line_number = 1
        @last_newline = 0
 
        
# line 759 "lib/gherkin/rb_lexer/tr.rb"
begin
	p ||= 0
	pe ||= data.length
	cs = lexer_start
end

# line 142 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
        
# line 768 "lib/gherkin/rb_lexer/tr.rb"
begin
	_klen, _trans, _keys, _acts, _nacts = nil
	_goto_level = 0
	_resume = 10
	_eof_trans = 15
	_again = 20
	_test_eof = 30
	_out = 40
	while true
	_trigger_goto = false
	if _goto_level <= 0
	if p == pe
		_goto_level = _test_eof
		next
	end
	if cs == 0
		_goto_level = _out
		next
	end
	end
	if _goto_level <= _resume
	_keys = _lexer_key_offsets[cs]
	_trans = _lexer_index_offsets[cs]
	_klen = _lexer_single_lengths[cs]
	_break_match = false
	
	begin
	  if _klen > 0
	     _lower = _keys
	     _upper = _keys + _klen - 1

	     loop do
	        break if _upper < _lower
	        _mid = _lower + ( (_upper - _lower) >> 1 )

	        if data[p] < _lexer_trans_keys[_mid]
	           _upper = _mid - 1
	        elsif data[p] > _lexer_trans_keys[_mid]
	           _lower = _mid + 1
	        else
	           _trans += (_mid - _keys)
	           _break_match = true
	           break
	        end
	     end # loop
	     break if _break_match
	     _keys += _klen
	     _trans += _klen
	  end
	  _klen = _lexer_range_lengths[cs]
	  if _klen > 0
	     _lower = _keys
	     _upper = _keys + (_klen << 1) - 2
	     loop do
	        break if _upper < _lower
	        _mid = _lower + (((_upper-_lower) >> 1) & ~1)
	        if data[p] < _lexer_trans_keys[_mid]
	          _upper = _mid - 2
	        elsif data[p] > _lexer_trans_keys[_mid+1]
	          _lower = _mid + 2
	        else
	          _trans += ((_mid - _keys) >> 1)
	          _break_match = true
	          break
	        end
	     end # loop
	     break if _break_match
	     _trans += _klen
	  end
	end while false
	cs = _lexer_trans_targs[_trans]
	if _lexer_trans_actions[_trans] != 0
		_acts = _lexer_trans_actions[_trans]
		_nacts = _lexer_actions[_acts]
		_acts += 1
		while _nacts > 0
			_nacts -= 1
			_acts += 1
			case _lexer_actions[_acts - 1]
when 0 then
# line 9 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          @content_start = p
          @current_line = @line_number
          @start_col = p - @last_newline - "#{@keyword}:".length
        		end
when 1 then
# line 15 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          @current_line = @line_number
          @start_col = p - @last_newline
        		end
when 2 then
# line 20 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          @content_start = p
        		end
when 3 then
# line 24 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          con = unindent(@start_col, utf8_pack(data[@content_start...@next_keyword_start-1]).sub(/(\r?\n)?([\t ])*\Z/, '').gsub(/\\"\\"\\"/, '"""'))
          @listener.py_string(con, @current_line) 
        		end
when 4 then
# line 29 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          
          store_keyword_content(:feature, data, p, eof) { |con| unindent(@start_col + 2, con).rstrip }
          p = @next_keyword_start - 1 if @next_keyword_start          
          @next_keyword_start = nil
        		end
when 5 then
# line 36 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          store_keyword_content(:background, data, p, eof) { |con| unindent(@start_col + 2, con).rstrip }
          p = @next_keyword_start - 1 if @next_keyword_start                    
          @next_keyword_start = nil
        		end
when 6 then
# line 42 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          store_keyword_content(:scenario, data, p, eof) { |con| unindent(@start_col + 2, con).rstrip }
          p = @next_keyword_start - 1 if @next_keyword_start                    
          @next_keyword_start = nil
        		end
when 7 then
# line 48 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          store_keyword_content(:scenario_outline, data, p, eof) { |con| unindent(@start_col + 2, con).rstrip }
          p = @next_keyword_start - 1 if @next_keyword_start                    
          @next_keyword_start = nil
        		end
when 8 then
# line 54 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          store_keyword_content(:examples, data, p, eof) { |con| unindent(@start_col + 2, con).rstrip }
          p = @next_keyword_start - 1 if @next_keyword_start                    
          @next_keyword_start = nil
        		end
when 9 then
# line 60 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          con = utf8_pack(data[@content_start...p]).strip
          @listener.step(@keyword, con, @current_line)
        		end
when 10 then
# line 65 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          con = utf8_pack(data[@content_start...p]).strip
          @listener.comment(con, @line_number)
          @keyword_start = nil
        		end
when 11 then
# line 71 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          con = utf8_pack(data[@content_start...p]).strip
          @listener.tag(con, @current_line)
          @keyword_start = nil
        		end
when 12 then
# line 77 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          @line_number += 1
        		end
when 13 then
# line 81 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          @last_newline = p + 1
        		end
when 14 then
# line 85 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          @keyword_start ||= p
        		end
when 15 then
# line 89 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          @keyword = utf8_pack(data[@keyword_start...p]).sub(/:$/,'')
          @keyword_start = nil
        		end
when 16 then
# line 94 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          @next_keyword_start = p
        		end
when 17 then
# line 98 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          p = p - 1
          current_row = []
          @current_line = @line_number
        		end
when 18 then
# line 104 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          @content_start = p
        		end
when 19 then
# line 108 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          con = utf8_pack(data[@content_start...p]).strip
          current_row << con.gsub(/\\\|/, "|").gsub(/\\n/, "\n").gsub(/\\\\/, "\\")
        		end
when 20 then
# line 113 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          @listener.row(current_row, @current_line)
        		end
when 21 then
# line 117 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          if cs < lexer_first_final
            content = current_line_content(data, p)
            raise Gherkin::Lexer::LexingError.new("Lexing error on line %d: '%s'. See http://wiki.github.com/aslakhellesoy/gherkin/lexingerror for more information." % [@line_number, content])
          else
            @listener.eof
          end
        		end
# line 1009 "lib/gherkin/rb_lexer/tr.rb"
			end # action switch
		end
	end
	if _trigger_goto
		next
	end
	end
	if _goto_level <= _again
	if cs == 0
		_goto_level = _out
		next
	end
	p += 1
	if p != pe
		_goto_level = _resume
		next
	end
	end
	if _goto_level <= _test_eof
	if p == eof
	__acts = _lexer_eof_actions[cs]
	__nacts =  _lexer_actions[__acts]
	__acts += 1
	while __nacts > 0
		__nacts -= 1
		__acts += 1
		case _lexer_actions[__acts - 1]
when 21 then
# line 117 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
		begin

          if cs < lexer_first_final
            content = current_line_content(data, p)
            raise Gherkin::Lexer::LexingError.new("Lexing error on line %d: '%s'. See http://wiki.github.com/aslakhellesoy/gherkin/lexingerror for more information." % [@line_number, content])
          else
            @listener.eof
          end
        		end
# line 1048 "lib/gherkin/rb_lexer/tr.rb"
		end # eof action switch
	end
	if _trigger_goto
		next
	end
end
	end
	if _goto_level <= _out
		break
	end
	end
	end

# line 143 "/Users/ahellesoy/scm/gherkin/tasks/../ragel/i18n/tr.rb.rl"
      end

      def unindent(startcol, text)
        text.gsub(/^[\t ]{0,#{startcol}}/, "")
      end

      def store_keyword_content(event, data, p, eof)
        end_point = (!@next_keyword_start or (p == eof)) ? p : @next_keyword_start
        content = yield utf8_pack(data[@content_start...end_point])
        content_lines = content.split("\n")
        name = content_lines.shift || ""
        name.strip!
        description = content_lines.join("\n")
        @listener.__send__(event, @keyword, name, description, @current_line)
      end
      
      def current_line_content(data, p)
        rest = data[@last_newline..-1]
        utf8_pack(rest[0..rest.index(10)||-1]).strip
      end

      if (RUBY_VERSION =~ /^1\.9/)
        def utf8_pack(array)
          array.pack("c*").force_encoding("UTF-8")
        end
      else
        def utf8_pack(array)
          array.pack("c*")
        end
      end
    end
  end
end
require 'erb'

module Thin
  module Stats
    # Rack adapter to log stats about a Rack application.
    class Adapter
      include ERB::Util
      
      def initialize(app, path='/stats')
        @app  = app
        @path = path

        @template = ERB.new(File.read(File.dirname(__FILE__) + '/stats.html.erb'))
        
        @requests          = 0
        @requests_finished = 0
        @start_time        = Time.now
      end
      
      def call(env)
        if env['PATH_INFO'].index(@path) == 0
          serve(env)
        else
          log(env) { @app.call(env) }
        end
      end
      
      def log(env)
        @requests += 1
        @last_request = Rack::Request.new(env)
        request_started_at = Time.now
        
        response = yield
        
        @requests_finished += 1
        @last_request_time = Time.now - request_started_at
        
        response
      end
      
      def serve(env)
        body = @template.result(binding)
        
        [
          200,
          { 'Content-Type' => 'text/html' },
          [body]
        ]
      end
    end
  end
endbegin
  require 'nokogiri'
rescue LoadError => e
  $stderr.puts "You don't have nokogiri installed in your application. Please add it to your Gemfile and run bundle install"
  raise e
end
require 'active_support/core_ext/object/blank'

# = XmlMini Nokogiri implementation using a SAX-based parser
module ActiveSupport
  module XmlMini_NokogiriSAX
    extend self

    # Class that will build the hash while the XML document
    # is being parsed using SAX events.
    class HashBuilder < Nokogiri::XML::SAX::Document

      CONTENT_KEY   = '__content__'.freeze
      HASH_SIZE_KEY = '__hash_size__'.freeze

      attr_reader :hash

      def current_hash
        @hash_stack.last
      end

      def start_document
        @hash = {}
        @hash_stack = [@hash]
      end

      def end_document
        raise "Parse stack not empty!" if @hash_stack.size > 1
      end

      def error(error_message)
        raise error_message
      end

      def start_element(name, attrs = [])
        new_hash = { CONTENT_KEY => '' }.merge(Hash[attrs])
        new_hash[HASH_SIZE_KEY] = new_hash.size + 1

        case current_hash[name]
          when Array then current_hash[name] << new_hash
          when Hash  then current_hash[name] = [current_hash[name], new_hash]
          when nil   then current_hash[name] = new_hash
        end

        @hash_stack.push(new_hash)
      end

      def end_element(name)
        if current_hash.length > current_hash.delete(HASH_SIZE_KEY) && current_hash[CONTENT_KEY].blank? || current_hash[CONTENT_KEY] == ''
          current_hash.delete(CONTENT_KEY)
        end
        @hash_stack.pop
      end

      def characters(string)
        current_hash[CONTENT_KEY] << string
      end

      alias_method :cdata_block, :characters
    end

    attr_accessor :document_class
    self.document_class = HashBuilder

    def parse(data)
      if !data.respond_to?(:read)
        data = StringIO.new(data || '')
      end

      char = data.getc
      if char.nil?
        {}
      else
        data.ungetc(char)
        document = self.document_class.new
        parser = Nokogiri::XML::SAX::Parser.new(document)
        parser.parse(data)
        document.hash
      end
    end
  end
end
require File.expand_path('../spec_helper', __FILE__)

describe "Struct tests" do
  it "Struct#[:pointer]" do
    magic = 0x12345678
    mp = FFI::MemoryPointer.new :long
    mp.put_long(0, magic)
    smp = FFI::MemoryPointer.new :pointer
    smp.put_pointer(0, mp)
    s = FFISpecs::PointerMember.new smp
    s[:pointer].should == mp
  end

  it "Struct#[:pointer].nil? for NULL value" do
    magic = 0x12345678
    mp = FFI::MemoryPointer.new :long
    mp.put_long(0, magic)
    smp = FFI::MemoryPointer.new :pointer
    smp.put_pointer(0, nil)
    s = FFISpecs::PointerMember.new smp
    s[:pointer].null?.should == true
  end

  it "Struct#[:pointer]=" do
    magic = 0x12345678
    mp = FFI::MemoryPointer.new :long
    mp.put_long(0, magic)
    smp = FFI::MemoryPointer.new :pointer
    s = FFISpecs::PointerMember.new smp
    s[:pointer] = mp
    smp.get_pointer(0).should == mp
  end

  it "Struct#[:pointer]=struct" do
    magic = 0x12345678
    smp = FFI::MemoryPointer.new :pointer
    s = FFISpecs::PointerMember.new smp
    lambda { s[:pointer] = s }.should_not raise_error
  end

  it "Struct#[:pointer]=nil" do
    smp = FFI::MemoryPointer.new :pointer
    s = FFISpecs::PointerMember.new smp
    s[:pointer] = nil
    smp.get_pointer(0).null?.should == true
  end

  it "Struct#[:string]" do
    magic = "test"
    mp = FFI::MemoryPointer.new 1024
    mp.put_string(0, magic)
    smp = FFI::MemoryPointer.new :pointer
    smp.put_pointer(0, mp)
    s = FFISpecs::StringMember.new smp
    s[:string].should == magic
  end

  it "Struct#[:string].nil? for NULL value" do
    smp = FFI::MemoryPointer.new :pointer
    smp.put_pointer(0, nil)
    s = FFISpecs::StringMember.new smp
    s[:string].nil?.should == true
  end

  it "Struct#layout works with :name, :type pairs" do
    pair_layout = Class.new(FFI::Struct) do
      layout :a, :int, :b, :long_long
    end

    ll_off = (FFI::TYPE_UINT64.alignment == 4 ? 4 : 8)
    pair_layout.size.should == (ll_off + 8)

    mp = FFI::MemoryPointer.new(pair_layout.size)
    s = pair_layout.new(mp)

    s[:a] = 0x12345678
    mp.get_int(0).should == 0x12345678

    s[:b] = 0xfee1deadbeef
    mp.get_int64(ll_off).should == 0xfee1deadbeef
  end

  it "Struct#layout works with :name, :type, offset tuples" do
    pair_layout = Class.new(FFI::Struct) do
      layout :a, :int, 0, :b, :long_long, 4
    end

    pair_layout.size.should == (FFI::TYPE_UINT64.alignment == 4 ? 12 : 16)

    mp = FFI::MemoryPointer.new(pair_layout.size)
    s = pair_layout.new(mp)

    s[:a] = 0x12345678
    mp.get_int(0).should == 0x12345678

    s[:b] = 0xfee1deadbeef
    mp.get_int64(4).should == 0xfee1deadbeef
  end

  it "Struct#layout works with mixed :name,:type and :name,:type,offset" do
    mixed_layout = Class.new(FFI::Struct) do
      layout :a, :int, :b, :long_long, 4
    end

    mixed_layout.size.should == (FFI::TYPE_UINT64.alignment == 4 ? 12 : 16)

    mp = FFI::MemoryPointer.new(mixed_layout.size)
    s = mixed_layout.new(mp)

    s[:a] = 0x12345678
    mp.get_int(0).should == 0x12345678

    s[:b] = 0xfee1deadbeef
    mp.get_int64(4).should == 0xfee1deadbeef
  end

  rb_maj, rb_min = RUBY_VERSION.split('.')
  if rb_maj.to_i >= 1 && rb_min.to_i >= 9 || RUBY_PLATFORM =~ /java/
    it "Struct#layout withs with a hash of :name => type" do
      hash_layout = Class.new(FFI::Struct) do
        layout :a => :int, :b => :long_long
      end

      ll_off = (FFI::TYPE_UINT64.alignment == 4? 4 : 8)
      hash_layout.size.should == (ll_off + 8)

      mp = FFI::MemoryPointer.new(hash_layout.size)
      s = hash_layout.new(mp)

      s[:a] = 0x12345678
      mp.get_int(0).should == 0x12345678

      s[:b] = 0xfee1deadbeef
      mp.get_int64(ll_off).should == 0xfee1deadbeef
      end
  end

  it "Can use Struct subclass as parameter type" do
    lambda {
      Module.new do
        extend FFI::Library
        ffi_lib FFISpecs::LIBRARY

        struct = Class.new(FFI::Struct) { layout :c, :char }
        attach_function :struct_field_s8, [ struct ], :char
      end
    }.should_not raise_error
  end

  it "Can use Struct subclass as IN parameter type" do
    lambda {
      Module.new do
        extend FFI::Library
        ffi_lib FFISpecs::LIBRARY

        struct = Class.new(FFI::Struct) { layout :c, :char }
        attach_function :struct_field_s8, [ struct.in ], :char
      end
    }.should_not raise_error
  end

  it "Can use Struct subclass as OUT parameter type" do
    lambda {
      Module.new do
        extend FFI::Library
        ffi_lib FFISpecs::LIBRARY

        struct = Class.new(FFI::Struct) { layout :c, :char }
        attach_function :struct_field_s8, [ struct.out ], :char
      end
    }.should_not raise_error
  end

  it "can be passed directly as a :pointer parameter" do
    struct = Class.new(FFI::Struct) do
      layout :i, :int
    end

    s = struct.new
    s[:i] = 0x12
    FFISpecs::LibTest.ptr_ret_int32_t(s, 0).should == 0x12
  end

  it ":char member aligned correctly" do
    align_char = Class.new(FFI::Struct) do
      layout :c, :char, :v, :char
    end

    s = align_char.new
    s[:v] = 0x12
    FFISpecs::LibTest.struct_align_s8(s.pointer).should == 0x12
  end

  it ":short member aligned correctly" do
    align_short = Class.new(FFI::Struct) do
      layout :c, :char, :v, :short
    end

    s = align_short.alloc_in
    s[:v] = 0x1234
    FFISpecs::LibTest.struct_align_s16(s.pointer).should == 0x1234
  end

  it ":int member aligned correctly" do
    align_int = Class.new(FFI::Struct) do
      layout :c, :char, :v, :int
    end

    s = align_int.alloc_in
    s[:v] = 0x12345678
    FFISpecs::LibTest.struct_align_s32(s.pointer).should == 0x12345678
  end

  it ":long_long member aligned correctly" do
    align_long_long = Class.new(FFI::Struct) do
      layout :c, :char, :v, :long_long
    end

    s = align_long_long.alloc_in
    s[:v] = 0x123456789abcdef0
    FFISpecs::LibTest.struct_align_s64(s.pointer).should == 0x123456789abcdef0
  end

  it ":long member aligned correctly" do
    align_long = Class.new(FFI::Struct) do
      layout :c, :char, :v, :long
    end

    s = align_long.alloc_in
    s[:v] = 0x12345678
    FFISpecs::LibTest.struct_align_long(s.pointer).should == 0x12345678
  end

  it ":float member aligned correctly" do
    align_float = Class.new(FFI::Struct) do
      layout :c, :char, :v, :float
    end

    s = align_float.alloc_in
    s[:v] = 1.23456
    (FFISpecs::LibTest.struct_align_f32(s.pointer) - 1.23456).abs.should < 0.00001
  end

  it ":double member aligned correctly" do
    align_double = Class.new(FFI::Struct) do
      layout :c, :char, :v, :double
    end

    s = align_double.alloc_in
    s[:v] = 1.23456789
    (FFISpecs::LibTest.struct_align_f64(s.pointer) - 1.23456789).abs.should < 0.00000001
  end

  it ":ulong, :pointer struct" do
    ulp_struct = Class.new(FFI::Struct) do
      layout :ul, :ulong, :p, :pointer
    end

    s = ulp_struct.alloc_in
    s[:ul] = 0xdeadbeef
    s[:p] = FFISpecs::LibTest.ptr_from_address(0x12345678)
    s.pointer.get_ulong(0).should == 0xdeadbeef
  end

  def self.test_num_field(type, v)
    klass = Class.new(FFI::Struct)
    klass.layout :v, type, :dummy, :long

    s = klass.new
    s[:v] = v
    s.pointer.send("get_#{type.to_s}", 0).should == v
    s.pointer.send("put_#{type.to_s}", 0, 0)
    s[:v].should == 0
  end

  def self.int_field_test(type, values)
    values.each do |v|
      it "#{type} field r/w (#{v.to_s(16)})" do
        test_num_field(type, v)
      end
    end
  end

  int_field_test(:char, [ 0, 127, -128, -1 ])
  int_field_test(:uchar, [ 0, 0x7f, 0x80, 0xff ])
  int_field_test(:short, [ 0, 0x7fff, -0x8000, -1 ])
  int_field_test(:ushort, [ 0, 0x7fff, 0x8000, 0xffff ])
  int_field_test(:int, [ 0, 0x7fffffff, -0x80000000, -1 ])
  int_field_test(:uint, [ 0, 0x7fffffff, 0x80000000, 0xffffffff ])
  int_field_test(:long_long, [ 0, 0x7fffffffffffffff, -0x8000000000000000, -1 ])
  int_field_test(:ulong_long, [ 0, 0x7fffffffffffffff, 0x8000000000000000, 0xffffffffffffffff ])

  if FFI::Platform::LONG_SIZE == 32
    int_field_test(:long, [ 0, 0x7fffffff, -0x80000000, -1 ])
    int_field_test(:ulong, [ 0, 0x7fffffff, 0x80000000, 0xffffffff ])
  else
    int_field_test(:long, [ 0, 0x7fffffffffffffff, -0x8000000000000000, -1 ])
    int_field_test(:ulong, [ 0, 0x7fffffffffffffff, 0x8000000000000000, 0xffffffffffffffff ])
  end

  it ":float field r/w" do
    klass = Class.new(FFI::Struct)
    klass.layout :v, :float, :dummy, :long

    s = klass.new
    value = 1.23456
    s[:v] = value
    (s.pointer.get_float(0) - value).abs.should < 0.0001
  end

  it ":double field r/w" do
    klass = Class.new(FFI::Struct)
    klass.layout :v, :double, :dummy, :long

    s = klass.new
    value = 1.23456
    s[:v] = value
    (s.pointer.get_double(0) - value).abs.should < 0.0001
  end

  it "Can have CallbackInfo struct field" do
    s = FFISpecs::CallbackMember::TestStruct.new
    add_proc = lambda { |a, b| a+b }
    sub_proc = lambda { |a, b| a-b }
    s[:add] = add_proc
    s[:sub] = sub_proc
    FFISpecs::CallbackMember.struct_call_add_cb(s.pointer, 40, 2).should == 42
    FFISpecs::CallbackMember.struct_call_sub_cb(s.pointer, 44, 2).should == 42
  end

  it "Can return its members as a list" do
    klass = Class.new(FFI::Struct)
    klass.layout :a, :int, :b, :int, :c, :int
    klass.members.should include(:a, :b, :c)
  end

  it "Can return its instance members and values as lists" do
    klass = Class.new(FFI::Struct)
    klass.layout :a, :int, :b, :int, :c, :int

    s = klass.new
    s.members.should include(:a, :b, :c)
    s[:a] = 1
    s[:b] = 2
    s[:c] = 3
    s.values.should include(1, 2, 3)
  end

  it 'should return an ordered field/offset pairs array' do
    klass = Class.new(FFI::Struct)
    klass.layout :a, :int, :b, :int, :c, :int

    s = klass.new
    s.offsets.should == [[:a, 0], [:b, 4], [:c, 8]]
    klass.offsets.should == [[:a, 0], [:b, 4], [:c, 8]]
  end

  it "Struct#offset_of returns offset of field within struct" do
    klass = Class.new(FFI::Struct)
    klass.layout :a, :int, :b, :int, :c, :int

    klass.offset_of(:a).should == 0
    klass.offset_of(:b).should == 4
    klass.offset_of(:c).should == 8
  end
end

describe FFI::Struct, ' with a nested struct field'  do
  before do
    @cs = FFISpecs::LibTest::ContainerStruct.new
  end

  it 'should align correctly nested struct field' do
    @cs[:ns][:i] = 123
    FFISpecs::LibTest.struct_align_nested_struct(@cs.to_ptr).should == 123
  end

  it 'should correctly calculate Container size (in bytes)' do
    FFISpecs::LibTest::ContainerStruct.size.should == 8
  end

  it 'should return a Struct object when the field is accessed' do
    @cs[:ns].is_a?(FFI::Struct).should be_true 
  end

  it 'should read a value from memory' do
    @cs = FFISpecs::LibTest::ContainerStruct.new(FFISpecs::LibTest.struct_make_container_struct(123))
    @cs[:ns][:i].should == 123
  end

  it 'should write a value to memory' do
    @cs = FFISpecs::LibTest::ContainerStruct.new(FFISpecs::LibTest.struct_make_container_struct(123))
    @cs[:ns][:i] = 456
    FFISpecs::LibTest.struct_align_nested_struct(@cs.to_ptr).should == 456
  end
end

describe FFI::Struct, ' with an array field'  do
  before do
    @s = FFISpecs::LibTest::StructWithArray.new
  end

  it 'should correctly calculate StructWithArray size (in bytes)' do
    FFISpecs::LibTest::StructWithArray.size.should == 24
  end

  it 'should read values from memory' do
    @s = FFISpecs::LibTest::StructWithArray.new(FFISpecs::LibTest.struct_make_struct_with_array(0, 1, 2, 3, 4))
    @s[:a].to_a.should == [0, 1, 2, 3, 4]
  end

  it 'should cache array object for successive calls' do
    @s[:a].object_id.should == @s[:a].object_id
  end

  it 'should return the size of the array field in bytes' do
    @s = FFISpecs::LibTest::StructWithArray.new(FFISpecs::LibTest.struct_make_struct_with_array(0, 1, 2, 3, 4))
    @s[:a].size.should == 20
  end

  it 'should allow iteration through the array elements' do
    @s = FFISpecs::LibTest::StructWithArray.new(FFISpecs::LibTest.struct_make_struct_with_array(0, 1, 2, 3, 4))
    @s[:a].each_with_index { |elem, i| elem.should == i }  
  end

  it 'should return the pointer to the array' do
    @s = FFISpecs::LibTest::StructWithArray.new(FFISpecs::LibTest.struct_make_struct_with_array(0, 1, 2, 3, 4))
    @s[:a].to_ptr.should == FFISpecs::LibTest::struct_field_array(@s.to_ptr)
  end
end

describe 'BuggedStruct' do
  it 'should return its correct size' do
    FFISpecs::LibTest::BuggedStruct.size.should == FFISpecs::LibTest.bugged_struct_size
  end

  it "offsets within struct should be correct" do
    FFISpecs::LibTest::BuggedStruct.offset_of(:visible).should == 0
    FFISpecs::LibTest::BuggedStruct.offset_of(:x).should == 4
    FFISpecs::LibTest::BuggedStruct.offset_of(:y).should == 8
    FFISpecs::LibTest::BuggedStruct.offset_of(:rx).should == 12
    FFISpecs::LibTest::BuggedStruct.offset_of(:ry).should == 14
    FFISpecs::LibTest::BuggedStruct.offset_of(:order).should == 16
    FFISpecs::LibTest::BuggedStruct.offset_of(:size).should == 17
  end

  it 'should return correct field/offset pairs' do
    FFISpecs::LibTest::BuggedStruct.offsets.sort do |a, b|
      a[1] <=> b[1] 
    end.should == [[:visible, 0], [:x, 4], [:y, 8], [:rx, 12], [:ry, 14], [:order, 16], [:size, 17]]
  end
end

describe "Struct allocation" do
  before :all do
    @klass = Class.new(FFI::Struct)
    @klass.layout :i, :uint
  end

  it "MemoryPointer.new(Struct, 2)" do
    p = FFI::MemoryPointer.new(@klass, 2)
    p.total.should == 8
    p.type_size.should == 4
    p.put_uint(4, 0xdeadbeef)
    @klass.new(p[1])[:i].should == 0xdeadbeef
    p[1].address.should == (p[0].address + 4)
  end

  it "Buffer.new(Struct, 2)" do
    p = FFI::Buffer.new(@klass, 2)
    p.total.should == 8
    p.type_size.should == 4
    p.put_uint(4, 0xdeadbeef)
    @klass.new(p[1])[:i].should == 0xdeadbeef
  end
endrequire File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../fixtures/common', __FILE__)
require File.expand_path('../shared/exists', __FILE__)

ruby_version_is "1.9" do
  describe "Dir.exist?" do
    before :all do
      DirSpecs.create_mock_dirs
    end

    after :all do
      DirSpecs.delete_mock_dirs
    end

    it_behaves_like(:dir_exists, :exist?)
  end
end
$:.unshift(File.join(File.dirname(__FILE__), '..', 'lib'))
require 'mongo'
require 'test/unit'
require './test/test_helper'

# Demonstrate features in MongoDB 1.4
class Features14Test < Test::Unit::TestCase

  context "MongoDB 1.4" do
    setup do
      @con = Mongo::Connection.new
      @db  = @con['mongo-ruby-test']
      @col = @db['new-features']
    end

    teardown do
      @col.drop
    end

    context "new query operators: " do

      context "$elemMatch: " do
        setup do
          @col.save({:user => 'bob', :updates => [{:date => Time.now.utc, :body => 'skiing', :n => 1},
                                                  {:date => Time.now.utc, :body => 'biking', :n => 2}]})

          @col.save({:user => 'joe', :updates => [{:date => Time.now.utc, :body => 'skiing', :n => 2},
                                                  {:date => Time.now.utc, :body => 'biking', :n => 10}]})
        end

        should "match a document with a matching object element in an array" do
          doc = @col.find_one({"updates" => {"$elemMatch" => {"body" => "skiing", "n" => 2}}})
          assert_equal 'joe', doc['user']
        end

        should "$elemMatch with a conditional operator" do
          doc1 = @col.find_one({"updates" => {"$elemMatch" => {"body" => "biking", "n" => {"$gt" => 5}}}})
          assert_equal 'joe', doc1['user']
        end

        should "note the difference between $elemMatch and a traditional match" do
          doc = @col.find({"updates.body" => "skiing", "updates.n" => 2}).to_a
          assert_equal 2, doc.size
        end
      end

      context "$all with regexes" do
        setup do
          @col.save({:n => 1, :a => 'whale'})
          @col.save({:n => 2, :a => 'snake'})
        end

        should "match multiple regexes" do
          doc = @col.find({:a => {'$all' => [/ha/, /le/]}}).to_a
          assert_equal 1, doc.size
          assert_equal 1, doc.first['n']
        end

        should "not match if not every regex matches" do
          doc = @col.find({:a => {'$all' => [/ha/, /sn/]}}).to_a
          assert_equal 0, doc.size
        end
      end

      context "the $not operator" do
        setup do
          @col.save({:a => ['x']})
          @col.save({:a => ['x', 'y']})
          @col.save({:a => ['x', 'y', 'z']})
        end

        should "negate a standard operator" do
          results = @col.find({:a => {'$not' => {'$size' => 2}}}).to_a
          assert_equal 2, results.size
          results = results.map {|r| r['a']}
          assert_equal ['x'], results.sort.first
          assert_equal ['x', 'y', 'z'], results.sort.last
        end
      end
    end

    context "new update operators: " do

      context "$addToSet (pushing a unique value)" do
        setup do
          @col.save({:username => 'bob', :interests => ['skiing', 'guitar']})
        end

        should "add an item to a set uniquely ($addToSet)" do
          @col.update({:username => 'bob'}, {'$addToSet' => {'interests' => 'skiing'}})
          @col.update({:username => 'bob'}, {'$addToSet' => {'interests' => 'kayaking'}})
          document = @col.find_one({:username => 'bob'})
          assert_equal ['guitar', 'kayaking', 'skiing'], document['interests'].sort
        end

        should "add an array of items uniquely ($addToSet with $each)" do
          @col.update({:username => 'bob'}, {'$addToSet' => {'interests' => {'$each' => ['skiing', 'kayaking', 'biking']}}})
          document = @col.find_one({:username => 'bob'})
          assert_equal ['biking', 'guitar', 'kayaking', 'skiing'], document['interests'].sort
        end
      end

      context "the positional operator ($)" do
        setup do
          @id1 = @col.insert({:text => 'hello',
                             :comments => [{'by'   => 'bob',
                                            'text' => 'lol!'},
                                           {'by'   => 'susie',
                                            'text' => 'bye bye!'}]})
          @id2 = @col.insert({:text => 'goodbye',
                            :comments => [{'by'   => 'bob',
                                           'text' => 'au revoir'},
                                          {'by'   => 'susie',
                                           'text' => 'bye bye!'}]})
        end

        should "update a matching array item" do
          @col.update({"_id" => @id1, "comments.by" => 'bob'}, {'$set' => {'comments.$.text' => 'lmao!'}}, :multi => true)
          result = @col.find_one({"_id" => @id1})
          assert_equal 'lmao!', result['comments'][0]['text']
        end
      end
    end

    context "Geoindexing" do
      setup do
        @places = @db['places']
        @places.create_index([['loc', Mongo::GEO2D]])

        @empire_state = ([40.748371, -73.985031])
        @jfk = ([40.643711, -73.790009])

        @places.insert({'name' => 'Empire State Building', 'loc' => ([40.748371, -73.985031])})
        @places.insert({'name' => 'Flatiron Building', 'loc' => ([40.741581, -73.987549])})
        @places.insert({'name' => 'Grand Central', 'loc' => ([40.751678, -73.976562])})
        @places.insert({'name' => 'Columbia University', 'loc' => ([40.808922, -73.961617])})
        @places.insert({'name' => 'NYSE', 'loc' => ([40.71455, -74.007124])})
        @places.insert({'name' => 'JFK', 'loc' => ([40.643711, -73.790009])})
      end

      teardown do
        @places.drop
      end

      should "find the nearest addresses" do
        results = @places.find({'loc' => {'$near' => @empire_state}}).limit(2).to_a
        assert_equal 2, results.size
        assert_equal 'Empire State Building', results[0]['name']
        assert_equal 'Flatiron Building', results[1]['name']
      end

      should "use geoNear command to return distances from a point" do
        cmd = BSON::OrderedHash.new
        cmd['geoNear'] = 'places'
        cmd['near']    = @empire_state
        cmd['num']     = 6
        r = @db.command(cmd)

        assert_equal 6, r['results'].length
        r['results'].each do |result|
          puts result.inspect
        end
      end
    end
  end
end
require 'rspec/core'
require 'autotest/rspec2'

Dir['./spec/support/**/*.rb'].map {|f| require f}

class NullObject
  private
  def method_missing(method, *args, &block)
    # ignore
  end
end

def sandboxed(&block)
  begin
    @orig_config = RSpec.configuration
    @orig_world  = RSpec.world
    new_config = RSpec::Core::Configuration.new
    new_config.include(RSpec::Matchers)
    new_world  = RSpec::Core::World.new(new_config)
    RSpec.instance_variable_set(:@configuration, new_config)
    RSpec.instance_variable_set(:@world, new_world)
    object = Object.new
    object.extend(RSpec::Core::ObjectExtensions)
    object.extend(RSpec::Core::SharedExampleGroup)

    (class << RSpec::Core::ExampleGroup; self; end).class_eval do
      alias_method :orig_run, :run
      def run(reporter=nil)
        @orig_mock_space = RSpec::Mocks::space
        RSpec::Mocks::space = RSpec::Mocks::Space.new
        orig_run(reporter || NullObject.new)
      ensure
        RSpec::Mocks::space = @orig_mock_space
      end
    end

    object.instance_eval(&block)
  ensure
    (class << RSpec::Core::ExampleGroup; self; end).class_eval do
      remove_method :run
      alias_method :run, :orig_run
      remove_method :orig_run
    end

    RSpec.instance_variable_set(:@configuration, @orig_config)
    RSpec.instance_variable_set(:@world, @orig_world)
  end
end

def in_editor?
  ENV.has_key?('TM_MODE') || ENV.has_key?('EMACS') || ENV.has_key?('VIM')
end

RSpec.configure do |c|
  c.color_enabled = !in_editor?
  c.filter_run :focus => true
  c.run_all_when_everything_filtered = true
  c.filter_run_excluding :ruby => lambda {|version|
    case version.to_s
    when "!jruby"
      RUBY_ENGINE != "jruby"
    when /^> (.*)/
      !(RUBY_VERSION.to_s > $1)
    else
      !(RUBY_VERSION.to_s =~ /^#{version.to_s}/)
    end
  }
  c.around do |example|
    sandboxed { example.run }
  end
end
require_relative 'gemutilities'
require 'rubygems'
require 'rubygems/gemcutter_utilities'

class TestGemGemcutterUtilities < RubyGemTestCase

  def setup
    super

    ENV['RUBYGEMS_HOST'] = nil
    Gem.configuration.rubygems_api_key = nil

    @cmd = Gem::Command.new '', 'summary'
    @cmd.extend Gem::GemcutterUtilities
  end

  def test_sign_in
    api_key     = 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
    util_sign_in [api_key, 200, 'OK']

    assert_match %r{Enter your RubyGems.org credentials.}, @sign_in_ui.output
    assert @fetcher.last_request["authorization"]
    assert_match %r{Signed in.}, @sign_in_ui.output

    credentials = YAML.load_file Gem.configuration.credentials_path
    assert_equal api_key, credentials[:rubygems_api_key]
  end

  def test_sign_in_with_host
    api_key     = 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
    util_sign_in [api_key, 200, 'OK'], 'http://example.com'

    assert_match %r{Enter your RubyGems.org credentials.}, @sign_in_ui.output
    assert @fetcher.last_request["authorization"]
    assert_match %r{Signed in.}, @sign_in_ui.output

    credentials = YAML.load_file Gem.configuration.credentials_path
    assert_equal api_key, credentials[:rubygems_api_key]
  end

  def test_sign_in_skips_with_existing_credentials
    api_key     = 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
    Gem.configuration.rubygems_api_key = api_key

    util_sign_in [api_key, 200, 'OK']

    assert_equal "", @sign_in_ui.output
  end

  def test_sign_in_with_other_credentials_doesnt_overwrite_other_keys
    api_key       = 'a5fdbb6ba150cbb83aad2bb2fede64cf040453903'
    other_api_key = 'f46dbb18bb6a9c97cdc61b5b85c186a17403cdcbf'

    FileUtils.mkdir_p File.dirname(Gem.configuration.credentials_path)
    open Gem.configuration.credentials_path, 'w' do |f|
      f.write Hash[:other_api_key, other_api_key].to_yaml
    end
    util_sign_in [api_key, 200, 'OK']

    assert_match %r{Enter your RubyGems.org credentials.}, @sign_in_ui.output
    assert_match %r{Signed in.}, @sign_in_ui.output

    credentials   = YAML.load_file Gem.configuration.credentials_path
    assert_equal api_key, credentials[:rubygems_api_key]
    assert_equal other_api_key, credentials[:other_api_key]
  end

  def test_sign_in_with_bad_credentials
    skip 'Always uses $stdin on windows' if Gem.win_platform?

    assert_raises MockGemUi::TermError do
      util_sign_in ['Access Denied.', 403, 'Forbidden']
    end

    assert_match %r{Enter your RubyGems.org credentials.}, @sign_in_ui.output
    assert_match %r{Access Denied.}, @sign_in_ui.output
  end

  def util_sign_in response, host = nil
    skip 'Always uses $stdin on windows' if Gem.win_platform?

    email    = 'you@example.com'
    password = 'secret'

    if host
      ENV['RUBYGEMS_HOST'] = host
    else
      host = "https://rubygems.org"
    end

    @fetcher = Gem::FakeFetcher.new
    @fetcher.data["#{host}/api/v1/api_key"] = response
    Gem::RemoteFetcher.fetcher = @fetcher

    @sign_in_ui = MockGemUi.new "#{email}\n#{password}\n"

    use_ui @sign_in_ui do
      @cmd.sign_in
    end
  end

end

# logger.rb - simple logging utility
# Copyright (C) 2000-2003, 2005  NAKAMURA, Hiroshi <nakahiro@sarion.co.jp>.

require 'monitor'

# Simple logging utility.
#
# Author:: NAKAMURA, Hiroshi  <nakahiro@sarion.co.jp>
# Documentation:: NAKAMURA, Hiroshi and Gavin Sinclair
# License::
#   You can redistribute it and/or modify it under the same terms of Ruby's
#   license; either the dual license version in 2003, or any later version.
# Revision:: $Id: logger.rb 22285 2009-02-13 10:19:04Z shyouhei $
#
# == Description
#
# The Logger class provides a simple but sophisticated logging utility that
# anyone can use because it's included in the Ruby 1.8.x standard library.
#
# The HOWTOs below give a code-based overview of Logger's usage, but the basic
# concept is as follows.  You create a Logger object (output to a file or
# elsewhere), and use it to log messages.  The messages will have varying
# levels (+info+, +error+, etc), reflecting their varying importance.  The
# levels, and their meanings, are:
#
# +FATAL+:: an unhandleable error that results in a program crash
# +ERROR+:: a handleable error condition
# +WARN+::  a warning
# +INFO+::  generic (useful) information about system operation
# +DEBUG+:: low-level information for developers
#
# So each message has a level, and the Logger itself has a level, which acts
# as a filter, so you can control the amount of information emitted from the
# logger without having to remove actual messages.
#
# For instance, in a production system, you may have your logger(s) set to
# +INFO+ (or +WARN+ if you don't want the log files growing large with
# repetitive information).  When you are developing it, though, you probably
# want to know about the program's internal state, and would set them to
# +DEBUG+.
#
# === Example
#
# A simple example demonstrates the above explanation:
#
#   log = Logger.new(STDOUT)
#   log.level = Logger::WARN
#
#   log.debug("Created logger")
#   log.info("Program started")
#   log.warn("Nothing to do!")
#
#   begin
#     File.each_line(path) do |line|
#       unless line =~ /^(\w+) = (.*)$/
#         log.error("Line in wrong format: #{line}")
#       end
#     end
#   rescue => err
#     log.fatal("Caught exception; exiting")
#     log.fatal(err)
#   end
#
# Because the Logger's level is set to +WARN+, only the warning, error, and
# fatal messages are recorded.  The debug and info messages are silently
# discarded.
#
# === Features
#
# There are several interesting features that Logger provides, like
# auto-rolling of log files, setting the format of log messages, and
# specifying a program name in conjunction with the message.  The next section
# shows you how to achieve these things.
#
#
# == HOWTOs
#
# === How to create a logger
#
# The options below give you various choices, in more or less increasing
# complexity.
#
# 1. Create a logger which logs messages to STDERR/STDOUT.
#
#      logger = Logger.new(STDERR)
#      logger = Logger.new(STDOUT)
#
# 2. Create a logger for the file which has the specified name.
#
#      logger = Logger.new('logfile.log')
#
# 3. Create a logger for the specified file.
#
#      file = File.open('foo.log', File::WRONLY | File::APPEND)
#      # To create new (and to remove old) logfile, add File::CREAT like;
#      #   file = open('foo.log', File::WRONLY | File::APPEND | File::CREAT)
#      logger = Logger.new(file)
#
# 4. Create a logger which ages logfile once it reaches a certain size.  Leave
#    10 "old log files" and each file is about 1,024,000 bytes.
#
#      logger = Logger.new('foo.log', 10, 1024000)
#
# 5. Create a logger which ages logfile daily/weekly/monthly.
#
#      logger = Logger.new('foo.log', 'daily')
#      logger = Logger.new('foo.log', 'weekly')
#      logger = Logger.new('foo.log', 'monthly')
#
# === How to log a message
#
# Notice the different methods (+fatal+, +error+, +info+) being used to log
# messages of various levels.  Other methods in this family are +warn+ and
# +debug+.  +add+ is used below to log a message of an arbitrary (perhaps
# dynamic) level.
#
# 1. Message in block.
#
#      logger.fatal { "Argument 'foo' not given." }
#
# 2. Message as a string.
#
#      logger.error "Argument #{ @foo } mismatch."
#
# 3. With progname.
#
#      logger.info('initialize') { "Initializing..." }
#
# 4. With severity.
#
#      logger.add(Logger::FATAL) { 'Fatal error!' }
#
# === How to close a logger
#
#      logger.close
#
# === Setting severity threshold
#
# 1. Original interface.
#
#      logger.sev_threshold = Logger::WARN
#
# 2. Log4r (somewhat) compatible interface.
#
#      logger.level = Logger::INFO
#      
#      DEBUG < INFO < WARN < ERROR < FATAL < UNKNOWN
#
#
# == Format
#
# Log messages are rendered in the output stream in a certain format.  The
# default format and a sample are shown below:
#
# Log format:
#   SeverityID, [Date Time mSec #pid] SeverityLabel -- ProgName: message
#
# Log sample:
#   I, [Wed Mar 03 02:34:24 JST 1999 895701 #19074]  INFO -- Main: info.
#
# You may change the date and time format in this manner:
#
#   logger.datetime_format = "%Y-%m-%d %H:%M:%S"
#         # e.g. "2004-01-03 00:54:26"
#
# There is currently no supported way to change the overall format, but you may
# have some luck hacking the Format constant.
#


class Logger
  VERSION = "1.2.6"
  id, name, rev = %w$Id: logger.rb 22285 2009-02-13 10:19:04Z shyouhei $
  ProgName = "#{name.chomp(",v")}/#{rev}"

  class Error < RuntimeError; end
  class ShiftingError < Error; end

  # Logging severity.
  module Severity
    DEBUG = 0
    INFO = 1
    WARN = 2
    ERROR = 3
    FATAL = 4
    UNKNOWN = 5
  end
  include Severity

  # Logging severity threshold (e.g. <tt>Logger::INFO</tt>).
  attr_accessor :level

  # Logging program name.
  attr_accessor :progname

  # Logging date-time format (string passed to +strftime+).
  def datetime_format=(datetime_format)
    @default_formatter.datetime_format = datetime_format
  end

  def datetime_format
    @default_formatter.datetime_format
  end

  # Logging formatter.  formatter#call is invoked with 4 arguments; severity,
  # time, progname and msg for each log.  Bear in mind that time is a Time and
  # msg is an Object that user passed and it could not be a String.  It is
  # expected to return a logdev#write-able Object.  Default formatter is used
  # when no formatter is set.
  attr_accessor :formatter

  alias sev_threshold level
  alias sev_threshold= level=

  # Returns +true+ iff the current severity level allows for the printing of
  # +DEBUG+ messages.
  def debug?; @level <= DEBUG; end

  # Returns +true+ iff the current severity level allows for the printing of
  # +INFO+ messages.
  def info?; @level <= INFO; end

  # Returns +true+ iff the current severity level allows for the printing of
  # +WARN+ messages.
  def warn?; @level <= WARN; end

  # Returns +true+ iff the current severity level allows for the printing of
  # +ERROR+ messages.
  def error?; @level <= ERROR; end

  # Returns +true+ iff the current severity level allows for the printing of
  # +FATAL+ messages.
  def fatal?; @level <= FATAL; end

  #
  # === Synopsis
  #
  #   Logger.new(name, shift_age = 7, shift_size = 1048576)
  #   Logger.new(name, shift_age = 'weekly')
  #
  # === Args
  #
  # +logdev+::
  #   The log device.  This is a filename (String) or IO object (typically
  #   +STDOUT+, +STDERR+, or an open file).
  # +shift_age+::
  #   Number of old log files to keep, *or* frequency of rotation (+daily+,
  #   +weekly+ or +monthly+).
  # +shift_size+::
  #   Maximum logfile size (only applies when +shift_age+ is a number).
  #
  # === Description
  #
  # Create an instance.
  #
  def initialize(logdev, shift_age = 0, shift_size = 1048576)
    @progname = nil
    @level = DEBUG
    @default_formatter = Formatter.new
    @formatter = nil
    @logdev = nil
    if logdev
      @logdev = LogDevice.new(logdev, :shift_age => shift_age,
        :shift_size => shift_size)
    end
  end

  #
  # === Synopsis
  #
  #   Logger#add(severity, message = nil, progname = nil) { ... }
  #
  # === Args
  #
  # +severity+::
  #   Severity.  Constants are defined in Logger namespace: +DEBUG+, +INFO+,
  #   +WARN+, +ERROR+, +FATAL+, or +UNKNOWN+.
  # +message+::
  #   The log message.  A String or Exception.
  # +progname+::
  #   Program name string.  Can be omitted.  Treated as a message if no +message+ and
  #   +block+ are given.
  # +block+::
  #   Can be omitted.  Called to get a message string if +message+ is nil.
  #
  # === Return
  #
  # +true+ if successful, +false+ otherwise.
  #
  # When the given severity is not high enough (for this particular logger), log
  # no message, and return +true+.
  #
  # === Description
  #
  # Log a message if the given severity is high enough.  This is the generic
  # logging method.  Users will be more inclined to use #debug, #info, #warn,
  # #error, and #fatal.
  #
  # <b>Message format</b>: +message+ can be any object, but it has to be
  # converted to a String in order to log it.  Generally, +inspect+ is used
  # if the given object is not a String.
  # A special case is an +Exception+ object, which will be printed in detail,
  # including message, class, and backtrace.  See #msg2str for the
  # implementation if required.
  #
  # === Bugs
  #
  # * Logfile is not locked.
  # * Append open does not need to lock file.
  # * But on the OS which supports multi I/O, records possibly be mixed.
  #
  def add(severity, message = nil, progname = nil, &block)
    severity ||= UNKNOWN
    if @logdev.nil? or severity < @level
      return true
    end
    progname ||= @progname
    if message.nil?
      if block_given?
        message = yield
      else
        message = progname
        progname = @progname
      end
    end
    @logdev.write(
      format_message(format_severity(severity), Time.now, progname, message))
    true
  end
  alias log add

  #
  # Dump given message to the log device without any formatting.  If no log
  # device exists, return +nil+.
  #
  def <<(msg)
    unless @logdev.nil?
      @logdev.write(msg)
    end
  end

  #
  # Log a +DEBUG+ message.
  #
  # See #info for more information.
  #
  def debug(progname = nil, &block)
    add(DEBUG, nil, progname, &block)
  end

  #
  # Log an +INFO+ message.
  #
  # The message can come either from the +progname+ argument or the +block+.  If
  # both are provided, then the +block+ is used as the message, and +progname+
  # is used as the program name.
  #
  # === Examples
  #
  #   logger.info("MainApp") { "Received connection from #{ip}" }
  #   # ...
  #   logger.info "Waiting for input from user"
  #   # ...
  #   logger.info { "User typed #{input}" }
  #
  # You'll probably stick to the second form above, unless you want to provide a
  # program name (which you can do with <tt>Logger#progname=</tt> as well).
  #
  # === Return
  #
  # See #add.
  #
  def info(progname = nil, &block)
    add(INFO, nil, progname, &block)
  end

  #
  # Log a +WARN+ message.
  #
  # See #info for more information.
  #
  def warn(progname = nil, &block)
    add(WARN, nil, progname, &block)
  end

  #
  # Log an +ERROR+ message.
  #
  # See #info for more information.
  #
  def error(progname = nil, &block)
    add(ERROR, nil, progname, &block)
  end

  #
  # Log a +FATAL+ message.
  #
  # See #info for more information.
  #
  def fatal(progname = nil, &block)
    add(FATAL, nil, progname, &block)
  end

  #
  # Log an +UNKNOWN+ message.  This will be printed no matter what the logger
  # level.
  #
  # See #info for more information.
  #
  def unknown(progname = nil, &block)
    add(UNKNOWN, nil, progname, &block)
  end

  #
  # Close the logging device.
  #
  def close
    @logdev.close if @logdev
  end

private

  # Severity label for logging. (max 5 char)
  SEV_LABEL = %w(DEBUG INFO WARN ERROR FATAL ANY)

  def format_severity(severity)
    SEV_LABEL[severity] || 'ANY'
  end

  def format_message(severity, datetime, progname, msg)
    (@formatter || @default_formatter).call(severity, datetime, progname, msg)
  end


  class Formatter
    Format = "%s, [%s#%d] %5s -- %s: %s\n"

    attr_accessor :datetime_format

    def initialize
      @datetime_format = nil
    end

    def call(severity, time, progname, msg)
      Format % [severity[0..0], format_datetime(time), $$, severity, progname,
        msg2str(msg)]
    end

  private

    def format_datetime(time)
      if @datetime_format.nil?
        time.strftime("%Y-%m-%dT%H:%M:%S.") << "%06d " % time.usec
      else
        time.strftime(@datetime_format)
      end
    end

    def msg2str(msg)
      case msg
      when ::String
        msg
      when ::Exception
        "#{ msg.message } (#{ msg.class })\n" <<
          (msg.backtrace || []).join("\n")
      else
        msg.inspect
      end
    end
  end


  class LogDevice
    attr_reader :dev
    attr_reader :filename

    class LogDeviceMutex
      include MonitorMixin
    end

    def initialize(log = nil, opt = {})
      @dev = @filename = @shift_age = @shift_size = nil
      @mutex = LogDeviceMutex.new
      if log.respond_to?(:write) and log.respond_to?(:close)
        @dev = log
      else
        @dev = open_logfile(log)
        @dev.sync = true
        @filename = log
        @shift_age = opt[:shift_age] || 7
        @shift_size = opt[:shift_size] || 1048576
      end
    end

    def write(message)
      @mutex.synchronize do
        if @shift_age and @dev.respond_to?(:stat)
          begin
            check_shift_log
          rescue
            raise Logger::ShiftingError.new("Shifting failed. #{$!}")
          end
        end
        @dev.write(message)
      end
    end

    def close
      @mutex.synchronize do
        @dev.close
      end
    end

  private

    def open_logfile(filename)
      if (FileTest.exist?(filename))
     	open(filename, (File::WRONLY | File::APPEND))
      else
       	create_logfile(filename)
      end
    end

    def create_logfile(filename)
      logdev = open(filename, (File::WRONLY | File::APPEND | File::CREAT))
      logdev.sync = true
      add_log_header(logdev)
      logdev
    end

    def add_log_header(file)
      file.write(
     	"# Logfile created on %s by %s\n" % [Time.now.to_s, Logger::ProgName]
    )
    end

    SiD = 24 * 60 * 60

    def check_shift_log
      if @shift_age.is_a?(Integer)
        # Note: always returns false if '0'.
        if @filename && (@shift_age > 0) && (@dev.stat.size > @shift_size)
          shift_log_age
        end
      else
        now = Time.now
        if @dev.stat.mtime <= previous_period_end(now)
          shift_log_period(now)
        end
      end
    end

    def shift_log_age
      (@shift_age-3).downto(0) do |i|
        if FileTest.exist?("#{@filename}.#{i}")
          File.rename("#{@filename}.#{i}", "#{@filename}.#{i+1}")
        end
      end
      @dev.close
      File.rename("#{@filename}", "#{@filename}.0")
      @dev = create_logfile(@filename)
      return true
    end

    def shift_log_period(now)
      postfix = previous_period_end(now).strftime("%Y%m%d")	# YYYYMMDD
      age_file = "#{@filename}.#{postfix}"
      if FileTest.exist?(age_file)
        raise RuntimeError.new("'#{ age_file }' already exists.")
      end
      @dev.close
      File.rename("#{@filename}", age_file)
      @dev = create_logfile(@filename)
      return true
    end

    def previous_period_end(now)
      case @shift_age
      when /^daily$/
        eod(now - 1 * SiD)
      when /^weekly$/
        eod(now - ((now.wday + 1) * SiD))
      when /^monthly$/
        eod(now - now.mday * SiD)
      else
        now
      end
    end

    def eod(t)
      Time.mktime(t.year, t.month, t.mday, 23, 59, 59)
    end
  end


  #
  # == Description
  #
  # Application -- Add logging support to your application.
  #
  # == Usage
  #
  # 1. Define your application class as a sub-class of this class.
  # 2. Override 'run' method in your class to do many things.
  # 3. Instantiate it and invoke 'start'.
  #
  # == Example
  #
  #   class FooApp < Application
  #     def initialize(foo_app, application_specific, arguments)
  #       super('FooApp') # Name of the application.
  #     end
  #
  #     def run
  #       ...
  #       log(WARN, 'warning', 'my_method1')
  #       ...
  #       @log.error('my_method2') { 'Error!' }
  #       ...
  #     end
  #   end
  #
  #   status = FooApp.new(....).start
  #
  class Application
    include Logger::Severity

    attr_reader :appname
    attr_reader :logdev

    #
    # == Synopsis
    #
    #   Application.new(appname = '')
    #
    # == Args
    #
    # +appname+:: Name of the application.
    #
    # == Description
    #
    # Create an instance.  Log device is +STDERR+ by default.  This can be
    # changed with #set_log.
    #
    def initialize(appname = nil)
      @appname = appname
      @log = Logger.new(STDERR)
      @log.progname = @appname
      @level = @log.level
    end

    #
    # Start the application.  Return the status code.
    #
    def start
      status = -1
      begin
	log(INFO, "Start of #{ @appname }.")
	status = run
      rescue
	log(FATAL, "Detected an exception. Stopping ... #{$!} (#{$!.class})\n" << $@.join("\n"))
      ensure
	log(INFO, "End of #{ @appname }. (status: #{ status.to_s })")
      end
      status
    end

    #
    # Sets the log device for this application.  See the class Logger for an
    # explanation of the arguments.
    #
    def set_log(logdev, shift_age = 0, shift_size = 1024000)
      @log = Logger.new(logdev, shift_age, shift_size)
      @log.progname = @appname
      @log.level = @level
    end

    def log=(logdev)
      set_log(logdev)
    end

    #
    # Set the logging threshold, just like <tt>Logger#level=</tt>.
    #
    def level=(level)
      @level = level
      @log.level = @level
    end

    #
    # See Logger#add.  This application's +appname+ is used.
    #
    def log(severity, message = nil, &block)
      @log.add(severity, message, @appname, &block) if @log
    end

  private

    def run
      raise RuntimeError.new('Method run must be defined in the derived class.')
    end
  end
end
module Nokogiri
  module HTML
    ###
    # Nokogiri lets you write a SAX parser to process HTML but get HTML
    # correction features.
    #
    # See Nokogiri::HTML::SAX::Parser for a basic example of using a
    # SAX parser with HTML.
    #
    # For more information on SAX parsers, see Nokogiri::XML::SAX
    module SAX
      ###
      # This class lets you perform SAX style parsing on HTML with HTML
      # error correction.
      #
      # Here is a basic usage example:
      #
      #   class MyDoc < Nokogiri::XML::SAX::Document
      #     def start_element name, attributes = []
      #       puts "found a #{name}"
      #     end
      #   end
      #
      #   parser = Nokogiri::HTML::SAX::Parser.new(MyDoc.new)
      #   parser.parse(File.read(ARGV[0], 'rb'))
      #
      # For more information on SAX parsers, see Nokogiri::XML::SAX
      class Parser < Nokogiri::XML::SAX::Parser
        ###
        # Parse html stored in +data+ using +encoding+
        def parse_memory data, encoding = 'UTF-8'
          raise ArgumentError unless data
          return unless data.length > 0
          ParserContext.memory(data, encoding).parse_with self
        end

        ###
        # Parse a file with +filename+
        def parse_file filename, encoding = 'UTF-8'
          raise ArgumentError unless filename
          raise Errno::ENOENT unless File.exists?(filename)
          raise Errno::EISDIR if File.directory?(filename)
          ParserContext.file(filename, encoding).parse_with self
        end
      end
    end
  end
end
#
#  tkextlib/blt/tile.rb
#                               by Hidetoshi NAGAI (nagai@ai.kyutech.ac.jp)
#

require 'tk'
require 'tkextlib/blt.rb'

module Tk::BLT
  module Tile
    TkComm::TkExtlibAutoloadModule.unshift(self)
    # Require autoload-symbols which is a same name as widget classname.
    # Those are used at  TkComm._genobj_for_tkwidget method.

    autoload :Button,      'tkextlib/blt/tile/button.rb'
    autoload :CheckButton, 'tkextlib/blt/tile/checkbutton.rb'
    autoload :Checkbutton, 'tkextlib/blt/tile/checkbutton.rb'
    autoload :Radiobutton, 'tkextlib/blt/tile/radiobutton.rb'
    autoload :RadioButton, 'tkextlib/blt/tile/radiobutton.rb'
    autoload :Frame,       'tkextlib/blt/tile/frame.rb'
    autoload :Label,       'tkextlib/blt/tile/label.rb'
    autoload :Scrollbar,   'tkextlib/blt/tile/scrollbar.rb'
    autoload :Toplevel,    'tkextlib/blt/tile/toplevel.rb'
  end
end
# encoding: utf-8
module Support #:nodoc:
  module MongoHQ
    extend self

    def configured?
      begin
        user = ENV["MONGOHQ_USER_MONGOID"]
        password = ENV["MONGOHQ_PASSWORD_MONGOID"]
        mongohq_uri = "mongodb://#{user}:#{password}@flame.mongohq.com:27040/mongoid"
        Mongo::Connection.from_uri(mongohq_uri)
        true
      rescue Mongo::ConnectionFailure => e
        false
      rescue Mongo::MongoArgumentError => e
        false
      end
    end

    def message
      %Q{
      ---------------------------------------------------------------------
      The Mongoid configuration specs require an internet connection to
      connect to the test mongohq database, or require the username and
      password set as environment variables. If you need the credentials
      and want these specs to run, please contact durran at gmail dot com.

        ENV["MONGOHQ_USER_MONGOID"]
        ENV["MONGOHQ_PASSWORD_MONGOID"]
      ---------------------------------------------------------------------
      }
    end
  end
end
require File.expand_path('../../../../spec_helper', __FILE__)

ruby_version_is "1.9" do
  describe "Enumerator::Generator#each" do
    it "needs to be reviewed for spec completeness"
  end
end
require File.expand_path('../../spec_helper', __FILE__)

describe "A Hash node" do
  relates "{ 1 => 2, 3 => 4 }" do
    compile do |g|
      g.push_cpath_top
      g.find_const :Hash
      g.push 2
      g.send :new_from_literal, 1

      g.dup
      g.push 1
      g.push 2
      g.send :[]=, 2
      g.pop

      g.dup
      g.push 3
      g.push 4
      g.send :[]=, 2
      g.pop
    end
  end

  relates "{ 1 => (2 rescue 3) }" do
    compile do |g|
      g.push_cpath_top
      g.find_const :Hash
      g.push 1
      g.send :new_from_literal, 1

      g.dup
      g.push 1

      g.for_rescue do |rb|
        rb.body do
          g.push 2
        end

        rb.condition :StandardError do
          g.push 3
        end
      end

      g.send :[]=, 2
      g.pop
    end
  end

  relates "{ 1 => [*1] }" do
    compile do |g|
      g.push_cpath_top
      g.find_const :Hash
      g.push 1
      g.send :new_from_literal, 1

      g.dup
      g.push 1
      g.push 1
      g.cast_array
      g.send :[]=, 2
      g.pop
    end
  end

  relates <<-ruby do
      a = 1
      { :a => a }
    ruby

    compile do |g|
      g.push 1
      g.set_local 0
      g.pop
      g.push_cpath_top
      g.find_const :Hash
      g.push 1
      g.send :new_from_literal, 1

      g.dup
      g.push_literal :a
      g.push_local 0
      g.send :[]=, 2
      g.pop
    end
  end
end
require File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../fixtures/classes', __FILE__)
require File.expand_path('../shared/enumeratorize', __FILE__)
require File.expand_path('../shared/keep_if', __FILE__)

describe "Array#select" do
  it_behaves_like :enumeratorize, :select

  it "returns a new array of elements for which block is true" do
    [1, 3, 4, 5, 6, 9].select { |i| i % ((i + 1) / 2) == 0}.should == [1, 4, 6]
  end

  it "does not return subclass instance on Array subclasses" do
    ArraySpecs::MyArray[1, 2, 3].select { true }.should be_kind_of(Array)
  end

  it "properly handles recursive arrays" do
    empty = ArraySpecs.empty_recursive_array
    empty.select { true }.should == empty
    empty.select { false }.should == []

    array = ArraySpecs.recursive_array
    array.select { true }.should == [1, 'two', 3.0, array, array, array, array, array]
    array.select { false }.should == []
  end
end

ruby_version_is "1.9" do
  describe "Array#select!" do
    it "returns nil if no changes were made in the array" do
      [1, 2, 3].select! { true }.should be_nil
    end

    it_behaves_like :keep_if, :select!
  end
end
require 'rexml/encoding'
require 'rexml/source'

module REXML
  # NEEDS DOCUMENTATION
  class XMLDecl < Child
    include Encoding

    DEFAULT_VERSION = "1.0";
    DEFAULT_ENCODING = "UTF-8";
    DEFAULT_STANDALONE = "no";
    START = '<\?xml';
    STOP = '\?>';

    attr_accessor :version, :standalone
    attr_reader :writeencoding, :writethis

    def initialize(version=DEFAULT_VERSION, encoding=nil, standalone=nil)
      @writethis = true
      @writeencoding = !encoding.nil?
      if version.kind_of? XMLDecl
        super()
        @version = version.version
        self.encoding = version.encoding
        @writeencoding = version.writeencoding
        @standalone = version.standalone
      else
        super()
        @version = version
        self.encoding = encoding
        @standalone = standalone
      end
      @version = DEFAULT_VERSION if @version.nil?
    end

    def clone
      XMLDecl.new(self)
    end

    # indent::
    #   Ignored.  There must be no whitespace before an XML declaration
    # transitive::
    #   Ignored
    # ie_hack::
    #   Ignored
    def write(writer, indent=-1, transitive=false, ie_hack=false)
      return nil unless @writethis or writer.kind_of? Output
      writer << START.sub(/\\/u, '')
      if writer.kind_of? Output
        writer << " #{content writer.encoding}"
      else
        writer << " #{content encoding}"
      end
      writer << STOP.sub(/\\/u, '')
    end

    def ==( other )
      other.kind_of?(XMLDecl) and
      other.version == @version and
      other.encoding == self.encoding and
      other.standalone == @standalone
    end

    def xmldecl version, encoding, standalone
      @version = version
      self.encoding = encoding
      @standalone = standalone
    end

    def node_type
      :xmldecl
    end

    alias :stand_alone? :standalone
    alias :old_enc= :encoding=

    def encoding=( enc )
      if enc.nil?
        self.old_enc = "UTF-8"
        @writeencoding = false
      else
        self.old_enc = enc
        @writeencoding = true
      end
      self.dowrite
    end

    # Only use this if you do not want the XML declaration to be written;
    # this object is ignored by the XML writer.  Otherwise, instantiate your
    # own XMLDecl and add it to the document.
    #
    # Note that XML 1.1 documents *must* include an XML declaration
    def XMLDecl.default
      rv = XMLDecl.new( "1.0" )
      rv.nowrite
      rv
    end

    def nowrite
      @writethis = false
    end

    def dowrite
      @writethis = true
    end

    def inspect
      START.sub(/\\/u, '') + " ... " + STOP.sub(/\\/u, '')
    end

    private
    def content(enc)
      rv = "version='#@version'"
      rv << " encoding='#{enc}'" if @writeencoding || enc !~ /utf-8/i
      rv << " standalone='#@standalone'" if @standalone
      rv
    end
  end
end
require 'compass/commands/project_base'

module Compass
  module Commands
    module ConfigurationOptionsParser
      def set_options(opts)
        opts.banner = %Q{
          Usage: compass config [path/to/config_file.rb] [options]

          Description:
            Generate a configuration file for the options specified.
            Compass will recognize configuration files in the
            following locations relative to the project root:
              * #{Compass::Configuration::Helpers::KNOWN_CONFIG_LOCATIONS.join("
              * ")}
            Any other location, and you'll need to specify it when working with the command line tool using the -c option.

          Options:
        }.strip.split("\n").map{|l| l.gsub(/^ {0,10}/,'')}.join("\n")
        opts.on("--debug [PROPERTY]", "Debug your configuration by printing out details.") do |prop|
          self.options[:debug] = prop.nil? ? true : prop.to_sym
        end

        super
      end
    end
    class WriteConfiguration < ProjectBase

      register :config

      include InstallerCommand

      def initialize(working_path, options)
        super
        assert_project_directory_exists!
      end

      def add_project_configuration
        Compass.add_project_configuration
      end

      def perform
        if options[:debug]
          puts "Configuration sources:"
          c = Compass.configuration
          while c
            print c.name
            c = c.inherited_data
            print ", " if c
          end
          print "\n"
          Compass.configuration.debug.each do |prop, values|
            if options[:debug].is_a?(Symbol)
              next unless prop == options[:debug]
            end
            puts "***** #{prop} = #{values.first[:resolved].inspect} *****"
            [:default, :value, :raw, :resolved].each do |kind|
              puts "#{kind}: " + values.inject([]){|m, v| m << v[kind]}.map{|v| v.nil? ? '-' : v.inspect}.join(", ")
            end
          end
        else
          config_file = options[:configuration_file]
          config_file ||= Compass.detect_configuration_file
          config_file ||= Compass::Configuration::Helpers::KNOWN_CONFIG_LOCATIONS.first
          directory File.dirname(config_file)
          installer.write_configuration_files(config_file)
        end
      end

      def installer_args
        [nil, project_directory, options]
      end

      def explicit_config_file_must_be_readable?
        false
      end

      class << self

        def option_parser(arguments)
          parser = Compass::Exec::CommandOptionParser.new(arguments)
          parser.extend(Compass::Exec::GlobalOptionsParser)
          parser.extend(Compass::Exec::ProjectOptionsParser)
          parser.extend(ConfigurationOptionsParser)
        end

        def usage
          option_parser([]).to_s
        end

        def description(command)
          "Generate a configuration file for the provided command line options."
        end

        def parse!(arguments)
          parser = option_parser(arguments)
          parser.parse!
          parse_arguments!(parser, arguments)
          parser.options
        end

        def parse_arguments!(parser, arguments)
          if arguments.size == 1
            parser.options[:configuration_file] = arguments.shift
          elsif arguments.size == 0
            # default to the current directory.
          else
            raise Compass::Error, "Too many arguments were specified."
          end
        end

      end

    end
  end
end
def product digits
  digits.split("").map {|d| d.to_i}.inject {|x, y| x * y}
end

s = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"

list = []
995.times do |i|
  list << (product s[i..i+4])
end

print list.sort.last
# -----------------------------------------------------------------------------
# 
# Tests for the simple cartesian point implementation
# 
# -----------------------------------------------------------------------------
# Copyright 2010 Daniel Azuma
# 
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# * Neither the name of the copyright holder, nor the names of any other
#   contributors to this software, may be used to endorse or promote products
#   derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# -----------------------------------------------------------------------------
;


require 'test/unit'
require 'rgeo'

require ::File.expand_path('../common/point_tests.rb', ::File.dirname(__FILE__))


module RGeo
  module Tests  # :nodoc:
    module SimpleCartesian  # :nodoc:
      
      class TestPoint < ::Test::Unit::TestCase  # :nodoc:
        
        
        def setup
          @factory = ::RGeo::Cartesian.simple_factory(:srid => 1)
          @zfactory = ::RGeo::Cartesian.simple_factory(:srid => 1, :has_z_coordinate => true)
          @mfactory = ::RGeo::Cartesian.simple_factory(:srid => 1, :has_m_coordinate => true)
          @zmfactory = ::RGeo::Cartesian.simple_factory(:srid => 1, :has_z_coordinate => true, :has_m_coordinate => true)
        end
        
        
        include ::RGeo::Tests::Common::PointTests
        
        
        def test_srid
          point_ = @factory.point(11, 12)
          assert_equal(1, point_.srid)
        end
        
        
        def test_distance
          point1_ = @factory.point(2, 2)
          point2_ = @factory.point(7, 14)
          assert_in_delta(13, point1_.distance(point2_), 0.0001)
        end
        
        
        undef_method :test_disjoint
        undef_method :test_intersects
        undef_method :test_touches
        undef_method :test_crosses
        undef_method :test_within
        undef_method :test_contains
        undef_method :test_overlaps
        undef_method :test_intersection
        undef_method :test_union
        undef_method :test_difference
        undef_method :test_sym_difference
        
        
      end
      
    end
  end
end
module ModuleSpecs::Autoload
  X = :x
end
module TZInfo
  module Definitions
    module America
      module Manaus
        include TimezoneDefinition
        
        timezone 'America/Manaus' do |tz|
          tz.offset :o0, -14404, 0, :LMT
          tz.offset :o1, -14400, 0, :AMT
          tz.offset :o2, -14400, 3600, :AMST
          
          tz.transition 1914, 1, :o1, 52274887201, 21600
          tz.transition 1931, 10, :o2, 19412945, 8
          tz.transition 1932, 4, :o1, 19414389, 8
          tz.transition 1932, 10, :o2, 7280951, 3
          tz.transition 1933, 4, :o1, 19417309, 8
          tz.transition 1949, 12, :o2, 7299755, 3
          tz.transition 1950, 4, :o1, 7300163, 3
          tz.transition 1950, 12, :o2, 7300850, 3
          tz.transition 1951, 4, :o1, 19469901, 8
          tz.transition 1951, 12, :o2, 7301945, 3
          tz.transition 1952, 4, :o1, 19472829, 8
          tz.transition 1952, 12, :o2, 7303043, 3
          tz.transition 1953, 3, :o1, 19475501, 8
          tz.transition 1963, 12, :o2, 7315118, 3
          tz.transition 1964, 3, :o1, 19507645, 8
          tz.transition 1965, 1, :o2, 7316375, 3
          tz.transition 1965, 3, :o1, 19510805, 8
          tz.transition 1965, 12, :o2, 7317287, 3
          tz.transition 1966, 3, :o1, 19513485, 8
          tz.transition 1966, 11, :o2, 7318292, 3
          tz.transition 1967, 3, :o1, 19516405, 8
          tz.transition 1967, 11, :o2, 7319387, 3
          tz.transition 1968, 3, :o1, 19519333, 8
          tz.transition 1985, 11, :o2, 499752000
          tz.transition 1986, 3, :o1, 511239600
          tz.transition 1986, 10, :o2, 530596800
          tz.transition 1987, 2, :o1, 540270000
          tz.transition 1987, 10, :o2, 562132800
          tz.transition 1988, 2, :o1, 571201200
          tz.transition 1993, 10, :o2, 750830400
          tz.transition 1994, 2, :o1, 761713200
        end
      end
    end
  end
end
module Rubinius
  class Debugger

    ##
    # Class used to return formatted output to the +Debugger+ for display.
    # Command implementations should not output anything directly, but should
    # instead return either a string, or an instance of this class if the output
    # needs to be formatted in some way.

    class Output

      ##
      # Class for defining columns of output.

      class Columns
        FORMAT_RE = /%([|-])?(0)?(\d*|\*)([sd])/

        # Defines a new Columns block for an output.
        # Takes the following arguments:
        # - formats: Either a fixnum specifying the number of columns, or an array
        #   of format specifications (one per column). If an array is passed, the
        #   items of the array may be either a format specification as handled by
        #   String#%, or an array containing the column header and a format
        #   specification.
        # - An optional column separator string that will be inserted between
        #   columns when converting a row of cells to a string; defaults to a
        #   single space.
        # Column widths will be fixed at whatever size is specified in the format,
        # or if none is specified, to whatever the necessary width is requried to
        # output all values in that column. The special width specification * can
        # be used to indicate that all remaining space on the line should be set
        # as the column width.
        def initialize(formats, col_sep=' ')
          if formats.kind_of? Array
            @formats = []
            @headers = nil
            formats.each_with_index do |fmt,i|
              if fmt.kind_of? Array
                @headers = [] unless @headers
                @headers[i] = fmt.first if fmt.size > 1
                @formats[i] = fmt.last
              else
                @formats[i] = fmt
              end
            end
          elsif formats.kind_of? Fixnum
            @formats = Array.new(formats, '%-s')
            @headers = nil
          else
            raise ArgumentError, "The formats arg must be an Array or a Fixnum (got #{formats.class})"
          end
          @col_separator = col_sep

          @fixed_widths = Array.new(@formats.size)
          @widths = Array.new(@formats.size, 0)

          # Use widths specified in format string
          @formats.each_with_index do |fmt, i|
            fmt =~ FORMAT_RE
            raise ArgumentError, "Invalid format specification" unless $4
            if $3 and $3.length > 0
              if $3 != '*'
                @fixed_widths[i] = $3.to_i + $`.length + $'.length
                @widths[i] = @fixed_widths[i]
              else
                @fixed_widths[i] = '*'
              end
            end
          end

          # Initialise column widths to column header widths
          if @headers
            @headers.each_with_index do |hdr, i|
              @widths[i] = hdr.length if hdr and hdr.length > @widths[i]
            end
          end
        end

        attr_reader :fixed_widths, :widths

        # Update the column widths required based on the row content
        def update_widths(cells)
          cells.each_with_index do |cell,col|
            if cell
              @formats[col] =~ FORMAT_RE
              str = "#{$`}%#{$2}#{$3 unless $3 == '*'}#{$4}#{$'}" % cell
              @widths[col] = str.length if str.length > @widths[col]
            end
          end
        end

        # Redistributes the calculated widths, ensuring the overall line width is
        # no greater than the specified page width. Reductions are made in the
        # following order:
        # - first, all columns that have a width specification are reduced to that
        #   width (if they exceed it)
        # - next, any columns with a variable width specification are reduced
        #   (from largest to smallest) proportionately based on the needed reduction
        def redistribute_widths(page_width, indent=0)
          if page_width
            # Reduce page_wdith by any requirements for indentation and column separators
            page_width -= indent + (@widths.size-1) * @col_separator.length
            raise ArgumentError, "Page width is insufficient to display any content" if page_width < 1

            # Determine the fixed and variable width columns
            fixed_width = 0
            var_width = 0
            cum_width = 0
            variable_widths = []
            @widths.each_with_index do |width,i|
              cum_width += @widths[i]
              if @fixed_widths[i]
                if fixed_widths[i] == '*'
                  variable_widths << i
                  var_width += @widths[i]
                else
                  fixed_width += @fixed_widths[i]
                end
              end
            end
            return true if cum_width <= page_width

            # Need to squeeze - first up, ensure fixed width columns don't exceed
            # specified size
            @fixed_widths.each_with_index do |fw,i|
              if fw and fw != '*'
                if fw < @widths[i]
                  cum_width -= @widths[i] - fw
                  @widths[i] = fw
                end
              end
            end
            return true if cum_width <= page_width

            if variable_widths.size > 0 and (fixed_width + variable_widths.size) < page_width
              # Next, reduce variable widths proportionately to needs
              cum_adj = 0
              variable_widths.sort.each do |i|
                adj = (@widths[i].to_f / var_width * (cum_width - page_width)).ceil
                @widths[i] -= adj
                cum_adj += adj
                break if cum_width - cum_adj <= page_width
              end
              cum_width -= cum_adj
            end
            return true if cum_width <= page_width

            if cum_width > page_width
              # TODO: Full squeeze - squeeze all columns to fit
            end

            return false
          end
          true
        end

        # Returns true if the column specification has headers
        def has_headers?
          !@headers.nil?
        end

        # Returns a count of the number of columns defined
        def count
          @formats.size
        end

        # Returns a formatted string containing the column headers.
        # Takes two optional parameters:
        # - indent: specifies the number of characters to indent the line by
        #   (default is 0).
        # - page_width: specifies a page width to which the output should be made
        #   to fit. If nil (the default), output is not forced to fit any width.
        def format_header_str(indent=0)
          if @headers
            hdr = [nil]
            hdr.concat format_str(@headers, indent-1, Array.new(@formats.size, '%|s'))
            str = ' ' * (indent-1) + '+' if indent > 0
            @widths.each do |width|
              str << '-' * width + '+'
            end
            hdr << str
            hdr
          end
        end

        # Format an array of cells into a string
        def format_str(row, indent=0, formats=@formats)
          cells = []
          formats.each_with_index do |fmt, i|
            if row[i]
              # Format cell ignoring width and alignment, wrapping if necessary
              fmt =~ FORMAT_RE
              cell = "#{$`}%#{$4}#{$'}" % row[i]
              align = case $1
              when '-' then :left
              when '|' then :center
              else :right
              end
              pad = $2 || ' '
              lines = wrap(cell, @widths[i], align, pad)
              cells << lines
            else
              cells << []
            end
          end

          line, last_line = 0, 1
          str = []
          while line < last_line do
            line_cells = []
            cells.each_with_index do |cell, i|
              last_line = cell.size if line == 0 and cell.size > last_line
              if line < cell.size
                line_cells << cell[line]
              else
                # Cell does not wrap onto current line, so just output spaces
                line_cells << ' ' * @widths[i]
              end
            end
            str << ' ' * indent + line_cells.join(@col_separator)
            line += 1
          end
          str
        end

        # Splits the supplied string at logical breaks to ensure that no line is
        # longer than the spcecified width. Returns an array of lines.
        def wrap(str, width, align=:none, pad=' ')
          raise ArgumentError, "Invalid wrap length specified (#{width})" if width < 0

          return [nil] unless str and width > 0

          str.rstrip!
          lines = []
          until str.length <= width do
            if pos = str[0, width].rindex(/[\s\-,\/_]/)
              # Found a break on whitespace or dash
              line, str = str[0..pos].rstrip, str[pos+1..-1].strip
            elsif pos = str[0, width-1].rindex(/[^\w]/) and pos > 0
              # Found a non-word character to break on
              line, str = str[0...pos].rstrip, str[pos..-1].strip
            else
              # Force break at width
              line, str = str[0...width].rstrip, str[width..-1].strip
            end

            # Pad with spaces to requested width if an alignment is specified
            lines << align(line, width, align, pad)
          end
          lines << align(str, width, align, pad) if str
          lines
        end

        # Aligns
        def align(line, width, align, pad=' ')
          case align
          when :left
            line = line + pad * (width - line.length)
          when :right
            line = pad * (width - line.length) + line
          when :center
            line = line.center(width, pad)
          else
            line
          end
        end
      end

      ##
      # Class for colorizing output lines

      class Color
        def initialize(color=:clear)
          @color = color
        end
        attr_accessor :color

        # Set the color
        def escape
          case @color
          when :blue
            "\033[0;34m"
          when :red
            "\033[0;31m"
          when :green
            "\033[0;32m"
          when :yellow
            "\033[0;33m"
          when :blue
            "\033[0;34m"
          when :magenta
            "\033[0;35m"
          when :cyan
            "\033[0;36m"
          when :white
            "\033[0;37m"
          when :clear
            "\033[0m"
          else
            @color
          end
        end

        # Clear the color
        def clear
          "\033[0m"
        end

        def to_s
          @color.to_s
        end
      end

      ##
      # Class for marking a line in some way

      class LineMarker
        def initialize(marker='=> ')
          @marker = marker
        end

        def length
          @marker.length
        end

        def to_s
          @marker
        end
      end

      # Convenience method for creating an Output of type :info
      def self.info(msg, color=nil)
        out = new(:info)
        out.set_color color if color
        out << msg
        out.set_color :clear if color
        out
      end

      # Convenience method for creating an Output of type :none
      def self.none(msg, color=nil)
        out = new(:none)
        out.set_color color if color
        out << msg
        out.set_color :clear if color
        out
      end

      # Convenience method for creating an Output of type :error
      def self.error(msg, color=nil)
        out = new(:error)
        out.set_color color if color
        out << msg
        out.set_color :clear if color
        out
      end

      # Initializes a new output instance.
      # Output may be of different types, with the default being :info.
      # The output type is not used by the Output class, but may be significant
      # to the interface that displays the output. Commonly used output types
      # include:
      # - :info, the default for informational output
      # - :none, to indicate there is no output of the requested type
      # - :error, to indicate a command error
      def initialize(output_type=:info)
        @output_type = output_type
        clear
      end

      # Clears all output settings
      def clear
        @output = []
        @current_cols = nil
        @current_color = nil
        @marker_width = 0
      end
      attr_reader :output, :current_cols, :current_color

      # Adds a new row of data to the output
      # The item to be added may be an object of several different types:
      # - An array is regarded as a series of cells that make up a row in a table.
      # - A string is regarded as a complete row of data.
      # - A Columns object defines the columnar aspects of subsequent rows of
      #   data, which are typically arrays.
      # - A Color object defines a color change that remains in force until it is
      #   cleared.
      # - LineMarker object specifies a marker to appear to the left of the next
      #   row.
      def <<(item)
        case item
        when Array
          # Line contains multiple columns of text
          unless @current_cols and item.size == @current_cols.count
            # Normally, a command will explicitly specify column formats via a
            # call to set_columns; however, if the output stream receives an array
            # of objects with a different column count to previous lines, a new
            # Columns instance is auto-created.
            @current_cols = Columns.new(item.size)
            @output << @current_cols
          end
          @current_cols.update_widths(item)
        when Columns
          @current_cols = item
        when Color
          @current_color = item
        when LineMarker
          @marker_width = item.length if @marker_width < item.length
        end
        @output << item
      end

      # Convenience method to set a new column structure
      def set_columns(formats, col_sep=' ')
        self << Columns.new(formats, col_sep)
      end

      # Convenience method to set a new row color
      def set_color(color)
        self << Color.new(color) unless @current_color and @current_color.color == color
      end

      # Sets a marker to be displayed next to the next line
      def set_line_marker(marker='=> ')
        self << LineMarker.new(marker)
      end

      # Convert this output stream to a string
      def to_s
        lines.join("\n")
      end

      # Return the output as an array of strings, one per line. If an output item
      # wraps to more than one line, each line will be a separate entry in the
      # returned array.
      # Takes an optional parameter +page_width+ that specifies the width of the
      # page on which the output will be displayed.
      def lines(page_width=nil)
        column = nil
        color = nil
        marker = nil
        lines = []
        @output.each do |item|
          case item
          when String
            str = ""
            str << color.escape if color
            str << item.rstrip
            str << color.clear if color
            lines << str
          when Columns
            column = item
            if page_width
              # Check page_width is sufficient for marker and column headers
              width = page_width-1 - (@marker_width + 2)
              column.redistribute_widths(page_width-1, @marker_width + 2) if width > 0
            end
            if column.has_headers?
              lines.concat column.format_header_str(@marker_width+2)
            end
          when Array
            str = ""
            str << color.escape if color
            str << output_marker(marker)
            marker = nil
            l = column.format_str(item, @marker_width+2)
            l.first[0, @marker_width] = ''
            l.first.insert 0, str
            l.last << color.clear if color
            lines.concat l
          when Color
            if item.color == :clear
              color = nil
            else
              color = item
            end
          when LineMarker
            marker = item
          end
        end
        lines
      end

      def output_marker(marker)
        str = ''
        if @marker_width > 0
          if marker
            str = marker.to_s
          else
            str = ' ' * @marker_width
          end
        end
        str
      end
    end
  end
end

#
#  tcombobox widget
#                               by Hidetoshi NAGAI (nagai@ai.kyutech.ac.jp)
#
require 'tk'
require 'tkextlib/tile.rb'

module Tk
  module Tile
    class TCombobox < Tk::Tile::TEntry
    end
    Combobox = TCombobox
  end
end

class Tk::Tile::TCombobox < Tk::Tile::TEntry
  include Tk::Tile::TileWidget

  if Tk::Tile::USE_TTK_NAMESPACE
    TkCommandNames = ['::ttk::combobox'.freeze].freeze
  else
    TkCommandNames = ['::tcombobox'.freeze].freeze
  end
  WidgetClassName = 'TCombobox'.freeze
  WidgetClassNames[WidgetClassName] ||= self

  def __boolval_optkeys
    super() << 'exportselection'
  end
  private :__boolval_optkeys

  def __listval_optkeys
    super() << 'values'
  end
  private :__listval_optkeys

  def self.style(*args)
    [self::WidgetClassName, *(args.map!{|a| _get_eval_string(a)})].join('.')
  end

  def current
    number(tk_send_without_enc('current'))
  end
  def current=(idx)
    tk_send_without_enc('current', idx)
  end

  def set(val)
    tk_send('set', val)
  end
end

#Tk.__set_toplevel_aliases__(:Ttk, Tk::Tile::Combobox, :TkCombobox)
Tk.__set_loaded_toplevel_aliases__('tkextlib/tile/tcombobox.rb',
                                   :Ttk, Tk::Tile::Combobox, :TkCombobox)
ActionController::Base.perform_caching = true
ActiveSupport::Dependencies.mechanism = :require
Rails.logger.level = ActiveSupport::BufferedLogger::INFO
require File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../fixtures/classes', __FILE__)
require File.expand_path('../shared/find', __FILE__)

describe "Enumerable#find" do
  it_behaves_like(:enumerable_find , :find) 
end
require File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../fixtures/classes', __FILE__)

describe "Module#===" do
  it "returns true when the given Object is an instance of self or of self's descendants" do
    (ModuleSpecs::Child       === ModuleSpecs::Child.new).should == true
    (ModuleSpecs::Parent      === ModuleSpecs::Parent.new).should == true
    
    (ModuleSpecs::Parent      === ModuleSpecs::Child.new).should == true
    (Object                   === ModuleSpecs::Child.new).should == true

    (ModuleSpecs::Child       === String.new).should == false
    (ModuleSpecs::Child       === mock('x')).should == false
  end
  
  it "returns true when the given Object's class includes self or when the given Object is extended by self" do
    (ModuleSpecs::Basic === ModuleSpecs::Child.new).should == true
    (ModuleSpecs::Super === ModuleSpecs::Child.new).should == true
    (ModuleSpecs::Basic === mock('x').extend(ModuleSpecs::Super)).should == true
    (ModuleSpecs::Super === mock('y').extend(ModuleSpecs::Super)).should == true

    (ModuleSpecs::Basic === ModuleSpecs::Parent.new).should == false
    (ModuleSpecs::Super === ModuleSpecs::Parent.new).should == false
    (ModuleSpecs::Basic === mock('z')).should == false
    (ModuleSpecs::Super === mock('a')).should == false
  end
end
