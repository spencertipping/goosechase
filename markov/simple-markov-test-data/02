require 'test/unit'

class TestCase < Test::Unit::TestCase
  def test_case
    case 5
    when 1, 2, 3, 4, 6, 7, 8
      assert(false)
    when 5
      assert(true)
    end

    case 5
    when 5
      assert(true)
    when 1..10
      assert(false)
    end

    case 5
    when 1..10
      assert(true)
    else
      assert(false)
    end

    case 5
    when 5
      assert(true)
    else
      assert(false)
    end

    case "foobar"
    when /^f.*r$/
      assert(true)
    else
      assert(false)
    end

    case
    when true
      assert(true)
    when false, nil
      assert(false)
    else
      assert(false)
    end
  end
end
module StructClasses

  class Apple < Struct; end

  Ruby = Struct.new(:version, :platform)

  Car = Struct.new(:make, :model, :year)

  class Honda < Car
    def initialize(*args)
      self.make = "Honda"
      super(*args)
    end
  end

  class SubclassX < Struct
  end

  class SubclassX
    attr_reader :key
    def initialize(*)
      @key = :value
      super
    end
  end
end
require File.expand_path('../../../spec_helper', __FILE__)

ruby_version_is "1.9" do
  describe "Array#drop" do
    it "needs to be reviewed for spec completeness"
  end
end
# -*- encoding: utf-8 -*-
require File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../fixtures/classes', __FILE__)

describe "IO#getc" do
  before :each do
    @kcode, $KCODE = $KCODE, "utf-8"
    @io = IOSpecs.io_fixture "lines.txt"
  end

  after :each do
    @io.close unless @io.closed?
    $KCODE = @kcode
  end

  ruby_version_is ''...'1.9' do
    it "returns the next byte from the stream" do
      @io.readline.should == "Voici la ligne une.\n"
      bytes = @io.getc, @io.getc, @io.getc, @io.getc, @io.getc
      bytes.should == [81, 117, 105, 32, 195]
    end
  end

  ruby_version_is '1.9' do
    it "returns the next character from the stream" do
      @io.readline.should == "Voici la ligne une.\n"
      letters = @io.getc, @io.getc, @io.getc, @io.getc, @io.getc
      letters.should == ["Q", "u", "i", " ", "Ã¨"]
    end
  end

  it "returns nil when invoked at the end of the stream" do
    @io.read
    @io.getc.should be_nil
  end

  it "raises IOError on closed stream" do
    lambda { IOSpecs.closed_io.getc }.should raise_error(IOError)
  end
end

describe "IO#getc" do
  before :each do
    @io = IOSpecs.io_fixture "empty.txt"
  end

  after :each do
    @io.close unless @io.closed?
  end

  it "returns nil on empty stream" do
    @io.getc.should be_nil
  end
end
require File.expand_path('../../../spec_helper', __FILE__)

describe "RangeError" do
  it "is a superclass of FloatDomainError" do
    RangeError.should be_ancestor_of(FloatDomainError)
  end
end
#
#  tkextlib/bwidget/selectcolor.rb
#                               by Hidetoshi NAGAI (nagai@ai.kyutech.ac.jp)
#

require 'tk'
require 'tkextlib/bwidget.rb'
require 'tkextlib/bwidget/messagedlg'

module Tk
  module BWidget
    class SelectColor < Tk::BWidget::MessageDlg
      class Dialog < Tk::BWidget::SelectColor
      end
      class Menubutton < Tk::Menubutton
      end
      MenuButton = Menubutton
    end
  end
end

class Tk::BWidget::SelectColor
  extend Tk

  TkCommandNames = ['SelectColor'.freeze].freeze
  WidgetClassName = 'SelectColor'.freeze
  WidgetClassNames[WidgetClassName] = self

  def dialog(keys={})
    newkeys = @keys.dup
    newkeys.update(_symbolkey2str(keys))
    tk_call('SelectColor::dialog', @path, *hash_kv(newkeys))
  end

  def menu(*args)
    if args[-1].kind_of?(Hash)
      keys = args.pop
    else
      keys = {}
    end
    place = args.flatten
    newkeys = @keys.dup
    newkeys.update(_symbolkey2str(keys))
    tk_call('SelectColor::menu', @path, place, *hash_kv(newkeys))
  end

  def self.set_color(idx, color)
    tk_call('SelectColor::setcolor', idx, color)
  end
end

class Tk::BWidget::SelectColor::Dialog
  def create_self(keys)
    super(keys)
    @keys['type'] = 'dialog'
  end

  def create
    @keys['type'] = 'dialog'  # 'dialog' type returns color
    tk_call(Tk::BWidget::SelectColor::TkCommandNames[0], 
            @path, *hash_kv(@keys))
  end
end

class Tk::BWidget::SelectColor::Menubutton
  def create_self(keys)
    keys = {} unless keys
    keys = _symbolkey2str(keys)
    keys['type'] = 'menubutton'  # 'toolbar' type returns widget path
    window(tk_call(Tk::BWidget::SelectColor::TkCommandNames[0], 
                   @path, *hash_kv(keys)))
  end
end
require "active_support/inflector/methods"

module ActionDispatch
  class MiddlewareStack < Array
    class Middleware
      attr_reader :args, :block

      def initialize(klass_or_name, *args, &block)
        @ref = ActiveSupport::Dependencies::Reference.new(klass_or_name)
        @args, @block = args, block
      end

      def klass
        @ref.get
      end

      def ==(middleware)
        case middleware
        when Middleware
          klass == middleware.klass
        when Class
          klass == middleware
        else
          normalize(@ref.name) == normalize(middleware)
        end
      end

      def inspect
        klass.to_s
      end

      def build(app)
        klass.new(app, *args, &block)
      end

    private

      def normalize(object)
        object.to_s.strip.sub(/^::/, '')
      end
    end

    def initialize(*args, &block)
      super(*args)
      block.call(self) if block_given?
    end

    def insert(index, *args, &block)
      index = assert_index(index, :before)
      middleware = self.class::Middleware.new(*args, &block)
      super(index, middleware)
    end

    alias_method :insert_before, :insert

    def insert_after(index, *args, &block)
      index = assert_index(index, :after)
      insert(index + 1, *args, &block)
    end

    def swap(target, *args, &block)
      insert_before(target, *args, &block)
      delete(target)
    end

    def use(*args, &block)
      middleware = self.class::Middleware.new(*args, &block)
      push(middleware)
    end

    def active
      ActiveSupport::Deprecation.warn "All middlewares in the chain are active since the laziness " <<
        "was removed from the middleware stack", caller
    end

    def build(app = nil, &block)
      app ||= block
      raise "MiddlewareStack#build requires an app" unless app
      reverse.inject(app) { |a, e| e.build(a) }
    end

  protected

    def assert_index(index, where)
      i = index.is_a?(Integer) ? index : self.index(index)
      raise "No such middleware to insert #{where}: #{index.inspect}" unless i
      i
    end
  end
end
module TZInfo
  module Definitions
    module Iceland
      include TimezoneDefinition
      
      linked_timezone 'Iceland', 'Atlantic/Reykjavik'
    end
  end
end
MACCYRILLIC_TO_UCS_TBL = [
  ["CA",0xA0],
  ["A2",0xA2],
  ["A3",0xA3],
  ["FF",0xA4],
  ["A4",0xA7],
  ["A9",0xA9],
  ["C7",0xAB],
  ["C2",0xAC],
  ["A8",0xAE],
  ["A1",0xB0],
  ["B1",0xB1],
  ["B5",0xB5],
  ["A6",0xB6],
  ["C8",0xBB],
  ["D6",0xF7],
  ["C4",0x192],
  ["DD",0x401],
  ["AB",0x402],
  ["AE",0x403],
  ["B8",0x404],
  ["C1",0x405],
  ["A7",0x406],
  ["BA",0x407],
  ["B7",0x408],
  ["BC",0x409],
  ["BE",0x40A],
  ["CB",0x40B],
  ["CD",0x40C],
  ["D8",0x40E],
  ["DA",0x40F],
  ["80",0x410],
  ["81",0x411],
  ["82",0x412],
  ["83",0x413],
  ["84",0x414],
  ["85",0x415],
  ["86",0x416],
  ["87",0x417],
  ["88",0x418],
  ["89",0x419],
  ["8A",0x41A],
  ["8B",0x41B],
  ["8C",0x41C],
  ["8D",0x41D],
  ["8E",0x41E],
  ["8F",0x41F],
  ["90",0x420],
  ["91",0x421],
  ["92",0x422],
  ["93",0x423],
  ["94",0x424],
  ["95",0x425],
  ["96",0x426],
  ["97",0x427],
  ["98",0x428],
  ["99",0x429],
  ["9A",0x42A],
  ["9B",0x42B],
  ["9C",0x42C],
  ["9D",0x42D],
  ["9E",0x42E],
  ["9F",0x42F],
  ["E0",0x430],
  ["E1",0x431],
  ["E2",0x432],
  ["E3",0x433],
  ["E4",0x434],
  ["E5",0x435],
  ["E6",0x436],
  ["E7",0x437],
  ["E8",0x438],
  ["E9",0x439],
  ["EA",0x43A],
  ["EB",0x43B],
  ["EC",0x43C],
  ["ED",0x43D],
  ["EE",0x43E],
  ["EF",0x43F],
  ["F0",0x440],
  ["F1",0x441],
  ["F2",0x442],
  ["F3",0x443],
  ["F4",0x444],
  ["F5",0x445],
  ["F6",0x446],
  ["F7",0x447],
  ["F8",0x448],
  ["F9",0x449],
  ["FA",0x44A],
  ["FB",0x44B],
  ["FC",0x44C],
  ["FD",0x44D],
  ["FE",0x44E],
  ["DF",0x44F],
  ["DE",0x451],
  ["AC",0x452],
  ["AF",0x453],
  ["B9",0x454],
  ["CF",0x455],
  ["B4",0x456],
  ["BB",0x457],
  ["C0",0x458],
  ["BD",0x459],
  ["BF",0x45A],
  ["CC",0x45B],
  ["CE",0x45C],
  ["D9",0x45E],
  ["DB",0x45F],
  ["D0",0x2013],
  ["D1",0x2014],
  ["D4",0x2018],
  ["D5",0x2019],
  ["D2",0x201C],
  ["D3",0x201D],
  ["D7",0x201E],
  ["A0",0x2020],
  ["A5",0x2022],
  ["C9",0x2026],
  ["DC",0x2116],
  ["AA",0x2122],
  ["B6",0x2202],
  ["C6",0x2206],
  ["C3",0x221A],
  ["B0",0x221E],
  ["C5",0x2248],
  ["AD",0x2260],
  ["B2",0x2264],
  ["B3",0x2265],
]require "spec_helper"

describe Mongoid::Collection do

  let(:master) do
    stub.quacks_like(Mongoid::Collections::Master.allocate)
  end

  let(:slaves) do
    stub.quacks_like(Mongoid::Collections::Slaves.allocate)
  end

  let(:collection) do
    Mongoid::Collection.new(Person, "people")
  end

  before do
    collection.instance_variable_set(:@master, master)
    collection.instance_variable_set(:@slaves, slaves)
  end

  context "Mongo::Collection write operations" do

    Mongoid::Collections::Operations::WRITE.each do |name|

      it "defines #{name}" do
        collection.should respond_to(name)
      end
    end

  end

  context "Mongo::Collection read operations" do

    Mongoid::Collections::Operations::READ.each do |name|

      it "defines #{name}" do
        collection.should respond_to(name)
      end
    end
  end

  describe "master and slave" do

    context "when the database is named" do
      let(:secondary) { mock("secondary") }
      let(:secondary_slaves) { mock("secondary_slaves") }
      let(:collection) do
        Mongoid::Collection.new(Business, "businesses")
      end

      before do
        collection.instance_variable_set(:@master, nil)
        collection.instance_variable_set(:@slaves, nil)
      end

      before do
        Mongoid.expects(:databases).returns({
          "secondary" => secondary,
          "secondary_slaves" => secondary_slaves
        })
      end

      it "should use the named database master" do
        Mongoid::Collections::Master.expects(:new).with(secondary, "businesses")
        collection.master
      end

      it "should use the named database slaves" do
        Mongoid::Collections::Slaves.expects(:new).with(secondary_slaves, "businesses")
        collection.slaves
      end
    end

  end

  describe "#directed" do

    context "when an enslave option is not passed" do

      before do
        slaves.expects(:empty?).returns(false)
      end

      before do
        Person.enslave
      end

      after do
        Person.enslaved = false
      end

      it "uses the default" do
        collection.directed.should == slaves
      end
    end

    context "when an enslave option is passed" do

      before do
        slaves.expects(:empty?).returns(false)
      end

      it "overwrites the default" do
        collection.directed(:enslave => true).should == slaves
      end
    end

    context "when cached option is passed" do

      let(:options) do
        { :cache => true }
      end

      it "removed the cache option" do
        collection.directed(options).should == master
        options[:cache].should be_nil
      end
    end

  end

  describe "#find" do

    before do
      @cursor = stub.quacks_like(Mongoid::Cursor.allocate)
      Mongoid::Cursor.expects(:new).with(Person, collection, @mongo_cursor).returns(@cursor)
    end

    context "when no block supplied" do

      before do
        master.expects(:find).with({ :test => "value" }, {}).returns(@mongo_cursor)
      end

      it "finds return a cursor" do
        collection.find({ :test => "value"}).should == @cursor
      end

    end

    context "when a block is supplied" do

      before do
        master.expects(:find).with({ :test => "value" }, {}).returns(@mongo_cursor)
      end

      it "yields to the cursor and closes it" do
        @cursor.expects(:close).returns(true)
        collection.find({ :test => "value" }) do |cur|
          cur.should == @cursor
        end
      end
    end

    context "when an enslave option exists" do

      before do
        @options = { :enslave => true }
        slaves.expects(:empty?).returns(false)
        slaves.expects(:find).with({ :test => "value" }, {}).returns(@mongo_cursor)
      end

      it "sends the query to the slave pool" do
        collection.find({ :test => "value"}, @options).should == @cursor
      end

      it "deletes the enslave option" do
        collection.find({ :test => "value"}, @options)
        @options[:enslave].should be_nil
      end
    end

    context "when an enslave option does not exist" do

      before do
        master.expects(:find).with({ :test => "value" }, {}).returns(@mongo_cursor)
      end

      it "sends the query to the master" do
        collection.find({ :test => "value"}).should == @cursor
      end
    end
  end

  describe "#find_one" do

    before do
      @person = stub
    end

    context "when an enslave option exists" do

      before do
        @options = { :enslave => true }
        slaves.expects(:empty?).returns(false)
        slaves.expects(:find_one).with({ :test => "value" }, {}).returns(@person)
      end

      it "sends the query to the slave pool" do
        collection.find_one({ :test => "value"}, @options).should == @person
      end

      it "deletes the enslave option" do
        collection.find_one({ :test => "value"}, @options)
        @options[:enslave].should be_nil
      end
    end

    context "when an enslave option does not exist" do

      before do
        master.expects(:find_one).with({ :test => "value" }, {}).returns(@person)
      end

      it "sends the query to the master" do
        collection.find_one({ :test => "value"}).should == @person
      end
    end
  end
end
def ack(m, n)
  if n == 0
    ack(m - 1, 1)
  elsif m != 0
    ack(m - 1, ack(m, n - 1))
  else
    n + 1
  end
end

def Bench.run
  50.times { ack 3, 7 }
end
#
# config.rb -- Default configurations.
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2003 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: config.rb,v 1.52 2003/07/22 19:20:42 gotoyuzo Exp $

require 'webrick/version'
require 'webrick/httpversion'
require 'webrick/httputils'
require 'webrick/utils'
require 'webrick/log'

module WEBrick
  module Config
    LIBDIR = File::dirname(__FILE__)

    # for GenericServer
    General = {
      :ServerName     => Utils::getservername,
      :BindAddress    => nil,   # "0.0.0.0" or "::" or nil
      :Port           => nil,   # users MUST specify this!!
      :MaxClients     => 100,   # maximum number of the concurrent connections
      :ServerType     => nil,   # default: WEBrick::SimpleServer
      :Logger         => nil,   # default: WEBrick::Log.new
      :ServerSoftware => "WEBrick/#{WEBrick::VERSION} " +
                         "(Ruby/#{RUBY_VERSION}/#{RUBY_RELEASE_DATE})",
      :TempDir        => ENV['TMPDIR']||ENV['TMP']||ENV['TEMP']||'/tmp',
      :DoNotListen    => false,
      :StartCallback  => nil,
      :StopCallback   => nil,
      :AcceptCallback => nil,
      :DoNotReverseLookup => nil,
      :ShutdownSocketWithoutClose => false,
    }

    # for HTTPServer, HTTPRequest, HTTPResponse ...
    HTTP = General.dup.update(
      :Port           => 80,
      :RequestTimeout => 30,
      :HTTPVersion    => HTTPVersion.new("1.1"),
      :AccessLog      => nil,
      :MimeTypes      => HTTPUtils::DefaultMimeTypes,
      :DirectoryIndex => ["index.html","index.htm","index.cgi","index.rhtml"],
      :DocumentRoot   => nil,
      :DocumentRootOptions => { :FancyIndexing => true },
      :RequestCallback => nil,
      :ServerAlias    => nil,
      :InputBufferSize  => 65536, # input buffer size in reading request body
      :OutputBufferSize => 65536, # output buffer size in sending File or IO

      # for HTTPProxyServer
      :ProxyAuthProc  => nil,
      :ProxyContentHandler => nil,
      :ProxyVia       => true,
      :ProxyTimeout   => true,
      :ProxyURI       => nil,

      :CGIInterpreter => nil,
      :CGIPathEnv     => nil,

      # workaround: if Request-URIs contain 8bit chars,
      # they should be escaped before calling of URI::parse().
      :Escape8bitURI  => false
    )

    FileHandler = {
      :NondisclosureName => [".ht*", "*~"],
      :FancyIndexing     => false,
      :HandlerTable      => {},
      :HandlerCallback   => nil,
      :DirectoryCallback => nil,
      :FileCallback      => nil,
      :UserDir           => nil,  # e.g. "public_html"
      :AcceptableLanguages => []  # ["en", "ja", ... ]
    }

    BasicAuth = {
      :AutoReloadUserDB     => true,
    }

    DigestAuth = {
      :Algorithm            => 'MD5-sess', # or 'MD5'
      :Domain               => nil,        # an array includes domain names.
      :Qop                  => [ 'auth' ], # 'auth' or 'auth-int' or both.
      :UseOpaque            => true,
      :UseNextNonce         => false,
      :CheckNc              => false,
      :UseAuthenticationInfoHeader => true,
      :AutoReloadUserDB     => true,
      :NonceExpirePeriod    => 30*60,
      :NonceExpireDelta     => 60,
      :InternetExplorerHack => true,
      :OperaHack            => true,
    }
  end
end
# (see Ruby::AliasHandler)
class YARD::Handlers::Ruby::Legacy::AliasHandler < YARD::Handlers::Ruby::Legacy::Base
  handles /\Aalias(_method)?(\s|\()/
  
  process do
    if TkALIAS === statement.tokens.first 
      tokens = statement.tokens[2..-1].to_s.split(/\s+/)
      names = [tokens[0], tokens[1]].map {|t| t.gsub(/^:/, '') }
    else
      names = tokval_list(statement.tokens[2..-1], :attr)
    end
    raise YARD::Parser::UndocumentableError, statement.tokens.first.text if names.size != 2
    
    new_meth, old_meth = names[0].to_sym, names[1].to_sym
    old_obj = namespace.child(:name => old_meth, :scope => scope)
    new_obj = register MethodObject.new(namespace, new_meth, scope) do |o|
      o.visibility = visibility
      o.scope = scope
      o.add_file(parser.file, statement.tokens.first.line_no)
      o.docstring = statement.comments

      if old_obj
        o.signature = old_obj.signature
        o.source = old_obj.source
      else
        o.signature = "def #{new_meth}" # this is all we know.
      end
    end
    
    namespace.aliases[new_obj] = old_meth
  end
endrequire File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../shared/equal_value', __FILE__)

describe "Regexp#eql?" do
  it_behaves_like(:regexp_eql, :eql?)
end
# $Id: test_dryrun.rb 11708 2007-02-12 23:01:19Z shyouhei $

require 'test/unit'
require 'fileutils'

class TestFileUtilsDryRun < Test::Unit::TestCase

  include FileUtils::DryRun

  def test_visibility
    FileUtils::METHODS.each do |m|
      assert_equal true, FileUtils::DryRun.respond_to?(m, true),
                   "FileUtils::DryRun.#{m} not defined"
      assert_equal true, FileUtils::DryRun.respond_to?(m, false),
                   "FileUtils::DryRun.#{m} not public"
    end
    FileUtils::METHODS.each do |m|
      assert_equal true, respond_to?(m, true)
                   "FileUtils::DryRun\##{m} is not defined"
      assert_equal true, FileUtils::DryRun.private_method_defined?(m),
                   "FileUtils::DryRun\##{m} is not private"
    end
  end

end
##
## $Release: 2.6.6 $
## copyright(c) 2006-2010 kuwata-lab.com all rights reserved.
##


module Erubis


  ##
  ## context object for Engine#evaluate
  ##
  ## ex.
  ##   template = <<'END'
  ##   Hello <%= @user %>!
  ##   <% for item in @list %>
  ##    - <%= item %>
  ##   <% end %>
  ##   END
  ##
  ##   context = Erubis::Context.new(:user=>'World', :list=>['a','b','c'])
  ##   # or
  ##   # context = Erubis::Context.new
  ##   # context[:user] = 'World'
  ##   # context[:list] = ['a', 'b', 'c']
  ##
  ##   eruby = Erubis::Eruby.new(template)
  ##   print eruby.evaluate(context)
  ##
  class Context
    include Enumerable

    def initialize(hash=nil)
      hash.each do |name, value|
        self[name] = value
      end if hash
    end

    def [](key)
      return instance_variable_get("@#{key}")
    end

    def []=(key, value)
      return instance_variable_set("@#{key}", value)
    end

    def keys
      return instance_variables.collect { |name| name[1..-1] }
    end

    def each
      instance_variables.each do |name|
        key = name[1..-1]
        value = instance_variable_get(name)
        yield(key, value)
      end
    end

    def to_hash
      hash = {}
      self.keys.each { |key| hash[key] = self[key] }
      return hash
    end

    def update(context_or_hash)
      arg = context_or_hash
      if arg.is_a?(Hash)
        arg.each do |key, val|
          self[key] = val
        end
      else
        arg.instance_variables.each do |varname|
          key = varname[1..-1]
          val = arg.instance_variable_get(varname)
          self[key] = val
        end
      end
    end

  end


end
require 'rubygems'
require 'cucumber'
require 'spec'
require 'fileutils'
require 'rbconfig'

ROOT_PATH = File.expand_path(File.join(File.dirname(__FILE__), '../..'))
require 'mspec/matchers/variable'

class HaveClassVariableMatcher < VariableMatcher
  self.variables_method = :class_variables
  self.description      = 'class variable'
end

class Object
  def have_class_variable(variable)
    HaveClassVariableMatcher.new(variable)
  end
endrequire File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../../../shared/file/directory', __FILE__)

describe "File.directory?" do
  it_behaves_like :file_directory, :directory?, File
end
require 'test/unit'
require "xmlrpc/create"
require "xmlrpc/parser"
require "xmlrpc/config"

class Test_Features < Test::Unit::TestCase

  def setup
    @params = [nil, {"test" => nil}, [nil, 1, nil]]
  end

  def test_nil_create
    XMLRPC::XMLWriter.each_installed_writer do |writer|
      c = XMLRPC::Create.new(writer)

      XMLRPC::Config.module_eval {remove_const(:ENABLE_NIL_CREATE)}
      XMLRPC::Config.const_set(:ENABLE_NIL_CREATE, false)
      assert_raises(RuntimeError) { str = c.methodCall("test", *@params) }

      XMLRPC::Config.module_eval {remove_const(:ENABLE_NIL_CREATE)}
      XMLRPC::Config.const_set(:ENABLE_NIL_CREATE, true)
      assert_nothing_raised { str = c.methodCall("test", *@params) }
    end
  end

  def test_nil_parse
    XMLRPC::Config.module_eval {remove_const(:ENABLE_NIL_CREATE)}
    XMLRPC::Config.const_set(:ENABLE_NIL_CREATE, true)

    XMLRPC::XMLWriter.each_installed_writer do |writer|
      c = XMLRPC::Create.new(writer)
      str = c.methodCall("test", *@params) 
      XMLRPC::XMLParser.each_installed_parser do |parser|
        para = nil

        XMLRPC::Config.module_eval {remove_const(:ENABLE_NIL_PARSER)}
        XMLRPC::Config.const_set(:ENABLE_NIL_PARSER, false)
        assert_raises(RuntimeError) { para = parser.parseMethodCall(str) }

        XMLRPC::Config.module_eval {remove_const(:ENABLE_NIL_PARSER)}
        XMLRPC::Config.const_set(:ENABLE_NIL_PARSER, true)
        assert_nothing_raised { para = parser.parseMethodCall(str) }
        assert_equal(para[1], @params)
      end
    end
  end

end
require 'treetop/ruby_extensions'

require 'treetop/compiler/lexical_address_space'
require 'treetop/compiler/ruby_builder'
require 'treetop/compiler/node_classes'
require 'treetop/compiler/metagrammar' unless defined?($exclude_metagrammar)
require 'treetop/compiler/grammar_compiler'
LESS_INIT = (<<-LESS).gsub(/^ {6}/, '')
# Enables support for Less template reloading for rack.
# Store Less files by default within 'app/stylesheets/'
# See http://github.com/kelredd/rack-less for more details.
require 'rack/less'
# optional - use as necessary
Rack::Less.configure do |config|
  config.compress = true
  # other configs ...
end
app.use Rack::Less,
:root      => app.root,
:source    => 'stylesheets/',
:public    => 'public/',
:hosted_at => '/stylesheets'
LESS

def setup_stylesheet
  require_dependencies 'less', 'rack-less'
  initializer :less, LESS_INIT
  empty_directory destination_root('/app/stylesheets')
end#
# utils.rb -- Miscellaneous utilities
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: utils.rb,v 1.10 2003/02/16 22:22:54 gotoyuzo Exp $

require 'socket'
require 'fcntl'
begin
  require 'etc'
rescue LoadError
  nil
end

module WEBrick
  module Utils
    def set_non_blocking(io)
      flag = File::NONBLOCK
      if defined?(Fcntl::F_GETFL)
        flag |= io.fcntl(Fcntl::F_GETFL)
      end
      io.fcntl(Fcntl::F_SETFL, flag)
    end
    module_function :set_non_blocking

    def set_close_on_exec(io)
      if defined?(Fcntl::FD_CLOEXEC)
        io.fcntl(Fcntl::FD_CLOEXEC, 1)
      end
    end
    module_function :set_close_on_exec

    def su(user)
      if defined?(Etc)
        pw = Etc.getpwnam(user)
        Process::initgroups(user, pw.gid)
        Process::Sys::setgid(pw.gid)
        Process::Sys::setuid(pw.uid)
      else
        warn("WEBrick::Utils::su doesn't work on this platform")
      end
    end
    module_function :su

    def getservername
      host = Socket::gethostname
      begin
        Socket::gethostbyname(host)[0]
      rescue
        host
      end
    end
    module_function :getservername

    def create_listeners(address, port, logger=nil)
      unless port
        raise ArgumentError, "must specify port"
      end
      res = Socket::getaddrinfo(address, port,
                                Socket::AF_UNSPEC,   # address family
                                Socket::SOCK_STREAM, # socket type
                                0,                   # protocol
                                Socket::AI_PASSIVE)  # flag
      last_error = nil
      sockets = []
      res.each{|ai|
        begin
          logger.debug("TCPServer.new(#{ai[3]}, #{port})") if logger
          sock = TCPServer.new(ai[3], port)
          port = sock.addr[1] if port == 0
          Utils::set_close_on_exec(sock)
          sockets << sock
        rescue => ex
          logger.warn("TCPServer Error: #{ex}") if logger
          last_error  = ex
        end
      }
      raise last_error if sockets.empty?
      return sockets
    end
    module_function :create_listeners

    RAND_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
                 "0123456789" +
                 "abcdefghijklmnopqrstuvwxyz"

    def random_string(len)
      rand_max = RAND_CHARS.bytesize
      ret = ""
      len.times{ ret << RAND_CHARS[rand(rand_max)] }
      ret
    end
    module_function :random_string

    ###########

    require "thread"
    require "timeout"
    require "singleton"

    class TimeoutHandler
      include Singleton
      TimeoutMutex = Mutex.new

      def TimeoutHandler.register(seconds, exception)
        TimeoutMutex.synchronize{
          instance.register(Thread.current, Time.now + seconds, exception)
        }
      end

      def TimeoutHandler.cancel(id)
        TimeoutMutex.synchronize{
          instance.cancel(Thread.current, id)
        }
      end

      def initialize
        @timeout_info = Hash.new
        Thread.start{
          while true
            now = Time.now
            @timeout_info.each{|thread, ary|
              ary.dup.each{|info|
                time, exception = *info
                interrupt(thread, info.object_id, exception) if time < now
              }
            }
            sleep 0.5
          end
        }
      end

      def interrupt(thread, id, exception)
        TimeoutMutex.synchronize{
          if cancel(thread, id) && thread.alive?
            thread.raise(exception, "execution timeout")
          end
        }
      end

      def register(thread, time, exception)
        @timeout_info[thread] ||= Array.new
        @timeout_info[thread] << [time, exception]
        return @timeout_info[thread].last.object_id
      end

      def cancel(thread, id)
        if ary = @timeout_info[thread]
          ary.delete_if{|info| info.object_id == id }
          if ary.empty?
            @timeout_info.delete(thread)
          end
          return true
        end
        return false
      end
    end

    def timeout(seconds, exception=Timeout::Error)
      return yield if seconds.nil? or seconds.zero?
      # raise ThreadError, "timeout within critical session" if Thread.critical
      id = TimeoutHandler.register(seconds, exception)
      begin
        yield(seconds)
      ensure
        TimeoutHandler.cancel(id)
      end
    end
    module_function :timeout
  end
end
#!/usr/bin/env ruby

require 'less'

module Less
  # This is the class that Treetop defines for parsing Less files.
  # Since not everything gets parsed into the AST but is instead resolved at parse-time,
  # we need to override some of it so that it can be converted into Sass.
  module StyleSheet
    # Selector mixins that don't have arguments.
    # This depends only on the syntax at the call site;
    # if it doesn't use parens, it hits this production,
    # regardless of whether the mixin being called has arguments or not.
    module Mixin4
      def build_with_sass(env)
        selectors.build(env, :mixin).each do |path|
          el = path.inject(env.root) do |current, node|
            current.descend(node.selector, node) or raise MixinNameError, "#{selectors.text_value} in #{env}"
          end
          if el.is_a?(Node::Mixin::Def)
            # Calling a mixin with arguments, which gets compiled to a Sass mixin
            env << Node::Mixin::Call.new(el, [], env)
          else
            # Calling a mixin without arguments, which gets compiled to @extend
            sel = selector_str(path)
            base = selector_str(selector_base(path))
            if base == sel
              env << Node::SassNode.new(Sass::Tree::ExtendNode.new([sel]))
            else
              Sass::Util.sass_warn <<WARNING
WARNING: Sass doesn't support mixing in selector sequences.
Replacing "#{sel}" with "@extend #{base}"
WARNING
              env << Node::SassNode.new(Sass::Tree::CommentNode.new("// #{sel};", true))
              env << Node::SassNode.new(Sass::Tree::ExtendNode.new([base]))
            end
          end
        end
      end
      alias_method :build_without_sass, :build
      alias_method :build, :build_with_sass

      def selector_base(path)
        el, i = Sass::Util.enum_with_index(path).to_a.reverse.find {|e, i| e.selector !~ /^:{1,2}$/} ||
          [path.first, 0]
        sel = (el.selector =~ /^:{0,2}$/ ? el.selector : "")
        [Node::Element.new(el.name, sel)] + path[i+1..-1]
      end

      def selector_str(path)
        path.map {|e| e.sass_selector_str}.join(' ').gsub(' :', ':')
      end
    end

    # Property and variable declarations.
    # We want to keep track of the line number
    # so we don't space out the variables too much in the generated Sass.
    module Declaration3
      def build_with_sass(env)
        build_without_sass(env)
        env.rules.last.src_line = input.line_of(interval.first)
      end
      alias_method :build_without_sass, :build
      alias_method :build, :build_with_sass
    end

    # Comma-separated selectors.
    # Less breaks these into completely separate nodes.
    # Since we don't want this duplication in the Sass,
    # we modify the production to keep track of the original group
    # so we can reconstruct it later on.
    module Selectors2
      def build_with_sass(env, method)
        arr = build_without_sass(env, method)
        return arr if method == :mixin
        rarr = arr.map {|e| e.top(env)}
        rarr.each {|e| e.group = rarr}
        arr
      end
      alias_method :build_without_sass, :build
      alias_method :build, :build_with_sass
    end

    # Attribute accessors.
    # Sass just flat-out doesn't support these,
    # so we print a warning to that effect and compile them to comments.
    module Accessor1
      def build(env)
        Sass::Util.sass_warn <<WARNING
WARNING: Sass doesn't support attribute accessors.
Ignoring #{text_value}
WARNING
        Node::Anonymous.new("/* #{text_value} */")
      end
    end

    # @import statements.
    # Less handles these during parse-time,
    # so we want to wrap them up as a node in the tree.
    # We also include the nodes, though,
    # since we want to have access to the mixins
    # so we can tell if they take arguments or not.
    # The included nodes are hidden so they don't appear in the output.
    module Import1
      def build_with_sass(env)
        line = input.line_of(interval.first)
        import = Sass::Tree::ImportNode.new(url.value.gsub(/\.less$/, ''))
        import.line = input.line_of(interval.first)
        env << Node::SassNode.new(import)
        old_rules = env.rules.dup
        build_without_sass env
        (env.rules - old_rules).each {|r| r.hide_in_sass = true}
      rescue ImportError => e
        raise Sass::SyntaxError.new("File to import #{url.text_value} not found or unreadable", :line => line)
      end
      alias_method :build_without_sass, :build
      alias_method :build, :build_with_sass
    end

    # The IE-specific `alpha(opacity=@var)`.
    # Less manually resolves the variable here at parse-time.
    # We want to keep the variable around,
    # so we compile this to a function.
    # Less doesn't actually have an `=` operator,
    # but that's okay since it's just getting compiled to Sass anyway.
    module Entity::Alpha1
      def build(env)
        Node::Function.new("alpha",
          [Node::Expression.new([
                Node::Keyword.new("opacity"),
                Node::Operator.new("="),
                variable.build])])
      end
    end
  end

  # The Less AST classes for the document,
  # including both stylesheet-level nodes and expression-level nodes.
  # The main purpose of overriding these is to add `#to_sass_tree` functions
  # for converting to Sass.
  module Node
    module Entity
      attr_accessor :hide_in_sass
      attr_accessor :src_line
    end

    class Element
      attr_accessor :group

      def top(env)
        return self if parent.equal?(env)
        return parent.top(env)
      end

      def to_sass_tree
        if root?
          root = Sass::Tree::RootNode.new("")
          rules.each {|r| root << r.to_sass_tree}
          return root
        end
        return if hide_in_sass
        return if !self.equal?(group.first)

        last_el = nil
        sel = group.map do |el|
          comma_sel = []
          loop do
            comma_sel << el.sass_selector_str
            break unless el.rules.size == 1 && el.rules.first.is_a?(Element)
            el = el.rules.first
          end
          last_el = el
          comma_sel = comma_sel.join(' ').gsub(' :', ':')
          comma_sel.gsub!(/^:/, '&:') unless parent.root?
          comma_sel
        end.join(', ')

        rule = Sass::Tree::RuleNode.new([sel])
        last_el.rules.each {|r| rule << r.to_sass_tree}
        return rule
      end

      def sass_selector_str
        case @selector
        when /[+>~]/; "#{@selector} #{@name}"
        else @selector + @name
        end
      end
    end

    module Mixin
      class Call
        def to_sass_tree
          return if hide_in_sass
          Sass::Tree::MixinNode.new(@mixin.name.gsub(/^\./, ''), @params.map {|v| v.to_sass_tree}, {})
        end
      end

      class Def
        def to_sass_tree
          return if hide_in_sass
          mixin = Sass::Tree::MixinDefNode.new(name, @params.map do |v|
              v.value.flatten!
              [Sass::Script::Variable.new(v), v.value.to_sass_tree]
            end)
          rules.each {|r| mixin << r.to_sass_tree}
          mixin
        end
      end
    end

    class SassNode
      include Entity

      def initialize(node)
        @node = node
      end

      def to_sass_tree
        return if hide_in_sass
        @node
      end
    end

    class Property
      def to_sass_tree
        return if hide_in_sass
        Sass::Tree::PropNode.new([self], @value.to_sass_tree, :new)
      end
    end

    class Expression
      def to_sass_tree
        if first.is_a?(Array)
          val = map {|e| _to_sass_tree(e)}.inject(nil) do |e, i|
            next i unless e
            Sass::Script::Operation.new(e, i, :comma)
          end
        else
          val = _to_sass_tree(self)
        end
        val.options = {}
        val
      end

      private

      LESS_TO_SASS_OPERATORS = {"-" => :minus, "+" => :plus, "*" => :times, "/" => :div, "=" => :single_eq}

      def _to_sass_tree(arr)
        e, rest = _to_sass_tree_plus_minus_eq(arr)
        until rest.empty?
          e2, rest = _to_sass_tree_plus_minus_eq(rest)
          e = Sass::Script::Operation.new(e, e2, :space)
        end
        return e
      end

      def _to_sass_tree_plus_minus_eq(arr)
        e, rest = _to_sass_tree_times_div(arr)
        while rest[0] && rest[0].is_a?(Operator) && %w[+ - =].include?(rest[0])
          op = LESS_TO_SASS_OPERATORS[rest[0]]
          e2, rest = _to_sass_tree_times_div(rest[1..-1])
          e = Sass::Script::Operation.new(e, e2, op)
        end
        return e, rest
      end

      def _to_sass_tree_times_div(arr)
        e, rest = _to_sass_tree_unary(arr)
        while rest[0] && rest[0].is_a?(Operator) && %w[* /].include?(rest[0])
          op = LESS_TO_SASS_OPERATORS[rest[0]]
          e2, rest = _to_sass_tree_unary(rest[1..-1])
          e = Sass::Script::Operation.new(e, e2, op)
        end
        return e, rest
      end

      def _to_sass_tree_unary(arr)
        if arr[0] == "-"
          first, rest = _sass_split(arr[1..-1])
          return Sass::Script::UnaryOperation.new(first, :minus), rest
        else
          return _sass_split(arr[0..-1])
        end
      end

      def _sass_split(arr)
        return arr[0].to_sass_tree, arr[1..-1] unless arr[0] == "("
        parens = 1
        i = arr[1..-1].each_with_index do |e, i|
          parens += 1 if e == "("
          parens -= 1 if e == ")"
          break i if parens == 0
        end

        return _to_sass_tree(arr[1...i+1]), arr[i+2..-1]
      end
    end

    class Color
      def to_sass_tree
        Sass::Script::Color.new(:red => r, :green => g, :blue => b, :alpha => a)
      end
    end

    class Number
      def to_sass_tree
        Sass::Script::Number.new(self, [self.unit])
      end
    end

    class Variable
      def to_sass_tree
        if @declaration
          return if hide_in_sass
          node = Sass::Tree::VariableNode.new(self, @value.to_sass_tree, false)
          node.line = self.src_line
          node
        else
          Sass::Script::Variable.new(self)
        end
      end
    end

    class Function
      def to_sass_tree
        Sass::Script::Funcall.new(self, @args.map {|a| a.to_sass_tree}, {})
      end
    end

    class Keyword
      def to_sass_tree
        Sass::Script::String.new(self)
      end
    end

    class Anonymous
      def to_sass_tree
        Sass::Script::String.new(self)
      end
    end

    class Quoted
      def to_sass_tree
        Sass::Script::String.new(self, true)
      end
    end

    class FontFamily
      def to_sass_tree
        @family.map {|f| f.to_sass_tree}.inject(nil) do |e, f|
          next f unless e
          Sass::Script::Operation.new(e, f, :comma)
        end
      end
    end
  end

  # The entry point to Less.
  # By default Less doesn't preserve the filename of the file being parsed,
  # which is unpleasant for error reporting.
  # Our monkeypatch keeps it around.
  class Engine
    def initialize_with_sass(obj, opts = {})
      initialize_without_sass(obj, opts)
      @filename = obj.path if obj.is_a?(File)
    end
    alias_method :initialize_without_sass, :initialize
    alias_method :initialize, :initialize_with_sass

    def parse_with_sass
      parse_without_sass
    rescue Sass::SyntaxError => e
      e.modify_backtrace(:filename => @filename)
      raise e
    end
    alias_method :parse_without_sass, :parse
    alias_method :parse, :parse_with_sass
    alias_method :to_tree, :parse
  end
end
# encoding: utf-8
module Mongoid #:nodoc
  module Inspection #:nodoc

    # Returns the class name plus its attributes. If using dynamic fields will
    # include those as well.
    #
    # Example:
    #
    # <tt>person.inspect</tt>
    #
    # Returns:
    #
    # A nice pretty string to look at.
    def inspect
      inspection = []
      inspection.concat(inspect_fields).concat(inspect_dynamic_fields)
      "#<#{self.class.name} _id: #{id}, #{inspection * ', '}>"
    end

    private

    # Get an array of inspected fields for the document.
    #
    # Example:
    #
    # <tt>inspect_fields</tt>
    #
    # Returns:
    #
    # An array of pretty printed field values.
    def inspect_fields
      fields.map do |name, field|
        "#{name}: #{@attributes[name].inspect}"
      end
    end

    # Get an array of inspected dynamic fields for the document.
    #
    # Example:
    #
    # <tt>inspect_dynamic_fields</tt>
    #
    # Returns:
    #
    # An array of pretty printed dynamic field values.
    def inspect_dynamic_fields
      if Mongoid.allow_dynamic_fields
        keys = @attributes.keys - fields.keys - relations.keys - ["_id", "_type"]
        return keys.map do |name|
          "#{name}: #{@attributes[name].inspect}"
        end
      else
        []
      end
    end
  end
end
# Seed add you the ability to populate your db.
# We provide you a basic shell for interaction with the end user.
# So try some code like below:
#
#   name = shell.ask("What's your name?")
#   shell.say name
#
email     = shell.ask "Which email do you want use for logging into admin?"
password  = shell.ask "Tell me the password to use:"

shell.say ""

account = Account.create(:email => email, :name => "Foo", :surname => "Bar", :password => password, :password_confirmation => password, :role => "admin")

if account.valid?
  shell.say "================================================================="
  shell.say "Account has been successfully created, now you can login with:"
  shell.say "================================================================="
  shell.say "   email: #{email}"
  shell.say "   password: #{password}"
  shell.say "================================================================="
else
  shell.say "Sorry but some thing went wrong!"
  shell.say ""
  account.errors.full_messages.each { |m| shell.say "   - #{m}" }
end

shell.say ""

# Seed add you the ability to populate your db.
# We provide you a basic shell for interaction with the end user.
# So try some code like below:
#
#   name = shell.ask("What's your name?")
#   shell.say name
#
email     = shell.ask "Which email do you want use for logging into admin?"
password  = shell.ask "Tell me the password to use:"

shell.say ""

account = Account.create(:email => email, :name => "Foo", :surname => "Bar", :password => password, :password_confirmation => password, :role => "admin")

if account.valid?
  shell.say "================================================================="
  shell.say "Account has been successfully created, now you can login with:"
  shell.say "================================================================="
  shell.say "   email: #{email}"
  shell.say "   password: #{password}"
  shell.say "================================================================="
else
  shell.say "Sorry but some thing went wrong!"
  shell.say ""
  account.errors.full_messages.each { |m| shell.say "   - #{m}" }
end

shell.say ""case ENV['JSON']
when 'pure'
  $:.unshift 'lib'
  require 'json/pure'
when 'ext'
  $:.unshift 'ext', 'lib'
  require 'json/ext'
else
  $:.unshift 'ext', 'lib'
  require 'json'
end
# Author:: Nathaniel Talbott.
# Copyright:: Copyright (c) 2000-2003 Nathaniel Talbott. All rights reserved.
# License:: Ruby license.

require 'test/unit/collector'

module Test
  module Unit
    module Collector
      class ObjectSpace
        include Collector
        
        NAME = 'collected from the ObjectSpace'
        
        def initialize(source=::ObjectSpace)
          super()
          @source = source
        end
        
        def collect(name=NAME)
          suite = TestSuite.new(name)
          sub_suites = []
          @source.each_object(Class) do |klass|
            if(Test::Unit::TestCase > klass)
              add_suite(sub_suites, klass.suite)
            end
          end
          sort(sub_suites).each{|s| suite << s}
          suite
        end
      end
    end
  end
end
require File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../fixtures/classes', __FILE__)
require File.expand_path('../shared/collect', __FILE__)

describe "Enumerable#map" do   
  it_behaves_like(:enumerable_collect , :map) 
end
# Autogenerated from a Treetop grammar. Edits may be lost.


module Mail
  module DateTime
    include Treetop::Runtime

    def root
      @root ||= :primary
    end

    include RFC2822

    module Primary0
      def day_of_week
        elements[0]
      end

    end

    module Primary1
      def date
        elements[1]
      end

      def FWS
        elements[2]
      end

      def time
        elements[3]
      end

    end

    def _nt_primary
      start_index = index
      if node_cache[:primary].has_key?(index)
        cached = node_cache[:primary][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      i2, s2 = index, []
      r3 = _nt_day_of_week
      s2 << r3
      if r3
        if has_terminal?(",", false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(",")
          r4 = nil
        end
        s2 << r4
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(Primary0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r1 = r2
      else
        r1 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r1
      if r1
        r5 = _nt_date
        s0 << r5
        if r5
          r6 = _nt_FWS
          s0 << r6
          if r6
            r7 = _nt_time
            s0 << r7
            if r7
              r9 = _nt_CFWS
              if r9
                r8 = r9
              else
                r8 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r8
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Primary1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:primary][start_index] = r0

      r0
    end

  end

  class DateTimeParser < Treetop::Runtime::CompiledParser
    include DateTime
  end

endrequire 'spec_helper'

module RSpec::Core
  describe CommandLineConfiguration do
    describe '#run' do
      context 'given autotest command' do
        let(:config) { CommandLineConfiguration.new('autotest') }

        it 'calls Autotest.generate' do
          CommandLineConfiguration::Autotest.should_receive(:generate)
          config.run
        end
      end

      context 'given unsupported command' do
        let(:config) { CommandLineConfiguration.new('unsupported') }

        it 'raises ArgumentError' do
          lambda { config.run }.should(
            raise_error(ArgumentError, /"unsupported" is not valid/)
          )
        end
      end
    end
  end
end
# SOAP4R - SOAP Header handler set
# Copyright (C) 2003, 2004  NAKAMURA, Hiroshi <nahi@ruby-lang.org>.

# This program is copyrighted free software by NAKAMURA, Hiroshi.  You can
# redistribute it and/or modify it under the same terms of Ruby's license;
# either the dual license version in 2003, or any later version.


require 'xsd/namedelements'


module SOAP
module Header


class HandlerSet
  def initialize
    @store = XSD::NamedElements.new
  end

  def dup
    obj = HandlerSet.new
    obj.store = @store.dup
    obj
  end

  def add(handler)
    @store << handler
  end
  alias << add

  def delete(handler)
    @store.delete(handler)
  end

  def include?(handler)
    @store.include?(handler)
  end

  # returns: Array of SOAPHeaderItem
  def on_outbound
    @store.collect { |handler|
      handler.on_outbound_headeritem
    }.compact
  end

  # headers: SOAPHeaderItem enumerable object
  def on_inbound(headers)
    headers.each do |name, item|
      handler = @store.find { |handler|
        handler.elename == item.element.elename
      }
      if handler
        handler.on_inbound_headeritem(item)
      elsif item.mustunderstand
        raise UnhandledMustUnderstandHeaderError.new(item.element.elename.to_s)
      end
    end
  end

protected

  def store=(store)
    @store = store
  end
end


end
end
#
#  tkextlib/bwidget/combobox.rb
#                               by Hidetoshi NAGAI (nagai@ai.kyutech.ac.jp)
#

require 'tk'
require 'tk/entry'
require 'tkextlib/bwidget.rb'
require 'tkextlib/bwidget/listbox'
require 'tkextlib/bwidget/spinbox'

module Tk
  module BWidget
    class ComboBox < Tk::BWidget::SpinBox
    end
  end
end

class Tk::BWidget::ComboBox
  include Scrollable

  TkCommandNames = ['ComboBox'.freeze].freeze
  WidgetClassName = 'ComboBox'.freeze
  WidgetClassNames[WidgetClassName] ||= self

  def __boolval_optkeys
    super() << 'autocomplete' << 'autopost'
  end
  private :__boolval_optkeys

  def get_listbox(&b)
    win = window(tk_send_without_enc('getlistbox'))
    if b
      if TkCore::WITH_RUBY_VM  ### Ruby 1.9 !!!!
        win.instance_exec(self, &b)
      else
        win.instance_eval(&b)
      end
    end
    win
  end

  def clear_value
    tk_send_without_enc('clearvalue')
    self
  end
  alias clearvalue clear_value

  def icursor(idx)
    tk_send_without_enc('icursor', idx)
  end

  def post
    tk_send_without_enc('post')
    self
  end

  def unpost
    tk_send_without_enc('unpost')
    self
  end
end
require File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../fixtures/classes', __FILE__)

describe "IO#close_read" do

  before :each do
    @io = IO.popen 'cat', "r+"
    @path = tmp('io.close.txt')
  end

  after :each do
    @io.close unless @io.closed?
  end

  it "closes the read end of a duplex I/O stream" do
    @io.close_read

    lambda { @io.read }.should raise_error(IOError)
  end

  it "raises an IOError on subsequent invocations" do
    @io.close_read

    lambda { @io.close_read }.should raise_error(IOError)
  end

  it "allows subsequent invocation of close" do
    @io.close_read

    lambda { @io.close }.should_not raise_error
  end

  it "raises an IOError if the stream is writable and not duplexed" do
    io = File.open @path, 'w'

    begin
      lambda { io.close_read }.should raise_error(IOError)
    ensure
      io.close unless io.closed?
    end
    File.unlink(@path)
  end

  it "closes the stream if it is neither writable nor duplexed" do
    io_close_path = @path
    touch io_close_path

    io = File.open io_close_path

    io.close_read

    io.closed?.should == true
    File.unlink(@path)
  end

  it "raises IOError on closed stream" do
    @io.close

    lambda { @io.close_read }.should raise_error(IOError)
  end

end

require File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../fixtures/classes', __FILE__)
require File.expand_path('../shared/replace', __FILE__)

describe "Array#replace" do
  it_behaves_like(:array_replace, :replace)
end
require File.expand_path('../../../spec_helper', __FILE__)

describe "TrueClass#to_s" do
  it "returns the string 'true'" do
    true.to_s.should == "true"
  end
end
require File.expand_path('../../../spec_helper', __FILE__)
require 'rational'

describe :rational_numerator, :shared => true do
  it "returns the numerator" do
    Rational(3, 4).numerator.should equal(3)
    Rational(3, -4).numerator.should equal(-3)
    
    Rational(bignum_value, 1).numerator.should == bignum_value
  end
end
require File.expand_path('../../../../spec_helper', __FILE__)

describe "FFI::Library#attach_function" do
  it "needs to be reviewed for spec completeness"
end
# encoding: utf-8
module Mongoid #:nodoc:
  class Identity #:nodoc:

    attr_reader :document

    # Create the identity for the document. The id will be set in either in
    # the form of a Mongo object id or a composite key set up by defining
    # a key on the document. The _type will be set to the document's class
    # name.
    #
    # @example Create the id and set the type.
    #   identity.create
    def create
      identify.tap { type }
    end

    # Create the new identity generator - this will be expanded in the future
    # to support pk generators.
    #
    # @example
    #   Identity.new(document)
    #
    # @param [ Document ] document The document to generate an id for.
    #
    # @return [ Identity ] The new identity object.
    def initialize(document)
      @document = document
    end

    private

    # Return the proper id for the document. Will be an object id or its string
    # representation depending on the configuration.
    #
    # @example Generate the id.
    #   identity.generate_id
    #
    # @return [ Object ] The bson object id or its string equivalent.
    def generate_id
      id = BSON::ObjectId.new
      document.using_object_ids? ? id : id.to_s
    end

    # Sets the id on the document. Will either set a newly generated id or
    # build the composite key.
    #
    # @example Set the id.
    #   identity.identify
    def identify
      if !document.embedded? || Mongoid.embedded_object_id
        document.id = compose.join(" ").identify if document.primary_key
        document.id = generate_id if document.id.blank?
      end
      document.id
    end

    # Set the _type field on the document if the document is hereditary or in a
    # polymorphic relation.
    #
    # @example Set the type.
    #   identity.type
    def type
      document._type = document.class.name if typed?
    end

    # Generates the array of keys to build the id.
    #
    # @example Build the array for the keys.
    #   identity.compose.
    #
    # @return [ Array<Object> ] The array of keys.
    def compose
      document.primary_key.collect do |key|
        document.attributes[key]
      end.reject { |val| val.nil? }
    end

    # Determines if the document stores the type information. This is if it is
    # in a hierarchy, has subclasses, or is in a polymorphic relation.
    #
    # @example Check if the document is typed.
    #   identity.typed?
    #
    # @return [ true, false ] True if typed, false if not.
    def typed?
      document.hereditary? ||
        document.class.descendants.any? ||
        document.polymorphic?
    end
  end
end
require File.expand_path('../../../../spec_helper', __FILE__)
require File.expand_path('../shared/constants', __FILE__)

describe "Digest::SHA512#hexdigest!" do

  it 'returns a hexdigest and resets the state' do
    cur_digest = Digest::SHA512.new

    cur_digest << SHA512Constants::Contents
    cur_digest.hexdigest!.should == SHA512Constants::Hexdigest
    cur_digest.hexdigest.should == SHA512Constants::BlankHexdigest
  end

end
require 'test/unit'
require 'soap/property'


module SOAP


class TestProperty < Test::Unit::TestCase
  FrozenError = (RUBY_VERSION >= "1.9.0") ? RuntimeError : TypeError

  def setup
    @prop = ::SOAP::Property.new
  end

  def teardown
    # Nothing to do.
  end

  def test_s_load
    propstr = <<__EOP__

# comment1

# comment2\r
# comment2

\r
a.b.0 = 1
a.b.1 = 2
a.b.2 = 3
client.protocol.http.proxy=http://myproxy:8080   \r
client.protocol.http.no_proxy:  intranet.example.com,local.example.com\r
client.protocol.http.protocol_version = 1.0
foo\\:bar\\=baz = qux
foo\\\\.bar.baz=\tq\\\\ux\ttab
  a\\ b                            =                          1   
[ppp.qqq.rrr]
sss = 3
ttt.uuu = 4

[ sss.ttt.uuu  ]
vvv.www = 5
[  ]
xxx.yyy.zzz = 6
__EOP__
    prop = Property.load(propstr)
    assert_equal(["1", "2", "3"], prop["a.b"].values.sort)
    assert_equal("intranet.example.com,local.example.com",
      prop["client.protocol.http.no_proxy"])
    assert_equal("http://myproxy:8080", prop["client.protocol.http.proxy"])
    assert_equal("1.0", prop["client.protocol.http.protocol_version"])
    assert_equal("q\\ux\ttab", prop['foo\.bar.baz'])
    assert_equal("1", prop['a b'])
    assert_equal("3", prop['ppp.qqq.rrr.sss'])
    assert_equal("4", prop['ppp.qqq.rrr.ttt.uuu'])
    assert_equal("5", prop['sss.ttt.uuu.vvv.www'])
    assert_equal("6", prop['xxx.yyy.zzz'])
  end

  def test_load
    prop = Property.new
    hooked = false
    prop.add_hook("foo.bar.baz") do |name, value|
      assert_equal(["foo", "bar", "baz"], name)
      assert_equal("123", value)
      hooked = true
    end
    prop.lock
    prop["foo.bar"].lock
    prop.load("foo.bar.baz = 123")
    assert(hooked)
    assert_raises(FrozenError) do
      prop.load("foo.bar.qux = 123")
    end
    prop.load("foo.baz = 456")
    assert_equal("456", prop["foo.baz"])
  end

  def test_initialize
    prop = ::SOAP::Property.new
    # store is empty
    assert_nil(prop["a"])
    # does hook work?
    assert_equal(1, prop["a"] = 1)
  end

  def test_aref
    # name_to_a
    assert_nil(@prop[:foo])
    assert_nil(@prop["foo"])
    assert_nil(@prop[[:foo]])
    assert_nil(@prop[["foo"]])
    assert_raises(ArgumentError) do
      @prop[1]
    end
    @prop[:foo] = :foo
    assert_equal(:foo, @prop[:foo])
    assert_equal(:foo, @prop["foo"])
    assert_equal(:foo, @prop[[:foo]])
    assert_equal(:foo, @prop[["foo"]])
  end

  def test_referent
    # referent(1)
    assert_nil(@prop["foo.foo"])
    assert_nil(@prop[["foo", "foo"]])
    assert_nil(@prop[["foo", :foo]])
    @prop["foo.foo"] = :foo
    assert_equal(:foo, @prop["foo.foo"])
    assert_equal(:foo, @prop[["foo", "foo"]])
    assert_equal(:foo, @prop[[:foo, "foo"]])
    # referent(2)
    @prop["bar.bar.bar"] = :bar
    assert_equal(:bar, @prop["bar.bar.bar"])
    assert_equal(:bar, @prop[["bar", "bar", "bar"]])
    assert_equal(:bar, @prop[[:bar, "bar", :bar]])
  end

  def test_to_key_and_deref
    @prop["foo.foo"] = :foo
    assert_equal(:foo, @prop["fOo.FoO"])
    assert_equal(:foo, @prop[[:fOO, :FOO]])
    assert_equal(:foo, @prop[["FoO", :Foo]])
    # deref_key negative test
    assert_raises(ArgumentError) do
      @prop["baz"] = 1
      @prop["baz.qux"] = 2
    end
  end

  def test_hook_name
    tag = Object.new
    tested = false
    @prop.add_hook("foo.bar") do |key, value|
      assert_raise(FrozenError) do
	key << "baz"
      end
      tested = true
    end
    @prop["foo.bar"] = tag
    assert(tested)
  end

  def test_value_hook
    tag = Object.new
    tested = false
    @prop.add_hook("FOO.BAR.BAZ") do |key, value|
      assert_equal(["Foo", "baR", "baZ"], key)
      assert_equal(tag, value)
      tested = true
    end
    @prop["Foo.baR.baZ"] = tag
    assert_equal(tag, @prop["foo.bar.baz"])
    assert(tested)
    @prop["foo.bar"] = 1	# unhook the above block
    assert_equal(1, @prop["foo.bar"])
  end

  def test_key_hook_no_cascade
    tag = Object.new
    tested = 0
    @prop.add_hook do |key, value|
      assert(false)
    end
    @prop.add_hook(false) do |key, value|
      assert(false)
    end
    @prop.add_hook("foo") do |key, value|
      assert(false)
    end
    @prop.add_hook("foo.bar", false) do |key, value|
      assert(false)
    end
    @prop.add_hook("foo.bar.baz") do |key, value|
      assert(false)
    end
    @prop.add_hook("foo.bar.baz.qux", false) do |key, value|
      assert_equal(["foo", "bar", "baz", "qux"], key)
      assert_equal(tag, value)
      tested += 1
    end
    @prop["foo.bar.baz.qux"] = tag
    assert_equal(tag, @prop["foo.bar.baz.qux"])
    assert_equal(1, tested)
  end

  def test_key_hook_cascade
    tag = Object.new
    tested = 0
    @prop.add_hook(true) do |key, value|
      assert_equal(["foo", "bar", "baz", "qux"], key)
      assert_equal(tag, value)
      tested += 1
    end
    @prop.add_hook("foo", true) do |key, value|
      assert_equal(["foo", "bar", "baz", "qux"], key)
      assert_equal(tag, value)
      tested += 1
    end
    @prop.add_hook("foo.bar", true) do |key, value|
      assert_equal(["foo", "bar", "baz", "qux"], key)
      assert_equal(tag, value)
      tested += 1
    end
    @prop.add_hook("foo.bar.baz", true) do |key, value|
      assert_equal(["foo", "bar", "baz", "qux"], key)
      assert_equal(tag, value)
      tested += 1
    end
    @prop.add_hook("foo.bar.baz.qux", true) do |key, value|
      assert_equal(["foo", "bar", "baz", "qux"], key)
      assert_equal(tag, value)
      tested += 1
    end
    @prop["foo.bar.baz.qux"] = tag
    assert_equal(tag, @prop["foo.bar.baz.qux"])
    assert_equal(5, tested)
  end

  def test_keys
    assert(@prop.keys.empty?)
    @prop["foo"] = 1
    @prop["bar"]
    @prop["BAz"] = 2
    assert_equal(2, @prop.keys.size)
    assert(@prop.keys.member?("foo"))
    assert(@prop.keys.member?("baz"))
    #
    assert_nil(@prop["a"])
    @prop["a.a"] = 1
    assert_instance_of(::SOAP::Property, @prop["a"])
    @prop["a.b"] = 1
    @prop["a.c"] = 1
    assert_equal(3, @prop["a"].keys.size)
    assert(@prop["a"].keys.member?("a"))
    assert(@prop["a"].keys.member?("b"))
    assert(@prop["a"].keys.member?("c"))
  end

  def test_lshift
    assert(@prop.empty?)
    @prop << 1
    assert_equal([1], @prop.values)
    assert_equal(1, @prop["0"])
    @prop << 1
    assert_equal([1, 1], @prop.values)
    assert_equal(1, @prop["1"])
    @prop << 1
    assert_equal([1, 1, 1], @prop.values)
    assert_equal(1, @prop["2"])
    #
    @prop["abc.def"] = o = SOAP::Property.new
    tested = 0
    o.add_hook do |k, v|
      tested += 1
    end
    @prop["abc.def"] << 1
    @prop["abc.def"] << 2
    @prop["abc.def"] << 3
    @prop["abc.def"] << 4
    assert_equal(4, tested)
  end

  def test_lock_each
    @prop["a.b.c.d.e"] = 1
    @prop["a.b.d"] = branch = ::SOAP::Property.new
    @prop["a.b.d.e.f"] = 2
    @prop.lock
    assert(@prop.locked?)
    assert_instance_of(::SOAP::Property, @prop["a"])
    assert_raises(FrozenError) do
      @prop["b"]
    end
    #
    @prop["a"].lock
    assert_raises(FrozenError) do
      @prop["a"]
    end
    assert_instance_of(::SOAP::Property, @prop["a.b"])
    #
    @prop["a.b"].lock
    assert_raises(FrozenError) do
      @prop["a.b"]
    end
    assert_raises(FrozenError) do
      @prop["a"]
    end
    #
    @prop["a.b.c.d"].lock
    assert_instance_of(::SOAP::Property, @prop["a.b.c"])
    assert_raises(FrozenError) do
      @prop["a.b.c.d"]
    end
    assert_instance_of(::SOAP::Property, @prop["a.b.d"])
    #
    branch["e"].lock
    assert_instance_of(::SOAP::Property, @prop["a.b.d"])
    assert_raises(FrozenError) do
      @prop["a.b.d.e"]
    end
    assert_raises(FrozenError) do
      branch["e"]
    end
  end

  def test_lock_cascade
    @prop["a.a"] = nil
    @prop["a.b.c"] = 1
    @prop["b"] = false
    @prop.lock(true)
    assert(@prop.locked?)
    assert_equal(nil, @prop["a.a"])
    assert_equal(1, @prop["a.b.c"])
    assert_equal(false, @prop["b"])
    assert_raises(FrozenError) do
      @prop["c"]
    end
    assert_raises(FrozenError) do
      @prop["c"] = 2
    end
    assert_raises(FrozenError) do
      @prop["a.b.R"]
    end
    assert_raises(FrozenError) do
      @prop.add_hook do
	assert(false)
      end
    end
    assert_raises(FrozenError) do
      @prop.add_hook("c") do
	assert(false)
      end
    end
    assert_raises(FrozenError) do
      @prop.add_hook("a.c") do
	assert(false)
      end
    end
    assert_nil(@prop["a.a"])
    @prop["a.a"] = 2
    assert_equal(2, @prop["a.a"])
    #
    @prop.unlock(true)
    assert_nil(@prop["c"])
    @prop["c"] = 2
    assert_equal(2, @prop["c"])
    @prop["a.d.a.a"] = :foo
    assert_equal(:foo, @prop["a.d.a.a"])
    tested = false
    @prop.add_hook("a.c") do |name, value|
      assert(true)
      tested = true
    end
    @prop["a.c"] = 3
    assert(tested)
  end

  def test_hook_then_lock
    tested = false
    @prop.add_hook("a.b.c") do |name, value|
      assert_equal(["a", "b", "c"], name)
      tested = true
    end
    @prop["a.b"].lock
    assert(!tested)
    @prop["a.b.c"] = 5
    assert(tested)
    assert_equal(5, @prop["a.b.c"])
    assert_raises(FrozenError) do
      @prop["a.b.d"] = 5
    end
  end

  def test_lock_unlock_return
    assert_equal(@prop, @prop.lock)
    assert_equal(@prop, @prop.unlock)
  end

  def test_lock_split
    @prop["a.b.c"] = 1
    assert_instance_of(::SOAP::Property, @prop["a.b"])
    @prop["a.b.d"] = branch = ::SOAP::Property.new
    @prop["a.b.d.e"] = 2
    assert_equal(branch, @prop["a.b.d"])
    assert_equal(branch, @prop[:a][:b][:d])
    @prop.lock(true)
    # split error 1
    assert_raises(FrozenError) do
      @prop["a.b"]
    end
    # split error 2
    assert_raises(FrozenError) do
      @prop["a"]
    end
    @prop["a.b.c"] = 2
    assert_equal(2, @prop["a.b.c"])
    # replace error
    assert_raises(FrozenError) do
      @prop["a.b.c"] = ::SOAP::Property.new
    end
    # override error
    assert_raises(FrozenError) do
      @prop["a.b"] = 1
    end
    #
    assert_raises(FrozenError) do
      @prop["a.b.d"] << 1
    end
    assert_raises(FrozenError) do
      branch << 1
    end
    branch.unlock(true)
    branch << 1
    branch << 2
    branch << 3
    assert_equal(2, @prop["a.b.d.e"])
    assert_equal(1, @prop["a.b.d.1"])
    assert_equal(2, @prop["a.b.d.2"])
    assert_equal(3, @prop["a.b.d.3"])
  end
end


end
#
# Demo: Bitmaps
#
def demoBitmaps(t)
  #if $Version_1_1_OrLater
  if @has_bgimg
    t.configure(:showroot=>false, :showbuttons=>false, :showlines=>false,
                :selectmode=>:browse, :orient=>:horizontal, :wrap=>'5 items',
                :showheader=>false, :backgroundimage=>@images['sky'])
  else
    t.configure(:showroot=>false, :showbuttons=>false, :showlines=>false,
                :selectmode=>:browse, :orient=>:horizontal, :wrap=>'5 items',
                :showheader=>false)
  end

  if $HasColumnCreate
    t.column_create(:itembackground=>['gray90', []])
  else
    t.column_configure(0, :itembackground=>['gray90', []])
  end

  t.element_create('elemTxt', :text,
                   :fill=>[@SystemHighlightText, ['selected', 'focus']])
  t.element_create('elemSelTxt', :rect, :showfocus=>true,
                   :fill=>[@SystemHighlight, ['selected', 'focus']])
  t.element_create('elemSelBmp', :rect, :outlinewidth=>4,
                   :outline=>[@SystemHighlight, ['selected', 'focus']])
  t.element_create('elemBmp', :bitmap,
                   :foreground=>[@SystemHighlight, ['selected', 'focus']],
                   :background=>'linen',
                   :bitmap=>['question' ['selected']])

  s = t.style_create('STYLE', :orient=>:vertical)
  t.style_elements(s, ['elemSelBmp', 'elemBmp', 'elemSelTxt', 'elemTxt'])
  t.style_layout(s, 'elemSelBmp', :union=>'elemBmp', :ipadx=>6, :ipady=>6)
  t.style_layout(s, 'elemBmp',    :pady=>[0, 6], :expand=>:we)
  t.style_layout(s, 'elemSelTxt', :union=>'elemTxt', :ipadx=>2)
  t.style_layout(s, 'elemTxt',    :expand=>:we)

  # Set default item style
  if $Version_1_1_OrLater
    t.defaultstyle = [s]
  end

  bitmap_names = %w(error gray75 gray50 gray25 gray12
                    hourglass info questhead question warning)

  bitmap_names.each{|name|
    i = t.item_create
    unless $Version_1_1_OrLater
      t.item_style_set(i, 0, s)
    end
    t.item_text(i, 0, name)
    t.item_element_configure(i, 0, 'elemBmp', :bitmap=>name)
    t.item_lastchild(:root, i)
  }

  bitmap_names.each{|name|
    i = t.item_create
    t.item_style_set(i, 0, s)
    t.item_text(i, 0, name)
    if true
      t.item_element_configure(i, 0, 'elemBmp', :bitmap=>name,
                               :foreground=>['brown', ''],
                               :background=>['', ''])
    else
      t.item_element_configure(i, 0, 'elemBmp', :bitmap=>name,
                               :foreground=>[
                                 @SystemHighlight, ['selected', 'focus'],
                                 'brown', []
                               ],
                               :background=>['', []])
    end
    t.item_lastchild(:root, i)
  }
end
require 'cucumber/formatter/gherkin_formatter_adapter'
require 'cucumber/formatter/io'
require 'gherkin/formatter/argument'
require 'gherkin/formatter/json_formatter'

module Cucumber
  module Formatter
    # The formatter used for <tt>--format json</tt>
    class Json < GherkinFormatterAdapter
      include Io

      def initialize(step_mother, io, options)
        @io = ensure_io(io, "json")
        @obj = {'features' => []}
        super(Gherkin::Formatter::JSONFormatter.new(nil), false)
      end

      def after_feature(feature)
        super
        @obj['features'] << @gf.gherkin_object
      end

      def after_features(features)
        @io.write(@obj.to_json)
      end
    end
  end
end

require File.expand_path('../../../../spec_helper', __FILE__)

describe "Process::Status#exitstatus" do

  before :each do
    ruby_exe("exit(42)")
  end

  it "returns the process exit code" do
    $?.exitstatus.should == 42
  end

end
require 'benchmark'

class << Benchmark
  def ms
    1000 * realtime { yield }
  end
end
require File.expand_path('../../../spec_helper', __FILE__)

ruby_version_is "1.9" do
  describe "Proc#lambda?" do
    it "returns true if the object was created with the lambda keyword" do
      lambda { true }.lambda?.should be_true
    end

    it "returns false if the object was created with the proc keyword" do
      proc { true }.lambda?.should be_false
    end

    it "returns false if the object was created with Proc.new" do
      Proc.new { true }.lambda?.should be_false
    end

    # [ruby-core:24127]
    it "returns true if the object was created with Proc#curry" do
      l = lambda { true }
      l.curry.lambda?.should be_true
    end
  end
end
require File.expand_path(File.dirname(__FILE__) + '/edgecase')

class AboutOpenClasses < EdgeCase::Koan
  class Dog
    def bark
      "WOOF"
    end
  end

  def test_as_defined_dogs_do_bark
    fido = Dog.new
    assert_equal __("WOOF"), fido.bark
  end

  # ------------------------------------------------------------------

  # Open the existing Dog class and add a new method.
  class Dog
    def wag
      "HAPPY"
    end
  end

  def test_after_reopening_dogs_can_both_wag_and_bark
    fido = Dog.new
    assert_equal __("HAPPY"), fido.wag
    assert_equal __("WOOF"), fido.bark
  end

  # ------------------------------------------------------------------

  class ::Integer
    def even?
      (self % 2) == 0
    end
  end

  def test_even_existing_built_in_classes_can_be_reopened
    assert_equal __(false), 1.even?
    assert_equal __(true), 2.even?
  end

  # NOTE: To understand why we need the :: before Integer, you need to
  # become enlightened about scope.  
end
require 'rubygems'
require 'minitest/unit'
require 'rdoc/stats'
require 'rdoc/options'
require 'rdoc/code_objects'
require 'rdoc/parser/ruby'
require 'test/xref_data'

class XrefTestCase < MiniTest::Unit::TestCase

  def setup
    RDoc::TopLevel.reset
    RDoc::AnyMethod.reset

    @file_name = 'xref_data.rb'
    @xref_data = RDoc::TopLevel.new @file_name

    @options = RDoc::Options.new
    @options.quiet = true

    stats = RDoc::Stats.new 0

    parser = RDoc::Parser::Ruby.new @xref_data, @file_name, XREF_DATA, @options,
                                    stats
    @top_levels = []
    @top_levels.push parser.scan

    generator = Object.new
    def generator.class_dir() nil end
    def generator.file_dir() nil end
    rdoc = RDoc::RDoc.new
    RDoc::RDoc.current = rdoc
    rdoc.generator = generator

    @c1    = @xref_data.find_module_named 'C1'
    @c2    = @xref_data.find_module_named 'C2'
    @c2_c3 = @xref_data.find_module_named 'C2::C3'
    @c3    = @xref_data.find_module_named 'C3'
    @c4    = @xref_data.find_module_named 'C4'
    @c4_c4 = @xref_data.find_module_named 'C4::C4'

    @m1    = @xref_data.find_module_named 'M1'
  end

end

MiniTest::Unit.autorun

require 'set'

module Sass
  # The lexical environment for SassScript.
  # This keeps track of variable and mixin definitions.
  #
  # A new environment is created for each level of Sass nesting.
  # This allows variables to be lexically scoped.
  # The new environment refers to the environment in the upper scope,
  # so it has access to variables defined in enclosing scopes,
  # but new variables are defined locally.
  #
  # Environment also keeps track of the {Engine} options
  # so that they can be made available to {Sass::Script::Functions}.
  class Environment
    # The enclosing environment,
    # or nil if this is the global environment.
    #
    # @return [Environment]
    attr_reader :parent
    attr_writer :options

    # @param parent [Environment] See \{#parent}
    def initialize(parent = nil)
      @vars = {}
      @mixins = {}
      @parent = parent
      @stack = [] unless parent
      @mixins_in_use = Set.new unless parent
      set_var("important", Script::String.new("!important")) unless @parent
    end

    # The options hash.
    # See {file:SASS_REFERENCE.md#sass_options the Sass options documentation}.
    #
    # @return [{Symbol => Object}]
    def options
      @options || (parent && parent.options) || {}
    end

    # Push a new stack frame onto the mixin/include stack.
    #
    # @param frame_info [{Symbol => Object}]
    #   Frame information has the following keys:
    #
    #   `:filename`
    #   : The name of the file in which the lexical scope changed.
    #
    #   `:mixin`
    #   : The name of the mixin in which the lexical scope changed,
    #     or `nil` if it wasn't within in a mixin.
    #
    #   `:line`
    #   : The line of the file on which the lexical scope changed. Never nil.
    def push_frame(frame_info)
      if stack.last && stack.last[:prepared]
        stack.last.delete(:prepared)
        stack.last.merge!(frame_info)
      else
        stack.push(frame_info)
      end
      mixins_in_use << stack.last[:mixin] if stack.last[:mixin] && !stack.last[:prepared]
    end

    # Like \{#push\_frame}, but next time a stack frame is pushed,
    # it will be merged with this frame.
    #
    # @param frame_info [{Symbol => Object}] Same as for \{#push\_frame}.
    def prepare_frame(frame_info)
      push_frame(frame_info.merge(:prepared => true))
    end

    # Pop a stack frame from the mixin/include stack.
    def pop_frame
      stack.pop if stack.last && stack.last[:prepared]
      popped = stack.pop
      mixins_in_use.delete(popped[:mixin]) if popped && popped[:mixin]
    end

    # A list of stack frames in the mixin/include stack.
    # The last element in the list is the most deeply-nested frame.
    #
    # @return [Array<{Symbol => Object}>] The stack frames,
    #   of the form passed to \{#push\_frame}.
    def stack
      @stack ||= @parent.stack
    end

    # A set of names of mixins currently present in the stack.
    #
    # @return [Set<String>] The mixin names.
    def mixins_in_use
      @mixins_in_use ||= @parent.mixins_in_use
    end

    class << self
      private

      # Note: when updating this,
      # update haml/yard/inherited_hash.rb as well.
      def inherited_hash(name)
        class_eval <<RUBY, __FILE__, __LINE__ + 1
          def #{name}(name)
            _#{name}(name.gsub('_', '-'))
          end

          def _#{name}(name)
            @#{name}s[name] || @parent && @parent._#{name}(name)
          end
          protected :_#{name}

          def set_#{name}(name, value)
            name = name.gsub('_', '-')
            @#{name}s[name] = value unless try_set_#{name}(name, value)
          end

          def try_set_#{name}(name, value)
            if @#{name}s.include?(name)
              @#{name}s[name] = value
              true
            elsif @parent
              @parent.try_set_#{name}(name, value)
            else
              false
            end
          end
          protected :try_set_#{name}

          def set_local_#{name}(name, value)
            @#{name}s[name.gsub('_', '-')] = value
          end
RUBY
      end
    end

    # variable
    # Script::Literal
    inherited_hash :var
    # mixin
    # Engine::Mixin
    inherited_hash :mixin
  end
end
require "webrat/core_extensions/deprecate"
require "pathname"

module Webrat

  # Configures Webrat. If this is not done, Webrat will be created
  # with all of the default settings.
  def self.configure(configuration = Webrat.configuration)
    yield configuration if block_given?
    @@configuration = configuration
  end

  def self.configuration # :nodoc:
    @@configuration ||= Webrat::Configuration.new
  end

  # Webrat can be configured using the Webrat.configure method. For example:
  #
  #   Webrat.configure do |config|
  #     config.mode = :sinatra
  #   end
  class Configuration

    # Webrat's mode, set automatically when requiring webrat/rails, webrat/merb, etc.
    attr_reader :mode # :nodoc:

    # Save and open pages with error status codes (500-599) in a browser? Defualts to true.
    attr_writer :open_error_files

    # Save and open page storage directory, defaults to "tmp" under current directory if exists, otherwise current directory
    attr_accessor :saved_pages_dir

    # Which rails environment should the selenium tests be run in? Defaults to test.
    attr_accessor :application_environment
    webrat_deprecate :selenium_environment, :application_environment
    webrat_deprecate :selenium_environment=, :application_environment=

    # Which port is the application running on for selenium testing? Defaults to 3001.
    attr_accessor :application_port
    webrat_deprecate :selenium_port, :application_port
    webrat_deprecate :selenium_port=, :application_port=

    # Which port should selenium use to access the application. Defaults to application_port
    attr_writer :application_port_for_selenium
    
    def application_port_for_selenium
      @application_port_for_selenium || self.application_port
    end

    # Which underlying app framework we're testing with selenium
    attr_accessor :application_framework

    # Which server the application is running on for selenium testing? Defaults to localhost
    attr_accessor :application_address

    # Which server Selenium server is running on. Defaults to nil(server starts in webrat process and runs locally)
    attr_accessor :selenium_server_address

    # Which server Selenium port is running on. Defaults to 4444
    attr_accessor :selenium_server_port

    # Set the key that Selenium uses to determine the browser running. Default *firefox
    attr_accessor :selenium_browser_key

    # Set the timeout for waiting for the browser process to start
    attr_accessor :selenium_browser_startup_timeout

    # Set the firefox profile for selenium to use
    attr_accessor :selenium_firefox_profile

    # How many redirects to the same URL should be halted as an infinite redirect
    # loop? Defaults to 10
    attr_accessor :infinite_redirect_limit

    # Print out the full HTML on wait failure
    # Defaults to false
    attr_accessor :selenium_verbose_output

    def initialize # :nodoc:
      self.open_error_files = true
      self.application_environment = :test
      self.application_port = 3001
      self.application_address = 'localhost'
      self.application_framework = :rails
      self.selenium_server_port = 4444
      self.infinite_redirect_limit = 10
      self.selenium_browser_key = '*firefox'
      self.selenium_browser_startup_timeout = 5
      self.selenium_verbose_output = false

      tmp_dir = Pathname.new(Dir.pwd).join("tmp")
      self.saved_pages_dir = tmp_dir.exist? ? tmp_dir : Dir.pwd
    end
    
    def open_error_files? #:nodoc:
      @open_error_files ? true : false
    end

    # Allows setting of webrat's mode, valid modes are:
    # :rails, :selenium, :rack, :sinatra, :mechanize, :merb
    def mode=(mode)
      @mode = mode.to_sym

      begin
        require("webrat/integrations/#{mode}")
      rescue LoadError
        # Only some modes have integration code that needs to
        # be loaded, so this is OK
      end
    end

  end

end
#
# setup.rb
#
# Copyright (c) 2000-2004 Minero Aoki
#
# This program is free software.
# You can distribute/modify this program under the terms of
# the GNU LGPL, Lesser General Public License version 2.1.
#

unless Enumerable.method_defined?(:map)   # Ruby 1.4.6
  module Enumerable
    alias map collect
  end
end

unless File.respond_to?(:read)   # Ruby 1.6
  def File.read(fname)
    open(fname) {|f|
      return f.read
    }
  end
end

def File.binread(fname)
  open(fname, 'rb') {|f|
    return f.read
  }
end

# for corrupted windows stat(2)
def File.dir?(path)
  File.directory?((path[-1,1] == '/') ? path : path + '/')
end


class SetupError < StandardError; end

def setup_rb_error(msg)
  raise SetupError, msg
end

#
# Config
#

if arg = ARGV.detect {|arg| /\A--rbconfig=/ =~ arg }
  ARGV.delete(arg)
  require arg.split(/=/, 2)[1]
  $".push 'rbconfig.rb'
else
  require 'rbconfig'
end

def multipackage_install?
  FileTest.directory?(File.dirname($0) + '/packages')
end


class ConfigItem
  def initialize(name, template, default, desc)
    @name = name.freeze
    @template = template
    @value = default
    @default = default.dup.freeze
    @description = desc
  end

  attr_reader :name
  attr_reader :description

  attr_accessor :default
  alias help_default default

  def help_opt
    "--#{@name}=#{@template}"
  end

  def value
    @value
  end

  def eval(table)
    @value.gsub(%r<\$([^/]+)>) { table[$1] }
  end

  def set(val)
    @value = check(val)
  end

  private

  def check(val)
    setup_rb_error "config: --#{name} requires argument" unless val
    val
  end
end

class BoolItem < ConfigItem
  def config_type
    'bool'
  end

  def help_opt
    "--#{@name}"
  end

  private

  def check(val)
    return 'yes' unless val
    unless /\A(y(es)?|n(o)?|t(rue)?|f(alse))\z/i =~ val
      setup_rb_error "config: --#{@name} accepts only yes/no for argument"
    end
    (/\Ay(es)?|\At(rue)/i =~ value) ? 'yes' : 'no'
  end
end

class PathItem < ConfigItem
  def config_type
    'path'
  end

  private

  def check(path)
    setup_rb_error "config: --#{@name} requires argument"  unless path
    path[0,1] == '$' ? path : File.expand_path(path)
  end
end

class ProgramItem < ConfigItem
  def config_type
    'program'
  end
end

class SelectItem < ConfigItem
  def initialize(name, template, default, desc)
    super
    @ok = template.split('/')
  end

  def config_type
    'select'
  end

  private

  def check(val)
    unless @ok.include?(val.strip)
      setup_rb_error "config: use --#{@name}=#{@template} (#{val})"
    end
    val.strip
  end
end

class PackageSelectionItem < ConfigItem
  def initialize(name, template, default, help_default, desc)
    super name, template, default, desc
    @help_default = help_default
  end

  attr_reader :help_default

  def config_type
    'package'
  end

  private

  def check(val)
    unless File.dir?("packages/#{val}")
      setup_rb_error "config: no such package: #{val}"
    end
    val
  end
end

class ConfigTable_class

  def initialize(items)
    @items = items
    @table = {}
    items.each do |i|
      @table[i.name] = i
    end
    ALIASES.each do |ali, name|
      @table[ali] = @table[name]
    end
  end

  include Enumerable

  def each(&block)
    @items.each(&block)
  end

  def key?(name)
    @table.key?(name)
  end

  def lookup(name)
    @table[name] or raise ArgumentError, "no such config item: #{name}"
  end

  def add(item)
    @items.push item
    @table[item.name] = item
  end

  def remove(name)
    item = lookup(name)
    @items.delete_if {|i| i.name == name }
    @table.delete_if {|name, i| i.name == name }
    item
  end

  def new
    dup()
  end

  def savefile
    '.config'
  end

  def load
    begin
      t = dup()
      File.foreach(savefile()) do |line|
        k, v = *line.split(/=/, 2)
        t[k] = v.strip
      end
      t
    rescue Errno::ENOENT
      setup_rb_error $!.message + "#{File.basename($0)} config first"
    end
  end

  def save
    @items.each {|i| i.value }
    File.open(savefile(), 'w') {|f|
      @items.each do |i|
        f.printf "%s=%s\n", i.name, i.value if i.value
      end
    }
  end

  def [](key)
    lookup(key).eval(self)
  end

  def []=(key, val)
    lookup(key).set val
  end

end

c = ::Config::CONFIG

rubypath = c['bindir'] + '/' + c['ruby_install_name']

major = c['MAJOR'].to_i
minor = c['MINOR'].to_i
teeny = c['TEENY'].to_i
version = "#{major}.#{minor}"

# ruby ver. >= 1.4.4?
newpath_p = ((major >= 2) or
             ((major == 1) and
              ((minor >= 5) or
               ((minor == 4) and (teeny >= 4)))))

if c['rubylibdir']
  # V < 1.6.3
  _stdruby         = c['rubylibdir']
  _siteruby        = c['sitedir']
  _siterubyver     = c['sitelibdir']
  _siterubyverarch = c['sitearchdir']
elsif newpath_p
  # 1.4.4 <= V <= 1.6.3
  _stdruby         = "$prefix/lib/ruby/#{version}"
  _siteruby        = c['sitedir']
  _siterubyver     = "$siteruby/#{version}"
  _siterubyverarch = "$siterubyver/#{c['arch']}"
else
  # V < 1.4.4
  _stdruby         = "$prefix/lib/ruby/#{version}"
  _siteruby        = "$prefix/lib/ruby/#{version}/site_ruby"
  _siterubyver     = _siteruby
  _siterubyverarch = "$siterubyver/#{c['arch']}"
end
libdir = '-* dummy libdir *-'
stdruby = '-* dummy rubylibdir *-'
siteruby = '-* dummy site_ruby *-'
siterubyver = '-* dummy site_ruby version *-'
parameterize = lambda {|path|
  path.sub(/\A#{Regexp.quote(c['prefix'])}/, '$prefix')\
      .sub(/\A#{Regexp.quote(libdir)}/,      '$libdir')\
      .sub(/\A#{Regexp.quote(stdruby)}/,     '$stdruby')\
      .sub(/\A#{Regexp.quote(siteruby)}/,    '$siteruby')\
      .sub(/\A#{Regexp.quote(siterubyver)}/, '$siterubyver')
}
libdir          = parameterize.call(c['libdir'])
stdruby         = parameterize.call(_stdruby)
siteruby        = parameterize.call(_siteruby)
siterubyver     = parameterize.call(_siterubyver)
siterubyverarch = parameterize.call(_siterubyverarch)

if arg = c['configure_args'].split.detect {|arg| /--with-make-prog=/ =~ arg }
  makeprog = arg.sub(/'/, '').split(/=/, 2)[1]
else
  makeprog = 'make'
end

common_conf = [
  PathItem.new('prefix', 'path', c['prefix'],
               'path prefix of target environment'),
  PathItem.new('bindir', 'path', parameterize.call(c['bindir']),
               'the directory for commands'),
  PathItem.new('libdir', 'path', libdir,
               'the directory for libraries'),
  PathItem.new('datadir', 'path', parameterize.call(c['datadir']),
               'the directory for shared data'),
  PathItem.new('mandir', 'path', parameterize.call(c['mandir']),
               'the directory for man pages'),
  PathItem.new('sysconfdir', 'path', parameterize.call(c['sysconfdir']),
               'the directory for man pages'),
  PathItem.new('stdruby', 'path', stdruby,
               'the directory for standard ruby libraries'),
  PathItem.new('siteruby', 'path', siteruby,
      'the directory for version-independent aux ruby libraries'),
  PathItem.new('siterubyver', 'path', siterubyver,
               'the directory for aux ruby libraries'),
  PathItem.new('siterubyverarch', 'path', siterubyverarch,
               'the directory for aux ruby binaries'),
  PathItem.new('rbdir', 'path', '$siterubyver',
               'the directory for ruby scripts'),
  PathItem.new('sodir', 'path', '$siterubyverarch',
               'the directory for ruby extentions'),
  PathItem.new('rubypath', 'path', rubypath,
               'the path to set to #! line'),
  ProgramItem.new('rubyprog', 'name', rubypath,
                  'the ruby program using for installation'),
  ProgramItem.new('makeprog', 'name', makeprog,
                  'the make program to compile ruby extentions'),
  SelectItem.new('shebang', 'all/ruby/never', 'ruby',
                 'shebang line (#!) editing mode'),
  BoolItem.new('without-ext', 'yes/no', 'no',
               'does not compile/install ruby extentions')
]
class ConfigTable_class   # open again
  ALIASES = {
    'std-ruby'         => 'stdruby',
    'site-ruby-common' => 'siteruby',     # For backward compatibility
    'site-ruby'        => 'siterubyver',  # For backward compatibility
    'bin-dir'          => 'bindir',
    'bin-dir'          => 'bindir',
    'rb-dir'           => 'rbdir',
    'so-dir'           => 'sodir',
    'data-dir'         => 'datadir',
    'ruby-path'        => 'rubypath',
    'ruby-prog'        => 'rubyprog',
    'ruby'             => 'rubyprog',
    'make-prog'        => 'makeprog',
    'make'             => 'makeprog'
  }
end
multipackage_conf = [
  PackageSelectionItem.new('with', 'name,name...', '', 'ALL',
                           'package names that you want to install'),
  PackageSelectionItem.new('without', 'name,name...', '', 'NONE',
                           'package names that you do not want to install')
]
if multipackage_install?
  ConfigTable = ConfigTable_class.new(common_conf + multipackage_conf)
else
  ConfigTable = ConfigTable_class.new(common_conf)
end


module MetaConfigAPI

  def eval_file_ifexist(fname)
    instance_eval File.read(fname), fname, 1 if File.file?(fname)
  end

  def config_names
    ConfigTable.map {|i| i.name }
  end

  def config?(name)
    ConfigTable.key?(name)
  end

  def bool_config?(name)
    ConfigTable.lookup(name).config_type == 'bool'
  end

  def path_config?(name)
    ConfigTable.lookup(name).config_type == 'path'
  end

  def value_config?(name)
    case ConfigTable.lookup(name).config_type
    when 'bool', 'path'
      true
    else
      false
    end
  end

  def add_config(item)
    ConfigTable.add item
  end

  def add_bool_config(name, default, desc)
    ConfigTable.add BoolItem.new(name, 'yes/no', default ? 'yes' : 'no', desc)
  end

  def add_path_config(name, default, desc)
    ConfigTable.add PathItem.new(name, 'path', default, desc)
  end

  def set_config_default(name, default)
    ConfigTable.lookup(name).default = default
  end

  def remove_config(name)
    ConfigTable.remove(name)
  end

end


#
# File Operations
#

module FileOperations

  def mkdir_p(dirname, prefix = nil)
    dirname = prefix + File.expand_path(dirname) if prefix
    $stderr.puts "mkdir -p #{dirname}" if verbose?
    return if no_harm?

    # does not check '/'... it's too abnormal case
    dirs = File.expand_path(dirname).split(%r<(?=/)>)
    if /\A[a-z]:\z/i =~ dirs[0]
      disk = dirs.shift
      dirs[0] = disk + dirs[0]
    end
    dirs.each_index do |idx|
      path = dirs[0..idx].join('')
      Dir.mkdir path unless File.dir?(path)
    end
  end

  def rm_f(fname)
    $stderr.puts "rm -f #{fname}" if verbose?
    return if no_harm?

    if File.exist?(fname) or File.symlink?(fname)
      File.chmod 0777, fname
      File.unlink fname
    end
  end

  def rm_rf(dn)
    $stderr.puts "rm -rf #{dn}" if verbose?
    return if no_harm?

    Dir.chdir dn
    Dir.foreach('.') do |fn|
      next if fn == '.'
      next if fn == '..'
      if File.dir?(fn)
        verbose_off {
          rm_rf fn
        }
      else
        verbose_off {
          rm_f fn
        }
      end
    end
    Dir.chdir '..'
    Dir.rmdir dn
  end

  def move_file(src, dest)
    File.unlink dest if File.exist?(dest)
    begin
      File.rename src, dest
    rescue
      File.open(dest, 'wb') {|f| f.write File.binread(src) }
      File.chmod File.stat(src).mode, dest
      File.unlink src
    end
  end

  def install(from, dest, mode, prefix = nil)
    $stderr.puts "install #{from} #{dest}" if verbose?
    return if no_harm?

    realdest = prefix ? prefix + File.expand_path(dest) : dest
    realdest = File.join(realdest, File.basename(from)) if File.dir?(realdest)
    str = File.binread(from)
    if diff?(str, realdest)
      verbose_off {
        rm_f realdest if File.exist?(realdest)
      }
      File.open(realdest, 'wb') {|f|
        f.write str
      }
      File.chmod mode, realdest

      File.open("#{objdir_root()}/InstalledFiles", 'a') {|f|
        if prefix
          f.puts realdest.sub(prefix, '')
        else
          f.puts realdest
        end
      }
    end
  end

  def diff?(new_content, path)
    return true unless File.exist?(path)
    new_content != File.binread(path)
  end

  def command(str)
    $stderr.puts str if verbose?
    system str or raise RuntimeError, "'system #{str}' failed"
  end

  def ruby(str)
    command config('rubyprog') + ' ' + str
  end
  
  def make(task = '')
    command config('makeprog') + ' ' + task
  end

  def extdir?(dir)
    File.exist?(dir + '/MANIFEST')
  end

  def all_files_in(dirname)
    Dir.open(dirname) {|d|
      return d.select {|ent| File.file?("#{dirname}/#{ent}") }
    }
  end

  REJECT_DIRS = %w(
    CVS SCCS RCS CVS.adm .svn
  )

  def all_dirs_in(dirname)
    Dir.open(dirname) {|d|
      return d.select {|n| File.dir?("#{dirname}/#{n}") } - %w(. ..) - REJECT_DIRS
    }
  end

end


#
# Main Installer
#

module HookUtils

  def run_hook(name)
    try_run_hook "#{curr_srcdir()}/#{name}" or
    try_run_hook "#{curr_srcdir()}/#{name}.rb"
  end

  def try_run_hook(fname)
    return false unless File.file?(fname)
    begin
      instance_eval File.read(fname), fname, 1
    rescue
      setup_rb_error "hook #{fname} failed:\n" + $!.message
    end
    true
  end

end


module HookScriptAPI

  def get_config(key)
    @config[key]
  end

  alias config get_config

  def set_config(key, val)
    @config[key] = val
  end

  #
  # srcdir/objdir (works only in the package directory)
  #

  #abstract srcdir_root
  #abstract objdir_root
  #abstract relpath

  def curr_srcdir
    "#{srcdir_root()}/#{relpath()}"
  end

  def curr_objdir
    "#{objdir_root()}/#{relpath()}"
  end

  def srcfile(path)
    "#{curr_srcdir()}/#{path}"
  end

  def srcexist?(path)
    File.exist?(srcfile(path))
  end

  def srcdirectory?(path)
    File.dir?(srcfile(path))
  end
  
  def srcfile?(path)
    File.file? srcfile(path)
  end

  def srcentries(path = '.')
    Dir.open("#{curr_srcdir()}/#{path}") {|d|
      return d.to_a - %w(. ..)
    }
  end

  def srcfiles(path = '.')
    srcentries(path).select {|fname|
      File.file?(File.join(curr_srcdir(), path, fname))
    }
  end

  def srcdirectories(path = '.')
    srcentries(path).select {|fname|
      File.dir?(File.join(curr_srcdir(), path, fname))
    }
  end

end


class ToplevelInstaller

  Version   = '3.3.1'
  Copyright = 'Copyright (c) 2000-2004 Minero Aoki'

  TASKS = [
    [ 'all',      'do config, setup, then install' ],
    [ 'config',   'saves your configurations' ],
    [ 'show',     'shows current configuration' ],
    [ 'setup',    'compiles ruby extentions and others' ],
    [ 'install',  'installs files' ],
    [ 'clean',    "does `make clean' for each extention" ],
    [ 'distclean',"does `make distclean' for each extention" ]
  ]

  def ToplevelInstaller.invoke
    instance().invoke
  end

  @singleton = nil

  def ToplevelInstaller.instance
    @singleton ||= new(File.dirname($0))
    @singleton
  end

  include MetaConfigAPI

  def initialize(ardir_root)
    @config = nil
    @options = { 'verbose' => true }
    @ardir = File.expand_path(ardir_root)
  end

  def inspect
    "#<#{self.class} #{__id__()}>"
  end

  def invoke
    run_metaconfigs
    case task = parsearg_global()
    when nil, 'all'
      @config = load_config('config')
      parsearg_config
      init_installers
      exec_config
      exec_setup
      exec_install
    else
      @config = load_config(task)
      __send__ "parsearg_#{task}"
      init_installers
      __send__ "exec_#{task}"
    end
  end
  
  def run_metaconfigs
    eval_file_ifexist "#{@ardir}/metaconfig"
  end

  def load_config(task)
    case task
    when 'config'
      ConfigTable.new
    when 'clean', 'distclean'
      if File.exist?(ConfigTable.savefile)
      then ConfigTable.load
      else ConfigTable.new
      end
    else
      ConfigTable.load
    end
  end

  def init_installers
    @installer = Installer.new(@config, @options, @ardir, File.expand_path('.'))
  end

  #
  # Hook Script API bases
  #

  def srcdir_root
    @ardir
  end

  def objdir_root
    '.'
  end

  def relpath
    '.'
  end

  #
  # Option Parsing
  #

  def parsearg_global
    valid_task = /\A(?:#{TASKS.map {|task,desc| task }.join '|'})\z/

    while arg = ARGV.shift
      case arg
      when /\A\w+\z/
        setup_rb_error "invalid task: #{arg}" unless valid_task =~ arg
        return arg

      when '-q', '--quiet'
        @options['verbose'] = false

      when       '--verbose'
        @options['verbose'] = true

      when '-h', '--help'
        print_usage $stdout
        exit 0

      when '-v', '--version'
        puts "#{File.basename($0)} version #{Version}"
        exit 0
      
      when '--copyright'
        puts Copyright
        exit 0

      else
        setup_rb_error "unknown global option '#{arg}'"
      end
    end

    nil
  end


  def parsearg_no_options
    unless ARGV.empty?
      setup_rb_error "#{task}:  unknown options: #{ARGV.join ' '}"
    end
  end

  alias parsearg_show       parsearg_no_options
  alias parsearg_setup      parsearg_no_options
  alias parsearg_clean      parsearg_no_options
  alias parsearg_distclean  parsearg_no_options

  def parsearg_config
    re = /\A--(#{ConfigTable.map {|i| i.name }.join('|')})(?:=(.*))?\z/
    @options['config-opt'] = []

    while i = ARGV.shift
      if /\A--?\z/ =~ i
        @options['config-opt'] = ARGV.dup
        break
      end
      m = re.match(i)  or setup_rb_error "config: unknown option #{i}"
      name, value = *m.to_a[1,2]
      @config[name] = value
    end
  end

  def parsearg_install
    @options['no-harm'] = false
    @options['install-prefix'] = ''
    while a = ARGV.shift
      case a
      when /\A--no-harm\z/
        @options['no-harm'] = true
      when /\A--prefix=(.*)\z/
        path = $1
        path = File.expand_path(path) unless path[0,1] == '/'
        @options['install-prefix'] = path
      else
        setup_rb_error "install: unknown option #{a}"
      end
    end
  end

  def print_usage(out)
    out.puts 'Typical Installation Procedure:'
    out.puts "  $ ruby #{File.basename $0} config"
    out.puts "  $ ruby #{File.basename $0} setup"
    out.puts "  # ruby #{File.basename $0} install (may require root privilege)"
    out.puts
    out.puts 'Detailed Usage:'
    out.puts "  ruby #{File.basename $0} <global option>"
    out.puts "  ruby #{File.basename $0} [<global options>] <task> [<task options>]"

    fmt = "  %-24s %s\n"
    out.puts
    out.puts 'Global options:'
    out.printf fmt, '-q,--quiet',   'suppress message outputs'
    out.printf fmt, '   --verbose', 'output messages verbosely'
    out.printf fmt, '-h,--help',    'print this message'
    out.printf fmt, '-v,--version', 'print version and quit'
    out.printf fmt, '   --copyright',  'print copyright and quit'
    out.puts
    out.puts 'Tasks:'
    TASKS.each do |name, desc|
      out.printf fmt, name, desc
    end

    fmt = "  %-24s %s [%s]\n"
    out.puts
    out.puts 'Options for CONFIG or ALL:'
    ConfigTable.each do |item|
      out.printf fmt, item.help_opt, item.description, item.help_default
    end
    out.printf fmt, '--rbconfig=path', 'rbconfig.rb to load',"running ruby's"
    out.puts
    out.puts 'Options for INSTALL:'
    out.printf fmt, '--no-harm', 'only display what to do if given', 'off'
    out.printf fmt, '--prefix=path',  'install path prefix', '$prefix'
    out.puts
  end

  #
  # Task Handlers
  #

  def exec_config
    @installer.exec_config
    @config.save   # must be final
  end

  def exec_setup
    @installer.exec_setup
  end

  def exec_install
    @installer.exec_install
  end

  def exec_show
    ConfigTable.each do |i|
      printf "%-20s %s\n", i.name, i.value
    end
  end

  def exec_clean
    @installer.exec_clean
  end

  def exec_distclean
    @installer.exec_distclean
  end

end


class ToplevelInstallerMulti < ToplevelInstaller

  include HookUtils
  include HookScriptAPI
  include FileOperations

  def initialize(ardir)
    super
    @packages = all_dirs_in("#{@ardir}/packages")
    raise 'no package exists' if @packages.empty?
  end

  def run_metaconfigs
    eval_file_ifexist "#{@ardir}/metaconfig"
    @packages.each do |name|
      eval_file_ifexist "#{@ardir}/packages/#{name}/metaconfig"
    end
  end

  def init_installers
    @installers = {}
    @packages.each do |pack|
      @installers[pack] = Installer.new(@config, @options,
                                       "#{@ardir}/packages/#{pack}",
                                       "packages/#{pack}")
    end

    with    = extract_selection(config('with'))
    without = extract_selection(config('without'))
    @selected = @installers.keys.select {|name|
                  (with.empty? or with.include?(name)) \
                      and not without.include?(name)
                }
  end

  def extract_selection(list)
    a = list.split(/,/)
    a.each do |name|
      setup_rb_error "no such package: #{name}"  unless @installers.key?(name)
    end
    a
  end

  def print_usage(f)
    super
    f.puts 'Inluded packages:'
    f.puts '  ' + @packages.sort.join(' ')
    f.puts
  end

  #
  # multi-package metaconfig API
  #

  attr_reader :packages

  def declare_packages(list)
    raise 'package list is empty' if list.empty?
    list.each do |name|
      raise "directory packages/#{name} does not exist"\
              unless File.dir?("#{@ardir}/packages/#{name}")
    end
    @packages = list
  end

  #
  # Task Handlers
  #

  def exec_config
    run_hook 'pre-config'
    each_selected_installers {|inst| inst.exec_config }
    run_hook 'post-config'
    @config.save   # must be final
  end

  def exec_setup
    run_hook 'pre-setup'
    each_selected_installers {|inst| inst.exec_setup }
    run_hook 'post-setup'
  end

  def exec_install
    run_hook 'pre-install'
    each_selected_installers {|inst| inst.exec_install }
    run_hook 'post-install'
  end

  def exec_clean
    rm_f ConfigTable.savefile
    run_hook 'pre-clean'
    each_selected_installers {|inst| inst.exec_clean }
    run_hook 'post-clean'
  end

  def exec_distclean
    rm_f ConfigTable.savefile
    run_hook 'pre-distclean'
    each_selected_installers {|inst| inst.exec_distclean }
    run_hook 'post-distclean'
  end

  #
  # lib
  #

  def each_selected_installers
    Dir.mkdir 'packages' unless File.dir?('packages')
    @selected.each do |pack|
      $stderr.puts "Processing the package `#{pack}' ..." if @options['verbose']
      Dir.mkdir "packages/#{pack}" unless File.dir?("packages/#{pack}")
      Dir.chdir "packages/#{pack}"
      yield @installers[pack]
      Dir.chdir '../..'
    end
  end

  def verbose?
    @options['verbose']
  end

  def no_harm?
    @options['no-harm']
  end

end


class Installer

  FILETYPES = %w( bin lib ext data )

  include HookScriptAPI
  include HookUtils
  include FileOperations

  def initialize(config, opt, srcroot, objroot)
    @config = config
    @options = opt
    @srcdir = File.expand_path(srcroot)
    @objdir = File.expand_path(objroot)
    @currdir = '.'
  end

  def inspect
    "#<#{self.class} #{File.basename(@srcdir)}>"
  end

  #
  # Hook Script API base methods
  #

  def srcdir_root
    @srcdir
  end

  def objdir_root
    @objdir
  end

  def relpath
    @currdir
  end

  #
  # configs/options
  #

  def no_harm?
    @options['no-harm']
  end

  def verbose?
    @options['verbose']
  end

  def verbose_off
    begin
      save, @options['verbose'] = @options['verbose'], false
      yield
    ensure
      @options['verbose'] = save
    end
  end

  #
  # TASK config
  #

  def exec_config
    exec_task_traverse 'config'
  end

  def config_dir_bin(rel)
  end

  def config_dir_lib(rel)
  end

  def config_dir_ext(rel)
    extconf if extdir?(curr_srcdir())
  end

  def extconf
    opt = @options['config-opt'].join(' ')
    command "#{config('rubyprog')} #{curr_srcdir()}/extconf.rb #{opt}"
  end

  def config_dir_data(rel)
  end

  #
  # TASK setup
  #

  def exec_setup
    exec_task_traverse 'setup'
  end

  def setup_dir_bin(rel)
    all_files_in(curr_srcdir()).each do |fname|
      adjust_shebang "#{curr_srcdir()}/#{fname}"
    end
  end

  def adjust_shebang(path)
    return if no_harm?
    tmpfile = File.basename(path) + '.tmp'
    begin
      File.open(path, 'rb') {|r|
        first = r.gets
        return unless File.basename(config('rubypath')) == 'ruby'
        return unless File.basename(first.sub(/\A\#!/, '').split[0]) == 'ruby'
        $stderr.puts "adjusting shebang: #{File.basename(path)}" if verbose?
        File.open(tmpfile, 'wb') {|w|
          w.print first.sub(/\A\#!\s*\S+/, '#! ' + config('rubypath'))
          w.write r.read
        }
        move_file tmpfile, File.basename(path)
      }
    ensure
      File.unlink tmpfile if File.exist?(tmpfile)
    end
  end

  def setup_dir_lib(rel)
  end

  def setup_dir_ext(rel)
    make if extdir?(curr_srcdir())
  end

  def setup_dir_data(rel)
  end

  #
  # TASK install
  #

  def exec_install
    rm_f 'InstalledFiles'
    exec_task_traverse 'install'
  end

  def install_dir_bin(rel)
    install_files collect_filenames_auto(), "#{config('bindir')}/#{rel}", 0755
  end

  def install_dir_lib(rel)
    install_files ruby_scripts(), "#{config('rbdir')}/#{rel}", 0644
  end

  def install_dir_ext(rel)
    return unless extdir?(curr_srcdir())
    install_files ruby_extentions('.'),
                  "#{config('sodir')}/#{File.dirname(rel)}",
                  0555
  end

  def install_dir_data(rel)
    install_files collect_filenames_auto(), "#{config('datadir')}/#{rel}", 0644
  end

  def install_files(list, dest, mode)
    mkdir_p dest, @options['install-prefix']
    list.each do |fname|
      install fname, dest, mode, @options['install-prefix']
    end
  end

  def ruby_scripts
    collect_filenames_auto().select {|n| /\.rb\z/ =~ n }
  end
  
  # picked up many entries from cvs-1.11.1/src/ignore.c
  reject_patterns = %w( 
    core RCSLOG tags TAGS .make.state
    .nse_depinfo #* .#* cvslog.* ,* .del-* *.olb
    *~ *.old *.bak *.BAK *.orig *.rej _$* *$

    *.org *.in .*
  )
  mapping = {
    '.' => '\.',
    '$' => '\$',
    '#' => '\#',
    '*' => '.*'
  }
  REJECT_PATTERNS = Regexp.new('\A(?:' +
                               reject_patterns.map {|pat|
                                 pat.gsub(/[\.\$\#\*]/) {|ch| mapping[ch] }
                               }.join('|') +
                               ')\z')

  def collect_filenames_auto
    mapdir((existfiles() - hookfiles()).reject {|fname|
             REJECT_PATTERNS =~ fname
           })
  end

  def existfiles
    all_files_in(curr_srcdir()) | all_files_in('.')
  end

  def hookfiles
    %w( pre-%s post-%s pre-%s.rb post-%s.rb ).map {|fmt|
      %w( config setup install clean ).map {|t| sprintf(fmt, t) }
    }.flatten
  end

  def mapdir(filelist)
    filelist.map {|fname|
      if File.exist?(fname)   # objdir
        fname
      else                    # srcdir
        File.join(curr_srcdir(), fname)
      end
    }
  end

  def ruby_extentions(dir)
    Dir.open(dir) {|d|
      ents = d.select {|fname| /\.#{::Config::CONFIG['DLEXT']}\z/ =~ fname }
      if ents.empty?
        setup_rb_error "no ruby extention exists: 'ruby #{$0} setup' first"
      end
      return ents
    }
  end

  #
  # TASK clean
  #

  def exec_clean
    exec_task_traverse 'clean'
    rm_f ConfigTable.savefile
    rm_f 'InstalledFiles'
  end

  def clean_dir_bin(rel)
  end

  def clean_dir_lib(rel)
  end

  def clean_dir_ext(rel)
    return unless extdir?(curr_srcdir())
    make 'clean' if File.file?('Makefile')
  end

  def clean_dir_data(rel)
  end

  #
  # TASK distclean
  #

  def exec_distclean
    exec_task_traverse 'distclean'
    rm_f ConfigTable.savefile
    rm_f 'InstalledFiles'
  end

  def distclean_dir_bin(rel)
  end

  def distclean_dir_lib(rel)
  end

  def distclean_dir_ext(rel)
    return unless extdir?(curr_srcdir())
    make 'distclean' if File.file?('Makefile')
  end

  #
  # lib
  #

  def exec_task_traverse(task)
    run_hook "pre-#{task}"
    FILETYPES.each do |type|
      if config('without-ext') == 'yes' and type == 'ext'
        $stderr.puts 'skipping ext/* by user option' if verbose?
        next
      end
      traverse task, type, "#{task}_dir_#{type}"
    end
    run_hook "post-#{task}"
  end

  def traverse(task, rel, mid)
    dive_into(rel) {
      run_hook "pre-#{task}"
      __send__ mid, rel.sub(%r[\A.*?(?:/|\z)], '')
      all_dirs_in(curr_srcdir()).each do |d|
        traverse task, "#{rel}/#{d}", mid
      end
      run_hook "post-#{task}"
    }
  end

  def dive_into(rel)
    return unless File.dir?("#{@srcdir}/#{rel}")

    dir = File.basename(rel)
    Dir.mkdir dir unless File.dir?(dir)
    prevdir = Dir.pwd
    Dir.chdir dir
    $stderr.puts '---> ' + rel if verbose?
    @currdir = rel
    yield
    Dir.chdir prevdir
    $stderr.puts '<--- ' + rel if verbose?
    @currdir = File.dirname(rel)
  end

end


if $0 == __FILE__
  begin
    if multipackage_install?
      ToplevelInstallerMulti.invoke
    else
      ToplevelInstaller.invoke
    end
  rescue SetupError
    raise if $DEBUG
    $stderr.puts $!.message
    $stderr.puts "Try 'ruby #{$0} --help' for detailed usage."
    exit 1
  end
end
# encoding: utf-8

Before do
  @calc = Calculator.new
end

After do
end

ÐÐ°Ð´Ð°ÑÐ¸ /ÑÐ½ÐµÑÐµÐ½ Ð±ÑÐ¾Ñ (\d+) Ñ ÐºÐ°Ð»ÐºÑÐ»Ð°ÑÐ¾Ñ/ do |n|
  @calc.push n.to_i
end

ÐÐ°Ð´Ð° /Ð¿ÑÐ¸ÑÐ¸ÑÐ½ÐµÐ¼ (\w+)/ do |op|
  @result = @calc.send op
end

ÐÐ½Ð´Ð° /Ð±Ð¸ ÑÑÐµÐ±Ð°Ð»Ð¾ Ð´Ð° Ð±ÑÐ´Ðµ (.*) Ð¿ÑÐ¸ÐºÐ°ÑÐ°Ð½Ð¾ Ð½Ð° ÐµÐºÑÐ°Ð½Ñ/ do |result|
  @result.should == result.to_f
end
require File.expand_path(File.dirname(__FILE__) + '/../../spec_helper')
require 'cucumber/wire_support/wire_language'

module Cucumber
  module WireSupport
    describe WireStepDefinition, "#invoke" do
      describe "if one of the arguments is a table" do
        it "should pass the raw table to the connection" do
          connection = mock('connection')
          step_definition = WireStepDefinition.new(connection, 'id' => 'the-id')
          expected_args = ["a","b", [["1","2"],["3","4"]]]
          connection.should_receive(:invoke).with('the-id', expected_args)
          args = ["a","b"]
          args << Cucumber::Ast::Table.new([["1","2"],["3","4"]])
          step_definition.invoke(args)
        end
      end
    end
  end
end# just for compatibility; requiring "sha1" is obsoleted
#
# $RoughId: sha1.rb,v 1.4 2001/07/13 15:38:27 knu Exp $
# $Id: sha1.rb 12007 2007-03-06 10:09:51Z knu $

require 'digest/sha1'

class SHA1 < Digest::SHA1
  class << self
    alias orig_new new
    def new(str = nil)
      if str
        orig_new.update(str)
      else
        orig_new
      end
    end

    def sha1(*args)
      new(*args)
    end
  end
end
module TZInfo
  module Definitions
    module America
      module Martinique
        include TimezoneDefinition
        
        timezone 'America/Martinique' do |tz|
          tz.offset :o0, -14660, 0, :LMT
          tz.offset :o1, -14660, 0, :FFMT
          tz.offset :o2, -14400, 0, :AST
          tz.offset :o3, -14400, 3600, :ADT
          
          tz.transition 1890, 1, :o1, 10417112653, 4320
          tz.transition 1911, 5, :o2, 10450761133, 4320
          tz.transition 1980, 4, :o3, 323841600
          tz.transition 1980, 9, :o2, 338958000
        end
      end
    end
  end
end
require 'spec_helper'

class SelfObserver
  def self.cache
    @cache ||= []
  end

  def initialize
    self.class.cache << self
  end
end

module RSpec::Core

  describe ExampleGroup do

    describe "top level group" do
      it "runs its children" do
        examples_run = []
        group = ExampleGroup.describe("parent") do
          describe("child") do
            it "does something" do
              examples_run << example
            end
          end
        end

        group.run
        examples_run.should have(1).example
      end

      context "with a failure in the top level group" do
        it "runs its children " do
          examples_run = []
          group = ExampleGroup.describe("parent") do
            it "fails" do
              examples_run << example
              raise "fail"
            end
            describe("child") do
              it "does something" do
                examples_run << example
              end
            end
          end

          group.run
          examples_run.should have(2).examples
        end
      end

      describe "descendants" do
        it "returns self + all descendants" do
          group = ExampleGroup.describe("parent") do
            describe("child") do
              describe("grandchild 1") {}
              describe("grandchild 2") {}
            end
          end
          group.descendants.size.should == 4
        end
      end
    end

    describe "child" do
      it "is known by parent" do
        parent = ExampleGroup.describe
        child = parent.describe
        parent.children.should == [child]
      end

      it "is not registered in world" do
        world = RSpec::Core::World.new
        parent = ExampleGroup.describe
        world.register(parent)
        child = parent.describe
        world.example_groups.should == [parent]
      end
    end

    describe "filtering" do
      let(:world) { World.new }

      it "includes all examples in an explicitly included group" do
        world.stub(:inclusion_filter).and_return({ :awesome => true })
        group = ExampleGroup.describe("does something", :awesome => true)
        group.stub(:world) { world }

        examples = [
          group.example("first"),
          group.example("second")
        ]
        group.filtered_examples.should == examples
      end

      it "includes explicitly included examples" do
        world.stub(:inclusion_filter).and_return({ :include_me => true })
        group = ExampleGroup.describe
        group.stub(:world) { world }
        example = group.example("does something", :include_me => true)
        group.example("don't run me")
        group.filtered_examples.should == [example]
      end

      it "excludes all examples in an excluded group" do
        world.stub(:exclusion_filter).and_return({ :include_me => false })
        group = ExampleGroup.describe("does something", :include_me => false)
        group.stub(:world) { world }

        examples = [
          group.example("first"),
          group.example("second")
        ]
        group.filtered_examples.should == []
      end

      it "filters out excluded examples" do
        world.stub(:exclusion_filter).and_return({ :exclude_me => true })
        group = ExampleGroup.describe("does something")
        group.stub(:world) { world }

        examples = [
          group.example("first", :exclude_me => true),
          group.example("second")
        ]
        group.filtered_examples.should == [examples[1]]
      end

      context "with no filters" do
        it "returns all" do
          group = ExampleGroup.describe
          group.stub(:world) { world }
          example = group.example("does something")
          group.filtered_examples.should == [example]
        end
      end

      context "with no examples or groups that match filters" do
        it "returns none" do
          world.stub(:inclusion_filter).and_return({ :awesome => false })
          group = ExampleGroup.describe
          group.stub(:world) { world }
          example = group.example("does something")
          group.filtered_examples.should == []
        end
      end
    end

    describe '#describes' do

      context "with a constant as the first parameter" do
        it "is that constant" do
          ExampleGroup.describe(Object) { }.describes.should == Object
        end
      end

      context "with a string as the first parameter" do
        it "is nil" do
          ExampleGroup.describe("i'm a computer") { }.describes.should be_nil
        end
      end

      context "with a constant in an outer group" do
        context "and a string in an inner group" do
          it "is the top level constant" do
            group = ExampleGroup.describe(String) do
              describe :symbol do
                example "describes is String" do
                  described_class.should eq(String)
                end
              end
            end

            group.run.should be_true
          end
        end
      end

      context "in a nested group" do
        it "inherits the described class/module from the outer group" do
          group = ExampleGroup.describe(String) do
            describe Array do
              example "desribes is String" do
                described_class.should eq(String)
              end
            end
          end

          group.run.should be_true, "expected examples in group to pass"
        end
      end


    end

    describe '#described_class' do
      it "is the same as describes" do
        self.class.described_class.should eq(self.class.describes)
      end
    end

    describe '#description' do

      it "grabs the description from the metadata" do
        group = ExampleGroup.describe(Object, "my desc") { }
        group.description.should == group.metadata[:example_group][:description]
      end

    end

    describe '#metadata' do

      it "adds the third parameter to the metadata" do
        ExampleGroup.describe(Object, nil, 'foo' => 'bar') { }.metadata.should include({ "foo" => 'bar' })
      end

      it "adds the the file_path to metadata" do
        ExampleGroup.describe(Object) { }.metadata[:example_group][:file_path].should == __FILE__
      end

      it "has a reader for file_path" do
        ExampleGroup.describe(Object) { }.file_path.should == __FILE__
      end

      it "adds the line_number to metadata" do
        ExampleGroup.describe(Object) { }.metadata[:example_group][:line_number].should == __LINE__
      end

    end

    [:focus, :focused].each do |example_alias|
      describe "##{example_alias}" do
        let(:group) { ExampleGroup.describe }
        subject { group.send example_alias, "a focused example" }

        it 'defines an example that can be filtered with :focused => true' do
          subject.metadata.should include(:focused => true)
        end

        it 'defines an example that can be filtered with :focus => true' do
          subject.metadata.should include(:focus => true)
        end
      end
    end

    describe "#before, after, and around hooks" do

      it "runs the before alls in order" do
        group = ExampleGroup.describe
        order = []
        group.before(:all) { order << 1 }
        group.before(:all) { order << 2 }
        group.before(:all) { order << 3 }
        group.example("example") {}

        group.run

        order.should == [1,2,3]
      end

      it "runs the before eachs in order" do
        group = ExampleGroup.describe
        order = []
        group.before(:each) { order << 1 }
        group.before(:each) { order << 2 }
        group.before(:each) { order << 3 }
        group.example("example") {}

        group.run

        order.should == [1,2,3]
      end

      it "runs the after eachs in reverse order" do
        group = ExampleGroup.describe
        order = []
        group.after(:each) { order << 1 }
        group.after(:each) { order << 2 }
        group.after(:each) { order << 3 }
        group.example("example") {}

        group.run

        order.should == [3,2,1]
      end

      it "runs the after alls in reverse order" do
        group = ExampleGroup.describe
        order = []
        group.after(:all) { order << 1 }
        group.after(:all) { order << 2 }
        group.after(:all) { order << 3 }
        group.example("example") {}

        group.run

        order.should == [3,2,1]
      end

      it "only runs before/after(:all) hooks from example groups that have specs that run" do
        hooks_run = []

        RSpec.configure do |c|
          c.filter_run :focus => true
        end

        unfiltered_group = ExampleGroup.describe "unfiltered" do
          before(:all) { hooks_run << :unfiltered_before_all }
          after(:all)  { hooks_run << :unfiltered_after_all  }

          context "a subcontext" do
            it("has an example") { }
          end
        end

        filtered_group = ExampleGroup.describe "filtered", :focus => true do
          before(:all) { hooks_run << :filtered_before_all }
          after(:all)  { hooks_run << :filtered_after_all  }

          context "a subcontext" do
            it("has an example") { }
          end
        end

        unfiltered_group.run
        filtered_group.run

        hooks_run.should == [:filtered_before_all, :filtered_after_all]
      end

      it "runs before_all_defined_in_config, before all, before each, example, after each, after all, after_all_defined_in_config in that order" do
        order = []

        RSpec.configure do |c|
          c.before(:all) { order << :before_all_defined_in_config }
          c.after(:all) { order << :after_all_defined_in_config }
        end

        group = ExampleGroup.describe
        group.before(:all)  { order << :top_level_before_all  }
        group.before(:each) { order << :before_each }
        group.after(:each)  { order << :after_each  }
        group.after(:all)   { order << :top_level_after_all   }
        group.example("top level example") { order << :top_level_example }

        context1 = group.describe("context 1")
        context1.before(:all) { order << :nested_before_all }
        context1.example("nested example 1") { order << :nested_example_1 }

        context2 = group.describe("context 2")
        context2.after(:all) { order << :nested_after_all }
        context2.example("nested example 2") { order << :nested_example_2 }

        group.run

        order.should == [
          :before_all_defined_in_config,
          :top_level_before_all,
          :before_each,
          :top_level_example,
          :after_each,
          :nested_before_all,
          :before_each,
          :nested_example_1,
          :after_each,
          :before_each,
          :nested_example_2,
          :after_each,
          :nested_after_all,
          :top_level_after_all,
          :after_all_defined_in_config
        ]
      end

      it "accesses before(:all) state in after(:all)" do
        group = ExampleGroup.describe
        group.before(:all) { @ivar = "value" }
        group.after(:all)  { @ivar.should eq("value") }
        group.example("ignore") {  }

        expect do
          group.run
        end.to_not raise_error
      end

      it "treats an error in before(:each) as a failure" do
        group = ExampleGroup.describe
        group.before(:each) { raise "error in before each" }
        example = group.example("equality") { 1.should == 2}
        group.run

        example.metadata[:execution_result][:exception].message.should == "error in before each"
      end

      it "treats an error in before(:all) as a failure" do
        group = ExampleGroup.describe
        group.before(:all) { raise "error in before all" }
        example = group.example("equality") { 1.should == 2}
        group.run

        example.metadata.should_not be_nil
        example.metadata[:execution_result].should_not be_nil
        example.metadata[:execution_result][:exception].should_not be_nil
        example.metadata[:execution_result][:exception].message.should == "error in before all"
      end

      it "treats an error in before(:all) as a failure for a spec in a nested group" do
        example = nil
        group = ExampleGroup.describe do
          before(:all) { raise "error in before all" }

          describe "nested" do
            example = it("equality") { 1.should == 2}
          end
        end
        group.run

        example.metadata.should_not be_nil
        example.metadata[:execution_result].should_not be_nil
        example.metadata[:execution_result][:exception].should_not be_nil
        example.metadata[:execution_result][:exception].message.should == "error in before all"
      end

      context "when an error occurs in an after(:all) hook" do
        before(:each) do
          RSpec.configuration.reporter.stub(:message)
        end

        let(:group) do
          ExampleGroup.describe do
            after(:all) { raise "error in after all" }
            it("equality") { 1.should == 1 }
          end
        end

        it "allows the example to pass" do
          group.run
          example = group.examples.first
          example.metadata.should_not be_nil
          example.metadata[:execution_result].should_not be_nil
          example.metadata[:execution_result][:status].should == "passed"
        end

        it "rescues the error and prints it out" do
          RSpec.configuration.reporter.should_receive(:message).with(/error in after all/)
          group.run
        end
      end

      it "has no 'running example' within before(:all)" do
        group = ExampleGroup.describe
        running_example = :none
        group.before(:all) { running_example = example }
        group.example("no-op") { }
        group.run
        running_example.should == nil
      end

      it "has access to example options within before(:each)" do
        group = ExampleGroup.describe
        option = nil
        group.before(:each) { option = example.options[:data] }
        group.example("no-op", :data => :sample) { }
        group.run
        option.should == :sample
      end

      it "has access to example options within after(:each)" do
        group = ExampleGroup.describe
        option = nil
        group.after(:each) { option = example.options[:data] }
        group.example("no-op", :data => :sample) { }
        group.run
        option.should == :sample
      end

      it "has no 'running example' within after(:all)" do
        group = ExampleGroup.describe
        running_example = :none
        group.after(:all) { running_example = example }
        group.example("no-op") { }
        group.run
        running_example.should == nil
      end
    end

    describe "adding examples" do

      it "allows adding an example using 'it'" do
        group = ExampleGroup.describe
        group.it("should do something") { }
        group.examples.size.should == 1
      end

      it "allows adding a pending example using 'xit'" do
        group = ExampleGroup.describe
        group.xit("is pending") { }
        group.run
        group.examples.first.should be_pending
      end

      it "exposes all examples at examples" do
        group = ExampleGroup.describe
        group.it("should do something 1") { }
        group.it("should do something 2") { }
        group.it("should do something 3") { }
        group.should have(3).examples
      end

      it "maintains the example order" do
        group = ExampleGroup.describe
        group.it("should 1") { }
        group.it("should 2") { }
        group.it("should 3") { }
        group.examples[0].description.should == 'should 1'
        group.examples[1].description.should == 'should 2'
        group.examples[2].description.should == 'should 3'
      end

    end

    describe Object, "describing nested example_groups", :little_less_nested => 'yep' do

      describe "A sample nested group", :nested_describe => "yep" do
        it "sets the described class to the described class of the outer most group" do
          example.example_group.describes.should eq(ExampleGroup)
        end

        it "sets the description to 'A sample nested describe'" do
          example.example_group.description.should == 'A sample nested group'
        end

        it "has top level metadata from the example_group and its ancestors" do
          example.example_group.metadata.should include(:little_less_nested => 'yep', :nested_describe => 'yep')
        end

        it "exposes the parent metadata to the contained examples" do
          example.metadata.should include(:little_less_nested => 'yep', :nested_describe => 'yep')
        end
      end

    end

    describe "#run_examples" do

      let(:reporter) { double("reporter").as_null_object }

      it "returns true if all examples pass" do
        group = ExampleGroup.describe('group') do
          example('ex 1') { 1.should == 1 }
          example('ex 2') { 1.should == 1 }
        end
        group.stub(:filtered_examples) { group.examples }
        group.run(reporter).should be_true
      end

      it "returns false if any of the examples fail" do
        group = ExampleGroup.describe('group') do
          example('ex 1') { 1.should == 1 }
          example('ex 2') { 1.should == 2 }
        end
        group.stub(:filtered_examples) { group.examples }
        group.run(reporter).should be_false
      end

      it "runs all examples, regardless of any of them failing" do
        group = ExampleGroup.describe('group') do
          example('ex 1') { 1.should == 2 }
          example('ex 2') { 1.should == 1 }
        end
        group.stub(:filtered_examples) { group.examples }
        group.filtered_examples.each do |example|
          example.should_receive(:run)
        end
        group.run(reporter).should be_false
      end
    end

    describe "how instance variables are inherited" do
      before(:all) do
        @before_all_top_level = 'before_all_top_level'
      end

      before(:each) do
        @before_each_top_level = 'before_each_top_level'
      end

      it "can access a before each ivar at the same level" do
        @before_each_top_level.should == 'before_each_top_level'
      end

      it "can access a before all ivar at the same level" do
        @before_all_top_level.should == 'before_all_top_level'
      end

      it "can access the before all ivars in the before_all_ivars hash", :ruby => 1.8 do
        example.example_group.before_all_ivars.should include('@before_all_top_level' => 'before_all_top_level')
      end

      it "can access the before all ivars in the before_all_ivars hash", :ruby => 1.9 do
        example.example_group.before_all_ivars.should include(:@before_all_top_level => 'before_all_top_level')
      end

      describe "but now I am nested" do
        it "can access a parent example groups before each ivar at a nested level" do
          @before_each_top_level.should == 'before_each_top_level'
        end

        it "can access a parent example groups before all ivar at a nested level" do
          @before_all_top_level.should == "before_all_top_level"
        end

        it "changes to before all ivars from within an example do not persist outside the current describe" do
          @before_all_top_level = "ive been changed"
        end

        describe "accessing a before_all ivar that was changed in a parent example_group" do
          it "does not have access to the modified version" do
            @before_all_top_level.should == 'before_all_top_level'
          end
        end
      end

    end

    describe "ivars are not shared across examples" do
      it "(first example)" do
        @a = 1
        @b.should be_nil
      end

      it "(second example)" do
        @b = 2
        @a.should be_nil
      end
    end


    describe "#top_level_description" do
      it "returns the description from the outermost example group" do
        group = nil
        ExampleGroup.describe("top") do
          context "middle" do
            group = describe "bottom" do
            end
          end
        end

        group.top_level_description.should == "top"
      end
    end

    describe "#run" do
      let(:reporter) { double("reporter").as_null_object }

      context "with fail_fast? => true" do
        it "does not run examples after the failed example" do
          group = RSpec::Core::ExampleGroup.describe
          group.stub(:fail_fast?) { true }
          examples_run = []
          group.example('example 1') { examples_run << self }
          group.example('example 2') { examples_run << self; fail; }
          group.example('example 3') { examples_run << self }

          group.run

          examples_run.length.should eq(2)
        end
      end

      context "with RSpec.wants_to_quit=true" do
        let(:group) { RSpec::Core::ExampleGroup.describe }

        before do
          RSpec.stub(:wants_to_quit) { true }
          RSpec.stub(:clear_remaining_example_groups)
        end

        it "returns without starting the group" do
          reporter.should_not_receive(:example_group_started)
          group.run(reporter)
        end

        context "at top level" do
          it "purges remaining groups" do
            RSpec.should_receive(:clear_remaining_example_groups)
            group.run(reporter)
          end
        end

        context "in a nested group" do
          it "does not purge remaining groups" do
            nested_group = group.describe
            RSpec.should_not_receive(:clear_remaining_example_groups)
            nested_group.run(reporter)
          end
        end
      end

      context "with all examples passing" do
        it "returns true" do
          group = describe("something") do
            it "does something" do
              # pass
            end
            describe ("nested") do
              it "does something else" do
                # pass
              end
            end
          end

          group.run(reporter).should be_true
        end
      end

      context "with top level example failing" do
        it "returns false" do
          group = describe("something") do
            it "does something (wrong - fail)" do
              raise "fail"
            end
            describe ("nested") do
              it "does something else" do
                # pass
              end
            end
          end

          group.run(reporter).should be_false
        end
      end

      context "with nested example failing" do
        it "returns true" do
          group = describe("something") do
            it "does something" do
              # pass
            end
            describe ("nested") do
              it "does something else (wrong -fail)" do
                raise "fail"
              end
            end
          end

          group.run(reporter).should be_false
        end
      end
    end

  end
end
require 'optparse'

module Spec #:nodoc:
  module Runner #:nodoc:
    # Neuters RSpec's option parser.
    # (RSpec's option parser tries to parse ARGV, which
    # will fail when running cucumber)
    class OptionParser < ::OptionParser #:nodoc:
      NEUTERED_RSPEC = Object.new
      def NEUTERED_RSPEC.method_missing(m, *args); self; end
      
      def self.method_added(m)
        unless @__neutering_rspec
          @__neutering_rspec = true
          define_method(m) do |*a|
            NEUTERED_RSPEC
          end
          @__neutering_rspec = false
        end
      end
    end
  end
end
require 'rexml/document'
require File.expand_path('../../../../spec_helper', __FILE__)

describe :rexml_elements_to_a, :shared => true do
  before :each do
    @e = REXML::Element.new "root"
    @first = REXML::Element.new("FirstChild")
    @second = REXML::Element.new("SecondChild")
    @e << @first
    @e << @second
  end

  it "returns elements that match xpath" do
    @e.elements.send(@method, "FirstChild").first.should == @first
  end

  # According to the docs REXML::Element#get_elements is an alias for
  # REXML::Elements.to_a. Implementation wise there's a difference, get_elements
  # always needs the first param (even if it's nil).
  # A patch was submitted:
  # http://rubyforge.org/tracker/index.php?func=detail&aid=19354&group_id=426&atid=1698
  ruby_bug "#", "1.8.6.114" do
    it "returns all childs if xpath is nil" do
      @e.elements.send(@method).should == [@first, @second]
    end
  end

end

describe "REXML::REXML::Elements#to_a" do
  it_behaves_like :rexml_elements_to_a, :to_a
end

describe "REXML::REXML::Element#get_elements" do
  it_behaves_like :rexml_elements_to_a, :get_elements
end
