require File.expand_path(File.dirname(__FILE__) + '/../spec_helper')

describe Thor::Shell::Basic do
  def shell
    @shell ||= Thor::Shell::Basic.new
  end

  describe "#padding" do
    it "cannot be set to below zero" do
      shell.padding = 10
      shell.padding.should == 10

      shell.padding = -1
      shell.padding.should == 0
    end
  end

  describe "#ask" do
    it "prints a message to the user and gets the response" do
      $stdout.should_receive(:print).with("Should I overwrite it? ")
      $stdin.should_receive(:gets).and_return('Sure')
      shell.ask("Should I overwrite it?").should == "Sure"
    end
  end

  describe "#yes?" do
    it "asks the user and returns true if the user replies yes" do
      $stdout.should_receive(:print).with("Should I overwrite it? ")
        $stdin.should_receive(:gets).and_return('y')
      shell.yes?("Should I overwrite it?").should === true

      $stdout.should_receive(:print).with("Should I overwrite it? ")
        $stdin.should_receive(:gets).and_return('n')
      shell.yes?("Should I overwrite it?").should_not === true
    end
  end

  describe "#no?" do
    it "asks the user and returns true if the user replies no" do
      $stdout.should_receive(:print).with("Should I overwrite it? ")
        $stdin.should_receive(:gets).and_return('n')
      shell.no?("Should I overwrite it?").should === true

      $stdout.should_receive(:print).with("Should I overwrite it? ")
        $stdin.should_receive(:gets).and_return('Yes')
      shell.no?("Should I overwrite it?").should === false
    end
  end

  describe "#say" do
    it "prints a message to the user" do
      $stdout.should_receive(:puts).with("Running...")
      shell.say("Running...")
    end

    it "prints a message to the user without new line if it ends with a whitespace" do
      $stdout.should_receive(:print).with("Running... ")
      shell.say("Running... ")
    end

    it "prints a message to the user without new line" do
      $stdout.should_receive(:print).with("Running...")
      shell.say("Running...", nil, false)
    end
  end

  describe "#say_status" do
    it "prints a message to the user with status" do
      $stdout.should_receive(:puts).with("      create  ~/.thor/task.thor")
      shell.say_status(:create, "~/.thor/task.thor")
    end

    it "always use new line" do
      $stdout.should_receive(:puts).with("      create  ")
      shell.say_status(:create, "")
    end

    it "does not print a message if base is muted" do
      shell.should_receive(:mute?).and_return(true)
      $stdout.should_not_receive(:puts)

      shell.mute do
        shell.say_status(:created, "~/.thor/task.thor")
      end
    end

    it "does not print a message if base is set to quiet" do
      base = MyCounter.new [1,2]
      base.should_receive(:options).and_return(:quiet => true)

      $stdout.should_not_receive(:puts)
      shell.base = base
      shell.say_status(:created, "~/.thor/task.thor")
    end

    it "does not print a message if log status is set to false" do
      $stdout.should_not_receive(:puts)
      shell.say_status(:created, "~/.thor/task.thor", false)
    end

    it "uses padding to set messages left margin" do
      shell.padding = 2
      $stdout.should_receive(:puts).with("      create      ~/.thor/task.thor")
      shell.say_status(:create, "~/.thor/task.thor")
    end
  end

  describe "#print_table" do
    before(:each) do
      @table = []
      @table << ["abc", "#123", "first three"]
      @table << ["", "#0", "empty"]
      @table << ["xyz", "#786", "last three"]
    end

    it "prints a table" do
      content = capture(:stdout){ shell.print_table(@table) }
      content.should == <<-TABLE
abc  #123  first three
     #0    empty
xyz  #786  last three
TABLE
    end

    it "prints a table with identation" do
      content = capture(:stdout){ shell.print_table(@table, :ident => 2) }
      content.should == <<-TABLE
  abc  #123  first three
       #0    empty
  xyz  #786  last three
TABLE
    end

    it "uses maximum terminal width" do
      shell.should_receive(:terminal_width).and_return(20)
      content = capture(:stdout){ shell.print_table(@table, :ident => 2, :truncate => true) }
      content.should == <<-TABLE
  abc  #123  firs...
       #0    empty
  xyz  #786  last...
TABLE
    end

    it "honors the colwidth option" do
      content = capture(:stdout){ shell.print_table(@table, :colwidth => 10)}
      content.should == <<-TABLE
abc         #123  first three
            #0    empty
xyz         #786  last three
TABLE
    end
  end

  describe "#file_collision" do
    it "shows a menu with options" do
      $stdout.should_receive(:print).with('Overwrite foo? (enter "h" for help) [Ynaqh] ')
      $stdin.should_receive(:gets).and_return('n')
      shell.file_collision('foo')
    end

    it "returns true if the user choose default option" do
      $stdout.stub!(:print)
      $stdin.should_receive(:gets).and_return('')
      shell.file_collision('foo').should be_true
    end

    it "returns false if the user choose no" do
      $stdout.stub!(:print)
      $stdin.should_receive(:gets).and_return('n')
      shell.file_collision('foo').should be_false
    end

    it "returns true if the user choose yes" do
      $stdout.stub!(:print)
      $stdin.should_receive(:gets).and_return('y')
      shell.file_collision('foo').should be_true
    end

    it "shows help usage if the user choose help" do
      $stdout.stub!(:print)
      $stdin.should_receive(:gets).and_return('h')
      $stdin.should_receive(:gets).and_return('n')
      help = capture(:stdout){ shell.file_collision('foo') }
      help.should =~ /h \- help, show this help/
    end

    it "quits if the user choose quit" do
      $stdout.stub!(:print)
      $stdout.should_receive(:puts).with('Aborting...')
      $stdin.should_receive(:gets).and_return('q')

      lambda {
        shell.file_collision('foo')
      }.should raise_error(SystemExit)
    end

    it "always returns true if the user choose always" do
      $stdout.should_receive(:print).with('Overwrite foo? (enter "h" for help) [Ynaqh] ')
      $stdin.should_receive(:gets).and_return('a')

      shell.file_collision('foo').should be_true

      $stdout.should_not_receive(:print)
      shell.file_collision('foo').should be_true
    end

    describe "when a block is given" do
      it "displays diff options to the user" do
        $stdout.should_receive(:print).with('Overwrite foo? (enter "h" for help) [Ynaqdh] ')
        $stdin.should_receive(:gets).and_return('s')
        shell.file_collision('foo'){ }
      end

      it "invokes the diff command" do
        $stdout.stub!(:print)
        $stdin.should_receive(:gets).and_return('d')
        $stdin.should_receive(:gets).and_return('n')
        shell.should_receive(:system).with(/diff -u/)
        capture(:stdout){ shell.file_collision('foo'){ } }
      end
    end
  end
end
ruby_version_is "1.9" do
  require File.expand_path('../../../shared/rational/inspect', __FILE__)

  describe "Rational#inspect" do
    it_behaves_like(:rational_inspect, :inspect)
  end
end
require File.expand_path('../../../../spec_helper', __FILE__)

with_feature :encoding do
  describe "Encoding::Converter.asciicompat_encoding" do
    it "accepts an encoding name as a String argument" do
      lambda { Encoding::Converter.asciicompat_encoding('UTF-8') }.
        should_not raise_error
    end

    it "coerces non-String/Encoding objects with #to_str" do
      str = mock('string')
      str.should_receive(:to_str).twice.and_return('string')
      Encoding::Converter.asciicompat_encoding(str)
    end

    it "accepts an Encoding object as an argument" do
      Encoding::Converter.
        asciicompat_encoding(Encoding.find("ISO-2022-JP")).
        should == Encoding::Converter.asciicompat_encoding("ISO-2022-JP")
    end

    it "returns a corresponding ASCII compatible encoding for ASCII-incompatible encodings" do
      Encoding::Converter.asciicompat_encoding('UTF-16BE').should == Encoding::UTF_8
      Encoding::Converter.asciicompat_encoding("ISO-2022-JP").should == Encoding.find("stateless-ISO-2022-JP")
    end

    it "returns nil when the given encoding is ASCII compatible" do
      Encoding::Converter.asciicompat_encoding('ASCII').should be_nil
      Encoding::Converter.asciicompat_encoding('UTF-8').should be_nil
    end

    it "handles encoding names who resolve to nil encodings" do
      internal = Encoding.default_internal
      Encoding.default_internal = nil
      Encoding::Converter.asciicompat_encoding('internal').should be_nil
      Encoding.default_internal = internal
    end

    it "returns nil if called with an encoding it returned previously" do
      internal = Encoding.default_internal
      Encoding.name_list.each do |name|
        asciicompat = Encoding::Converter.asciicompat_encoding(name)
        next if asciicompat.nil?
        Encoding::Converter.asciicompat_encoding(asciicompat).should be_nil
      end
    end
  end
end
require 'mspec/runner/filters/match'
require 'mspec/runner/filters/regexp'
require 'mspec/runner/filters/tag'
require 'mspec/runner/filters/profile'
# = uri/common.rb
#
# Author:: Akira Yamada <akira@ruby-lang.org>
# Revision:: $Id: common.rb 30306 2010-12-23 10:49:00Z yugui $
# License::
#   You can redistribute it and/or modify it under the same term as Ruby.
#

module URI
  module REGEXP
    #
    # Patterns used to parse URI's
    #
    module PATTERN
      # :stopdoc:

      # RFC 2396 (URI Generic Syntax)
      # RFC 2732 (IPv6 Literal Addresses in URL's)
      # RFC 2373 (IPv6 Addressing Architecture)

      # alpha         = lowalpha | upalpha
      ALPHA = "a-zA-Z"
      # alphanum      = alpha | digit
      ALNUM = "#{ALPHA}\\d"

      # hex           = digit | "A" | "B" | "C" | "D" | "E" | "F" |
      #                         "a" | "b" | "c" | "d" | "e" | "f"
      HEX     = "a-fA-F\\d"
      # escaped       = "%" hex hex
      ESCAPED = "%[#{HEX}]{2}"
      # mark          = "-" | "_" | "." | "!" | "~" | "*" | "'" |
      #                 "(" | ")"
      # unreserved    = alphanum | mark
      UNRESERVED = "-_.!~*'()#{ALNUM}"
      # reserved      = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
      #                 "$" | ","
      # reserved      = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
      #                 "$" | "," | "[" | "]" (RFC 2732)
      RESERVED = ";/?:@&=+$,\\[\\]"

      # domainlabel   = alphanum | alphanum *( alphanum | "-" ) alphanum
      DOMLABEL = "(?:[#{ALNUM}](?:[-#{ALNUM}]*[#{ALNUM}])?)"
      # toplabel      = alpha | alpha *( alphanum | "-" ) alphanum
      TOPLABEL = "(?:[#{ALPHA}](?:[-#{ALNUM}]*[#{ALNUM}])?)"
      # hostname      = *( domainlabel "." ) toplabel [ "." ]
      HOSTNAME = "(?:#{DOMLABEL}\\.)*#{TOPLABEL}\\.?"

      # :startdoc:
    end # PATTERN

    # :startdoc:
  end # REGEXP

  class Parser
    include REGEXP

    #
    # == Synopsis
    #
    #   URI::Parser.new([opts])
    #
    # == Args
    #
    # The constructor accepts a hash as options for parser.
    # Keys of options are pattern names of URI components
    # and values of options are pattern strings.
    # The constructor generetes set of regexps for parsing URIs.
    #
    # You can use the following keys:
    #
    #   * <tt>:ESCAPED</tt> (URI::PATTERN::ESCAPED in default)
    #   * <tt>:UNRESERVED</tt> (URI::PATTERN::UNRESERVED in default)
    #   * <tt>:DOMLABEL</tt> (URI::PATTERN::DOMLABEL in default)
    #   * <tt>:TOPLABEL</tt> (URI::PATTERN::TOPLABEL in default)
    #   * <tt>:HOSTNAME</tt> (URI::PATTERN::HOSTNAME in default)
    #
    # == Examples
    #
    #   p = URI::Parser.new(:ESCPAED => "(?:%[a-fA-F0-9]{2}|%u[a-fA-F0-9]{4})"
    #   u = p.parse("http://example.jp/%uABCD") #=> #<URI::HTTP:0xb78cf4f8 URL:http://example.jp/%uABCD>
    #   URI.parse(u.to_s) #=> raises URI::InvalidURIError
    #
    #   s = "http://examle.com/ABCD"
    #   u1 = p.parse(s) #=> #<URI::HTTP:0xb78c3220 URL:http://example.com/ABCD>
    #   u2 = URI.parse(s) #=> #<URI::HTTP:0xb78b6d54 URL:http://example.com/ABCD>
    #   u1 == u2 #=> true
    #   u1.eql?(u2) #=> false
    #
    def initialize(opts = {})
      @pattern = initialize_pattern(opts)
      @pattern.each_value {|v| v.freeze}
      @pattern.freeze

      @regexp = initialize_regexp(@pattern)
      @regexp.each_value {|v| v.freeze}
      @regexp.freeze
    end
    attr_reader :pattern, :regexp

    def split(uri)
      case uri
      when ''
	# null uri

      when @regexp[:ABS_URI]
	scheme, opaque, userinfo, host, port,
	  registry, path, query, fragment = $~[1..-1]

	# URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]

	# absoluteURI   = scheme ":" ( hier_part | opaque_part )
	# hier_part     = ( net_path | abs_path ) [ "?" query ]
	# opaque_part   = uric_no_slash *uric

	# abs_path      = "/"  path_segments
	# net_path      = "//" authority [ abs_path ]

	# authority     = server | reg_name
	# server        = [ [ userinfo "@" ] hostport ]

	if !scheme
	  raise InvalidURIError,
	    "bad URI(absolute but no scheme): #{uri}"
	end
	if !opaque && (!path && (!host && !registry))
	  raise InvalidURIError,
	    "bad URI(absolute but no path): #{uri}"
	end

      when @regexp[:REL_URI]
	scheme = nil
	opaque = nil

	userinfo, host, port, registry,
	  rel_segment, abs_path, query, fragment = $~[1..-1]
	if rel_segment && abs_path
	  path = rel_segment + abs_path
	elsif rel_segment
	  path = rel_segment
	elsif abs_path
	  path = abs_path
	end

	# URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]

	# relativeURI   = ( net_path | abs_path | rel_path ) [ "?" query ]

	# net_path      = "//" authority [ abs_path ]
	# abs_path      = "/"  path_segments
	# rel_path      = rel_segment [ abs_path ]

	# authority     = server | reg_name
	# server        = [ [ userinfo "@" ] hostport ]

      else
	raise InvalidURIError, "bad URI(is not URI?): #{uri}"
      end

      path = '' if !path && !opaque # (see RFC2396 Section 5.2)
      ret = [
	scheme,
	userinfo, host, port,         # X
	registry,                     # X
	path,                         # Y
	opaque,                       # Y
	query,
	fragment
      ]
      return ret
    end

    def parse(uri)
      scheme, userinfo, host, port,
       	registry, path, opaque, query, fragment = self.split(uri)

      if scheme && URI.scheme_list.include?(scheme.upcase)
	URI.scheme_list[scheme.upcase].new(scheme, userinfo, host, port,
                                           registry, path, opaque, query,
                                           fragment, self)
      else
	Generic.new(scheme, userinfo, host, port,
	   	    registry, path, opaque, query,
	    	    fragment, self)
      end
    end

    def join(*str)
      u = self.parse(str[0])
      str[1 .. -1].each do |x|
	u = u.merge(x)
      end
      u
    end

    def extract(str, schemes = nil, &block)
      if block_given?
       	str.scan(make_regexp(schemes)) { yield $& }
	nil
      else
	result = []
	str.scan(make_regexp(schemes)) { result.push $& }
	result
      end
    end

    def make_regexp(schemes = nil)
      unless schemes
       	@regexp[:ABS_URI_REF]
      else
	/(?=#{Regexp.union(*schemes)}:)#{@pattern[:X_ABS_URI]}/x
      end
    end

    def escape(str, unsafe = @regexp[:UNSAFE])
      unless unsafe.kind_of?(Regexp)
        # perhaps unsafe is String object
        unsafe = Regexp.new("[#{Regexp.quote(unsafe)}]", false)
      end
      str.gsub(unsafe) do
        us = $&
        tmp = ''
        us.each_byte do |uc|
          tmp << sprintf('%%%02X', uc)
        end
        tmp
      end.force_encoding(Encoding::US_ASCII)
    end

    def unescape(str, escaped = @regexp[:ESCAPED])
      str.gsub(escaped) { [$&[1, 2].hex].pack('C') }.force_encoding(str.encoding)
    end

    @@to_s = Kernel.instance_method(:to_s)
    def inspect
      @@to_s.bind(self).call
    end

    private

    def initialize_pattern(opts = {})
      ret = {}
      ret[:ESCAPED] = escaped = (opts.delete(:ESCAPED) || PATTERN::ESCAPED)
      ret[:UNRESERVED] = unreserved = opts.delete(:UNRESERVED) || PATTERN::UNRESERVED
      ret[:RESERVED] = reserved = opts.delete(:RESERVED) || PATTERN::RESERVED
      ret[:DOMLABEL] = domlabel = opts.delete(:DOMLABEL) || PATTERN::DOMLABEL
      ret[:TOPLABEL] = toplabel = opts.delete(:TOPLABEL) || PATTERN::TOPLABEL
      ret[:HOSTNAME] = hostname = opts.delete(:HOSTNAME)

      # RFC 2396 (URI Generic Syntax)
      # RFC 2732 (IPv6 Literal Addresses in URL's)
      # RFC 2373 (IPv6 Addressing Architecture)

      # uric          = reserved | unreserved | escaped
      ret[:URIC] = uric = "(?:[#{unreserved}#{reserved}]|#{escaped})"
      # uric_no_slash = unreserved | escaped | ";" | "?" | ":" | "@" |
      #                 "&" | "=" | "+" | "$" | ","
      ret[:URIC_NO_SLASH] = uric_no_slash = "(?:[#{unreserved};?:@&=+$,]|#{escaped})"
      # query         = *uric
      ret[:QUERY] = query = "#{uric}*"
      # fragment      = *uric
      ret[:FRAGMENT] = fragment = "#{uric}*"

      # hostname      = *( domainlabel "." ) toplabel [ "." ]
      unless hostname
	ret[:HOSTNAME] = hostname = "(?:#{domlabel}\\.)*#{toplabel}\\.?"
      end

      # RFC 2373, APPENDIX B:
      # IPv6address = hexpart [ ":" IPv4address ]
      # IPv4address   = 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT
      # hexpart = hexseq | hexseq "::" [ hexseq ] | "::" [ hexseq ]
      # hexseq  = hex4 *( ":" hex4)
      # hex4    = 1*4HEXDIG
      #
      # XXX: This definition has a flaw. "::" + IPv4address must be
      # allowed too.  Here is a replacement.
      #
      # IPv4address = 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT
      ret[:IPV4ADDR] = ipv4addr = "\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}"
      # hex4     = 1*4HEXDIG
      hex4 = "[#{PATTERN::HEX}]{1,4}"
      # lastpart = hex4 | IPv4address
      lastpart = "(?:#{hex4}|#{ipv4addr})"
      # hexseq1  = *( hex4 ":" ) hex4
      hexseq1 = "(?:#{hex4}:)*#{hex4}"
      # hexseq2  = *( hex4 ":" ) lastpart
      hexseq2 = "(?:#{hex4}:)*#{lastpart}"
      # IPv6address = hexseq2 | [ hexseq1 ] "::" [ hexseq2 ]
      ret[:IPV6ADDR] = ipv6addr = "(?:#{hexseq2}|(?:#{hexseq1})?::(?:#{hexseq2})?)"

      # IPv6prefix  = ( hexseq1 | [ hexseq1 ] "::" [ hexseq1 ] ) "/" 1*2DIGIT
      # unused

      # ipv6reference = "[" IPv6address "]" (RFC 2732)
      ret[:IPV6REF] = ipv6ref = "\\[#{ipv6addr}\\]"

      # host          = hostname | IPv4address
      # host          = hostname | IPv4address | IPv6reference (RFC 2732)
      ret[:HOST] = host = "(?:#{hostname}|#{ipv4addr}|#{ipv6ref})"
      # port          = *digit
      port = '\d*'
      # hostport      = host [ ":" port ]
      ret[:HOSTPORT] = hostport = "#{host}(?::#{port})?"

      # userinfo      = *( unreserved | escaped |
      #                    ";" | ":" | "&" | "=" | "+" | "$" | "," )
      ret[:USERINFO] = userinfo = "(?:[#{unreserved};:&=+$,]|#{escaped})*"

      # pchar         = unreserved | escaped |
      #                 ":" | "@" | "&" | "=" | "+" | "$" | ","
      pchar = "(?:[#{unreserved}:@&=+$,]|#{escaped})"
      # param         = *pchar
      param = "#{pchar}*"
      # segment       = *pchar *( ";" param )
      segment = "#{pchar}*(?:;#{param})*"
      # path_segments = segment *( "/" segment )
      ret[:PATH_SEGMENTS] = path_segments = "#{segment}(?:/#{segment})*"

      # server        = [ [ userinfo "@" ] hostport ]
      server = "(?:#{userinfo}@)?#{hostport}"
      # reg_name      = 1*( unreserved | escaped | "$" | "," |
      #                     ";" | ":" | "@" | "&" | "=" | "+" )
      ret[:REG_NAME] = reg_name = "(?:[#{unreserved}$,;:@&=+]|#{escaped})+"
      # authority     = server | reg_name
      authority = "(?:#{server}|#{reg_name})"

      # rel_segment   = 1*( unreserved | escaped |
      #                     ";" | "@" | "&" | "=" | "+" | "$" | "," )
      ret[:REL_SEGMENT] = rel_segment = "(?:[#{unreserved};@&=+$,]|#{escaped})+"

      # scheme        = alpha *( alpha | digit | "+" | "-" | "." )
      ret[:SCHEME] = scheme = "[#{PATTERN::ALPHA}][-+.#{PATTERN::ALPHA}\\d]*"

      # abs_path      = "/"  path_segments
      ret[:ABS_PATH] = abs_path = "/#{path_segments}"
      # rel_path      = rel_segment [ abs_path ]
      ret[:REL_PATH] = rel_path = "#{rel_segment}(?:#{abs_path})?"
      # net_path      = "//" authority [ abs_path ]
      ret[:NET_PATH] = net_path = "//#{authority}(?:#{abs_path})?"

      # hier_part     = ( net_path | abs_path ) [ "?" query ]
      ret[:HIER_PART] = hier_part = "(?:#{net_path}|#{abs_path})(?:\\?(?:#{query}))?"
      # opaque_part   = uric_no_slash *uric
      ret[:OPAQUE_PART] = opaque_part = "#{uric_no_slash}#{uric}*"

      # absoluteURI   = scheme ":" ( hier_part | opaque_part )
      ret[:ABS_URI] = abs_uri = "#{scheme}:(?:#{hier_part}|#{opaque_part})"
      # relativeURI   = ( net_path | abs_path | rel_path ) [ "?" query ]
      ret[:REL_URI] = rel_uri = "(?:#{net_path}|#{abs_path}|#{rel_path})(?:\\?#{query})?"

      # URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]
      ret[:URI_REF] = uri_ref = "(?:#{abs_uri}|#{rel_uri})?(?:##{fragment})?"

      ret[:X_ABS_URI] = "
        (#{scheme}):                           (?# 1: scheme)
        (?:
           (#{opaque_part})                    (?# 2: opaque)
        |
           (?:(?:
             //(?:
                 (?:(?:(#{userinfo})@)?        (?# 3: userinfo)
                   (?:(#{host})(?::(\\d*))?))? (?# 4: host, 5: port)
               |
                 (#{reg_name})                 (?# 6: registry)
               )
             |
             (?!//))                           (?# XXX: '//' is the mark for hostport)
             (#{abs_path})?                    (?# 7: path)
           )(?:\\?(#{query}))?                 (?# 8: query)
        )
        (?:\\#(#{fragment}))?                  (?# 9: fragment)
      "

      ret[:X_REL_URI] = "
        (?:
          (?:
            //
            (?:
              (?:(#{userinfo})@)?       (?# 1: userinfo)
                (#{host})?(?::(\\d*))?  (?# 2: host, 3: port)
            |
              (#{reg_name})             (?# 4: registry)
            )
          )
        |
          (#{rel_segment})              (?# 5: rel_segment)
        )?
        (#{abs_path})?                  (?# 6: abs_path)
        (?:\\?(#{query}))?              (?# 7: query)
        (?:\\#(#{fragment}))?           (?# 8: fragment)
      "

      ret
    end

    def initialize_regexp(pattern)
      ret = {}

      # for URI::split
      ret[:ABS_URI] = Regexp.new('\A\s*' + pattern[:X_ABS_URI] + '\s*\z', Regexp::EXTENDED)
      ret[:REL_URI] = Regexp.new('\A\s*' + pattern[:X_REL_URI] + '\s*\z', Regexp::EXTENDED)

      # for URI::extract
      ret[:URI_REF]     = Regexp.new(pattern[:URI_REF])
      ret[:ABS_URI_REF] = Regexp.new(pattern[:X_ABS_URI], Regexp::EXTENDED)
      ret[:REL_URI_REF] = Regexp.new(pattern[:X_REL_URI], Regexp::EXTENDED)

      # for URI::escape/unescape
      ret[:ESCAPED] = Regexp.new(pattern[:ESCAPED])
      ret[:UNSAFE]  = Regexp.new("[^#{pattern[:UNRESERVED]}#{pattern[:RESERVED]}]")

      # for Generic#initialize
      ret[:SCHEME]   = Regexp.new("^#{pattern[:SCHEME]}$")
      ret[:USERINFO] = Regexp.new("^#{pattern[:USERINFO]}$")
      ret[:HOST]     = Regexp.new("^#{pattern[:HOST]}$")
      ret[:PORT]     = Regexp.new("^#{pattern[:PORT]}$")
      ret[:OPAQUE]   = Regexp.new("^#{pattern[:OPAQUE_PART]}$")
      ret[:REGISTRY] = Regexp.new("^#{pattern[:REG_NAME]}$")
      ret[:ABS_PATH] = Regexp.new("^#{pattern[:ABS_PATH]}$")
      ret[:REL_PATH] = Regexp.new("^#{pattern[:REL_PATH]}$")
      ret[:QUERY]    = Regexp.new("^#{pattern[:QUERY]}$")
      ret[:FRAGMENT] = Regexp.new("^#{pattern[:FRAGMENT]}$")

      ret
    end
  end # class Parser

  DEFAULT_PARSER = Parser.new
  DEFAULT_PARSER.pattern.each_pair do |sym, str|
    unless REGEXP::PATTERN.const_defined?(sym)
      REGEXP::PATTERN.const_set(sym, str)
    end
  end
  DEFAULT_PARSER.regexp.each_pair do |sym, str|
    const_set(sym, str)
  end

  module Util # :nodoc:
    def make_components_hash(klass, array_hash)
      tmp = {}
      if array_hash.kind_of?(Array) &&
          array_hash.size == klass.component.size - 1
        klass.component[1..-1].each_index do |i|
          begin
            tmp[klass.component[i + 1]] = array_hash[i].clone
          rescue TypeError
            tmp[klass.component[i + 1]] = array_hash[i]
          end
        end

      elsif array_hash.kind_of?(Hash)
        array_hash.each do |key, value|
          begin
            tmp[key] = value.clone
          rescue TypeError
            tmp[key] = value
          end
        end
      else
        raise ArgumentError,
          "expected Array of or Hash of components of #{klass.to_s} (#{klass.component[1..-1].join(', ')})"
      end
      tmp[:scheme] = klass.to_s.sub(/\A.*::/, '').downcase

      return tmp
    end
    module_function :make_components_hash
  end

  module Escape
    #
    # == Synopsis
    #
    #   URI.escape(str [, unsafe])
    #
    # == Args
    #
    # +str+::
    #   String to replaces in.
    # +unsafe+::
    #   Regexp that matches all symbols that must be replaced with codes.
    #   By default uses <tt>REGEXP::UNSAFE</tt>.
    #   When this argument is a String, it represents a character set.
    #
    # == Description
    #
    # Escapes the string, replacing all unsafe characters with codes.
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   enc_uri = URI.escape("http://example.com/?a=\11\15")
    #   p enc_uri
    #   # => "http://example.com/?a=%09%0D"
    #
    #   p URI.unescape(enc_uri)
    #   # => "http://example.com/?a=\t\r"
    #
    #   p URI.escape("@?@!", "!?")
    #   # => "@%3F@%21"
    #
    def escape(*arg)
      warn "#{caller(1)[0]}: warning: URI.escape is obsolete" if $VERBOSE
      DEFAULT_PARSER.escape(*arg)
    end
    alias encode escape
    #
    # == Synopsis
    #
    #   URI.unescape(str)
    #
    # == Args
    #
    # +str+::
    #   Unescapes the string.
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   enc_uri = URI.escape("http://example.com/?a=\11\15")
    #   p enc_uri
    #   # => "http://example.com/?a=%09%0D"
    #
    #   p URI.unescape(enc_uri)
    #   # => "http://example.com/?a=\t\r"
    #
    def unescape(*arg)
      warn "#{caller(1)[0]}: warning: URI.unescape is obsolete" if $VERBOSE
      DEFAULT_PARSER.unescape(*arg)
    end
    alias decode unescape
  end

  extend Escape
  include REGEXP

  @@schemes = {}
  def self.scheme_list
    @@schemes
  end

  #
  # Base class for all URI exceptions.
  #
  class Error < StandardError; end
  #
  # Not a URI.
  #
  class InvalidURIError < Error; end
  #
  # Not a URI component.
  #
  class InvalidComponentError < Error; end
  #
  # URI is valid, bad usage is not.
  #
  class BadURIError < Error; end

  #
  # == Synopsis
  #
  #   URI::split(uri)
  #
  # == Args
  #
  # +uri+::
  #   String with URI.
  #
  # == Description
  #
  # Splits the string on following parts and returns array with result:
  #
  #   * Scheme
  #   * Userinfo
  #   * Host
  #   * Port
  #   * Registry
  #   * Path
  #   * Opaque
  #   * Query
  #   * Fragment
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   p URI.split("http://www.ruby-lang.org/")
  #   # => ["http", nil, "www.ruby-lang.org", nil, nil, "/", nil, nil, nil]
  #
  def self.split(uri)
    DEFAULT_PARSER.split(uri)
  end

  #
  # == Synopsis
  #
  #   URI::parse(uri_str)
  #
  # == Args
  #
  # +uri_str+::
  #   String with URI.
  #
  # == Description
  #
  # Creates one of the URI's subclasses instance from the string.
  #
  # == Raises
  #
  # URI::InvalidURIError
  #   Raised if URI given is not a correct one.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://www.ruby-lang.org/")
  #   p uri
  #   # => #<URI::HTTP:0x202281be URL:http://www.ruby-lang.org/>
  #   p uri.scheme
  #   # => "http"
  #   p uri.host
  #   # => "www.ruby-lang.org"
  #
  def self.parse(uri)
    DEFAULT_PARSER.parse(uri)
  end

  #
  # == Synopsis
  #
  #   URI::join(str[, str, ...])
  #
  # == Args
  #
  # +str+::
  #   String(s) to work with
  #
  # == Description
  #
  # Joins URIs.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   p URI.join("http://localhost/","main.rbx")
  #   # => #<URI::HTTP:0x2022ac02 URL:http://localhost/main.rbx>
  #
  def self.join(*str)
    DEFAULT_PARSER.join(*str)
  end

  #
  # == Synopsis
  #
  #   URI::extract(str[, schemes][,&blk])
  #
  # == Args
  #
  # +str+::
  #   String to extract URIs from.
  # +schemes+::
  #   Limit URI matching to a specific schemes.
  #
  # == Description
  #
  # Extracts URIs from a string. If block given, iterates through all matched URIs.
  # Returns nil if block given or array with matches.
  #
  # == Usage
  #
  #   require "uri"
  #
  #   URI.extract("text here http://foo.example.org/bla and here mailto:test@example.com and here also.")
  #   # => ["http://foo.example.com/bla", "mailto:test@example.com"]
  #
  def self.extract(str, schemes = nil, &block)
    DEFAULT_PARSER.extract(str, schemes, &block)
  end

  #
  # == Synopsis
  #
  #   URI::regexp([match_schemes])
  #
  # == Args
  #
  # +match_schemes+::
  #   Array of schemes. If given, resulting regexp matches to URIs
  #   whose scheme is one of the match_schemes.
  #
  # == Description
  # Returns a Regexp object which matches to URI-like strings.
  # The Regexp object returned by this method includes arbitrary
  # number of capture group (parentheses).  Never rely on it's number.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   # extract first URI from html_string
  #   html_string.slice(URI.regexp)
  #
  #   # remove ftp URIs
  #   html_string.sub(URI.regexp(['ftp'])
  #
  #   # You should not rely on the number of parentheses
  #   html_string.scan(URI.regexp) do |*matches|
  #     p $&
  #   end
  #
  def self.regexp(schemes = nil)
    DEFAULT_PARSER.make_regexp(schemes)
  end

  TBLENCWWWCOMP_ = {} # :nodoc:
  TBLDECWWWCOMP_ = {} # :nodoc:
  HTML5ASCIIINCOMPAT = [Encoding::UTF_7, Encoding::UTF_16BE, Encoding::UTF_16LE,
    Encoding::UTF_32BE, Encoding::UTF_32LE] # :nodoc:

  # Encode given +str+ to URL-encoded form data.
  #
  # This doesn't convert *, -, ., 0-9, A-Z, _, a-z,
  # does convert SP to +, and convert others to %XX.
  #
  # This refers http://www.w3.org/TR/html5/forms.html#url-encoded-form-data
  #
  # See URI.decode_www_form_component, URI.encode_www_form
  def self.encode_www_form_component(str)
    if TBLENCWWWCOMP_.empty?
      256.times do |i|
        TBLENCWWWCOMP_[i.chr] = '%%%02X' % i
      end
      TBLENCWWWCOMP_[' '] = '+'
      TBLENCWWWCOMP_.freeze
    end
    str = str.to_s
    if HTML5ASCIIINCOMPAT.include?(str.encoding)
      str = str.encode(Encoding::UTF_8)
    else
      str = str.dup
    end
    str.force_encoding(Encoding::ASCII_8BIT)
    str.gsub!(/[^*\-.0-9A-Z_a-z]/, TBLENCWWWCOMP_)
    str.force_encoding(Encoding::US_ASCII)
  end

  # Decode given +str+ of URL-encoded form data.
  #
  # This decods + to SP.
  #
  # See URI.encode_www_form_component, URI.decode_www_form
  def self.decode_www_form_component(str, enc=Encoding::UTF_8)
    if TBLDECWWWCOMP_.empty?
      256.times do |i|
        h, l = i>>4, i&15
        TBLDECWWWCOMP_['%%%X%X' % [h, l]] = i.chr
        TBLDECWWWCOMP_['%%%x%X' % [h, l]] = i.chr
        TBLDECWWWCOMP_['%%%X%x' % [h, l]] = i.chr
        TBLDECWWWCOMP_['%%%x%x' % [h, l]] = i.chr
      end
      TBLDECWWWCOMP_['+'] = ' '
      TBLDECWWWCOMP_.freeze
    end
    raise ArgumentError, "invalid %-encoding (#{str})" unless /\A(?:%\h\h|[^%]+)*\z/ =~ str
    str.gsub(/\+|%\h\h/, TBLDECWWWCOMP_).force_encoding(enc)
  end

  # Generate URL-encoded form data from given +enum+.
  #
  # This generates application/x-www-form-urlencoded data defined in HTML5
  # from given an Enumerable object.
  #
  # This internally uses URI.encode_www_form_component(str).
  #
  # This doesn't convert encodings of give items, so convert them before call
  # this method if you want to send data as other than original encoding or
  # mixed encoding data. (strings which is encoded in HTML5 ASCII incompatible
  # encoding is converted to UTF-8)
  #
  # This doesn't treat files. When you send a file, use multipart/form-data.
  #
  # This refers http://www.w3.org/TR/html5/forms.html#url-encoded-form-data
  #
  # See URI.encode_www_form_component, URI.decode_www_form
  def self.encode_www_form(enum)
    str = nil
    enum.each do |k,v|
      if str
        str << '&'
      else
        str = nil.to_s
      end
      str << encode_www_form_component(k)
      str << '='
      str << encode_www_form_component(v)
    end
    str
  end

  WFKV_ = '(?:%\h\h|[^%#=;&])' # :nodoc:

  # Decode URL-encoded form data from given +str+.
  #
  # This decodes application/x-www-form-urlencoded data
  # and returns array of key-value array.
  # This internally uses URI.decode_www_form_component.
  #
  # _charset_ hack is not supported now because the mapping from given charset
  # to Ruby's encoding is not clear yet.
  # see also http://www.w3.org/TR/html5/syntax.html#character-encodings-0
  #
  # This refers http://www.w3.org/TR/html5/forms.html#url-encoded-form-data
  #
  # ary = URI.decode_www_form("a=1&a=2&b=3")
  # p ary                  #=> [['a', '1'], ['a', '2'], ['b', '3']]
  # p ary.assoc('a').last  #=> '1'
  # p ary.assoc('b').last  #=> '3'
  # p ary.rassoc('a').last #=> '2'
  # p Hash[ary]            # => {"a"=>"2", "b"=>"3"}
  #
  # See URI.decode_www_form_component, URI.encode_www_form
  def self.decode_www_form(str, enc=Encoding::UTF_8)
    return [] if str.empty?
    unless /\A#{WFKV_}*=#{WFKV_}*(?:[;&]#{WFKV_}*=#{WFKV_}*)*\z/o =~ str
      raise ArgumentError, "invalid data of application/x-www-form-urlencoded (#{str})"
    end
    ary = []
    $&.scan(/([^=;&]+)=([^;&]*)/) do
      ary << [decode_www_form_component($1, enc), decode_www_form_component($2, enc)]
    end
    ary
  end
end

module Kernel
  # alias for URI.parse.
  #
  # This method is introduced at 1.8.2.
  def URI(uri_str) # :doc:
    URI.parse(uri_str)
  end
  module_function :URI
end
# -*- encoding: ascii-8bit -*-
require File.expand_path('../../../../spec_helper', __FILE__)
require File.expand_path('../../fixtures/classes', __FILE__)
require File.expand_path('../shared/basic', __FILE__)
require File.expand_path('../shared/string', __FILE__)

describe "Array#pack with format 'Z'" do
  it_behaves_like :array_pack_basic, 'Z'
  it_behaves_like :array_pack_basic_non_float, 'Z'
  it_behaves_like :array_pack_no_platform, 'Z'
  it_behaves_like :array_pack_string, 'Z'

  it "adds all the bytes and appends a NULL byte when passed the '*' modifier" do
    ["abc"].pack("Z*").should == "abc\x00"
  end

  it "padds the output with NULL bytes when the count exceeds the size of the String" do
    ["abc"].pack("Z6").should == "abc\x00\x00\x00"
  end

  it "adds a NULL byte when the value is nil" do
    [nil].pack("Z").should == "\x00"
  end

  it "pads the output with NULL bytes when the value is nil" do
    [nil].pack("Z3").should == "\x00\x00\x00"
  end

  it "does not append a NULL byte when passed the '*' modifier and the value is nil" do
    [nil].pack("Z*").should == "\x00"
  end
end
require 'rubygems'
require 'hpricot'

class Profiler

  class Leaf
    def initialize(method, total)
      @method = method
      @total = total
    end

    attr_reader :method, :total
  end

  class Method
    def initialize(id)
      @id = id
      @leaves = []
    end

    attr_accessor :file, :line, :name, :total, :called

    def add_leaf(method, total)
      @leaves << Leaf.new(method, total)
    end

    def total_time
      @total.to_f / 1_000_000_000
    end

    def self_time
      time = @leaves.inject(@total) { |acc, leaf| acc - leaf.total }
      time.to_f / 1_000_000_000
    end

    def inspect
      "#<Profiler::Method #{name}>"
    end

  end

  def initialize
    @methods = Hash.new do |h,k|
      h[k] = Method.new(k)
    end
  end

  attr_reader :methods

  def load(data)
    doc = Hpricot(data)

    top = (doc / :profile)
    (top / :method).each do |m|
      meth = @methods[m[:id].to_i]
      meth.file = m[:file]
      meth.line = m[:line].to_i
      meth.name = m[:name]
      meth.total = m[:total].to_i
      meth.called = m[:called].to_i

      (m / :leaf).each do |l|
        meth.add_leaf @methods[l[:id].to_i], l[:total].to_i
      end
    end
  end

  def biggest
    sorted = @methods.sort do |a,b|
      b[1].total <=> a[1].total
    end

    sorted[0][1]
  end
end

prof = Profiler.new
prof.load File.read(ARGV.shift)
meth = prof.biggest

puts "#{meth.name}  #{meth.total_time} #{meth.self_time}"
require File.expand_path('../../../../../spec_helper', __FILE__)
require 'net/http'

describe "Net::HTTP#initialize" do
  it "is private" do
    Net::HTTP.should have_private_instance_method(:initialize)
  end
  
  describe "when passed address" do
    before(:each) do
      @net = Net::HTTP.allocate
      @net.send(:initialize, "localhost")
    end

    it "sets the new Net::HTTP instance's address to the passed address" do
      @net.address.should == "localhost"
    end

    it "sets the new Net::HTTP instance's port to the default HTTP port" do
      @net.port.should eql(Net::HTTP.default_port)
    end

    it "does not start the new Net::HTTP instance" do
      @net.started?.should be_false
    end
  end
  
  describe "when passed address, port" do
    before(:each) do
      @net = Net::HTTP.allocate
      @net.send(:initialize, "localhost", 3333)
    end

    it "sets the new Net::HTTP instance's address to the passed address" do
      @net.address.should == "localhost"
    end

    it "sets the new Net::HTTP instance's port to the passed port" do
      @net.port.should eql(3333)
    end

    it "does not start the new Net::HTTP instance" do
      @net.started?.should be_false
    end
  end
end
require File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../shared/eql', __FILE__)

ruby_version_is "1.9" do
  describe "MatchData#eql?" do
    it_behaves_like(:matchdata_eql, :eql?)
  end
end
require 'active_support/core_ext/array/wrap'
require 'active_support/core_ext/object/blank'

module ActiveResource
  class ResourceInvalid < ClientError  #:nodoc:
  end

  # Active Resource validation is reported to and from this object, which is used by Base#save
  # to determine whether the object in a valid state to be saved. See usage example in Validations.
  class Errors < ActiveModel::Errors
    # Grabs errors from an array of messages (like ActiveRecord::Validations)
    # The second parameter directs the errors cache to be cleared (default)
    # or not (by passing true)
    def from_array(messages, save_cache = false)
      clear unless save_cache
      humanized_attributes = @base.attributes.keys.inject({}) { |h, attr_name| h.update(attr_name.humanize => attr_name) }
      messages.each do |message|
        attr_message = humanized_attributes.keys.detect do |attr_name|
          if message[0, attr_name.size + 1] == "#{attr_name} "
            add humanized_attributes[attr_name], message[(attr_name.size + 1)..-1]
          end
        end

        self[:base] << message if attr_message.nil?
      end
    end

    # Grabs errors from a json response.
    def from_json(json, save_cache = false)
      array = Array.wrap(ActiveSupport::JSON.decode(json)['errors']) rescue []
      from_array array, save_cache
    end

    # Grabs errors from an XML response.
    def from_xml(xml, save_cache = false)
      array = Array.wrap(Hash.from_xml(xml)['errors']['error']) rescue []
      from_array array, save_cache
    end
  end

  # Module to support validation and errors with Active Resource objects. The module overrides
  # Base#save to rescue ActiveResource::ResourceInvalid exceptions and parse the errors returned
  # in the web service response. The module also adds an +errors+ collection that mimics the interface
  # of the errors provided by ActiveRecord::Errors.
  #
  # ==== Example
  #
  # Consider a Person resource on the server requiring both a +first_name+ and a +last_name+ with a
  # <tt>validates_presence_of :first_name, :last_name</tt> declaration in the model:
  #
  #   person = Person.new(:first_name => "Jim", :last_name => "")
  #   person.save                   # => false (server returns an HTTP 422 status code and errors)
  #   person.valid?                 # => false
  #   person.errors.empty?          # => false
  #   person.errors.count           # => 1
  #   person.errors.full_messages   # => ["Last name can't be empty"]
  #   person.errors[:last_name]  # => ["can't be empty"]
  #   person.last_name = "Halpert"
  #   person.save                   # => true (and person is now saved to the remote service)
  #
  module Validations
    extend  ActiveSupport::Concern
    include ActiveModel::Validations

    included do
      alias_method_chain :save, :validation
    end

    # Validate a resource and save (POST) it to the remote web service.
    # If any local validations fail - the save (POST) will not be attempted.
    def save_with_validation(options=nil)
      perform_validation = case options
        when Hash
          options[:validate] != false
        when NilClass
          true
        else
          ActiveSupport::Deprecation.warn "save(#{options}) is deprecated, please give save(:validate => #{options}) instead", caller
          options
      end

      # clear the remote validations so they don't interfere with the local
      # ones. Otherwise we get an endless loop and can never change the
      # fields so as to make the resource valid
      @remote_errors = nil
      if perform_validation && valid? || !perform_validation
        save_without_validation
        true
      else
        false
      end
    rescue ResourceInvalid => error
      # cache the remote errors because every call to <tt>valid?</tt> clears
      # all errors. We must keep a copy to add these back after local
      # validations
      @remote_errors = error
      load_remote_errors(@remote_errors, true)
      false
    end


    # Loads the set of remote errors into the object's Errors based on the
    # content-type of the error-block received
    def load_remote_errors(remote_errors, save_cache = false ) #:nodoc:
      case self.class.format
      when ActiveResource::Formats[:xml]
        errors.from_xml(remote_errors.response.body, save_cache)
      when ActiveResource::Formats[:json]
        errors.from_json(remote_errors.response.body, save_cache)
      end
    end

    # Checks for errors on an object (i.e., is resource.errors empty?).
    #
    # Runs all the specified local validations and returns true if no errors
    # were added, otherwise false.
    # Runs local validations (eg those on your Active Resource model), and
    # also any errors returned from the remote system the last time we
    # saved.
    # Remote errors can only be cleared by trying to re-save the resource.
    #
    # ==== Examples
    #   my_person = Person.create(params[:person])
    #   my_person.valid?
    #   # => true
    #
    #   my_person.errors.add('login', 'can not be empty') if my_person.login == ''
    #   my_person.valid?
    #   # => false
    #
    def valid?
      super
      load_remote_errors(@remote_errors, true) if defined?(@remote_errors) && @remote_errors.present?
      errors.empty?
    end

    # Returns the Errors object that holds all information about attribute error messages.
    def errors
      @errors ||= Errors.new(self)
    end
  end
end
#
# animated wave demo (called by 'widget')
#
# based on Tcl/Tk8.5a2 widget demos

# destroy toplevel widget for this demo script
if defined?($aniwave_demo) && $aniwave_demo
  $aniwave_demo.destroy
  $aniwave_demo = nil
end

# create toplevel widget
$aniwave_demo = TkToplevel.new {|w|
  title("Animated Wave Demonstration")
  iconname("aniwave")
  positionWindow(w)
}

base_frame = TkFrame.new($aniwave_demo).pack(:fill=>:both, :expand=>true)

# create label
msg = TkLabel.new(base_frame) {
  font $font
  wraplength '4i'
  justify 'left'
  text 'This demonstration contains a canvas widget with a line item inside it. The animation routines work by adjusting the coordinates list of the line.'
}
msg.pack('side'=>'top')

# create frame
TkFrame.new(base_frame) {|frame|
  TkButton.new(frame) {
    text 'Dismiss'
    command proc{
      tmppath = $aniwave_demo
      $aniwave_demo = nil
      tmppath.destroy
    }
  }.pack('side'=>'left', 'expand'=>'yes')

  TkButton.new(frame) {
    text 'See Code'
    command proc{showCode 'aniwave'}
  }.pack('side'=>'left', 'expand'=>'yes')

}.pack('side'=>'bottom', 'fill'=>'x', 'pady'=>'2m')

# animated wave
class AnimatedWaveDemo
  def initialize(frame, dir=:left)
    @direction = dir

    # create canvas widget
    @c = TkCanvas.new(frame, :width=>300, :height=>200,
                      :background=>'black')
    @c.pack(:padx=>10, :pady=>10, :expand=>true)

    # Creates a coordinates list of a wave.
    @waveCoords = []
    @backupCoords = []
    n = 0
    (-10..300).step(5){|n| @waveCoords << [n, 100]; @backupCoords << [n, 100] }
    n = 305
    @waveCoords << [n, 0]; @backupCoords << [n, 0]
    @waveCoords << [n+5, 200]; @backupCoords << [n+5, 200]
    @coordsLen = @waveCoords.length

    # Create a smoothed line and arrange for its coordinates to be the
    # contents of the variable waveCoords.
    @line = TkcLine.new(@c, @waveCoords,
                        :width=>1, :fill=>'green', :smooth=>true)

    # Main animation "loop".
    # Theoretically 100 frames-per-second (==10ms between frames)
    @timer = TkTimer.new(10){ basicMotion; reverser }

    # Arrange for the animation loop to stop when the canvas is deleted
    @c.bindtags_unshift(TkBindTag.new('Destroy'){ @timer.stop })
  end

  # Basic motion handler. Given what direction the wave is travelling
  # in, it advances the y coordinates in the coordinate-list one step in
  # that direction.
  def basicMotion
    @backupCoords, @waveCoords = @waveCoords, @backupCoords
    (0...@coordsLen).each{|idx|
      if @direction == :left
        @waveCoords[idx][1] = @backupCoords[(idx+1 == @coordsLen)? 0: idx+1][1]
      else
        @waveCoords[idx][1] = @backupCoords[(idx == 0)? -1: idx-1][1]
      end
    }
    @line.coords(@waveCoords)
  end

  # Oscillation handler. This detects whether to reverse the direction
  # of the wave by checking to see if the peak of the wave has moved off
  # the screen (whose size we know already.)
  def reverser
    if @waveCoords[0][1] < 10
      @direction = :right
    elsif @waveCoords[-1][1] < 10
      @direction = :left
    end
  end

  # animation control
  def move
    @timer.start
  end

  def stop
    @timer.stop
  end
end

# Start the animation processing
AnimatedWaveDemo.new(base_frame, :left).move
require 'test/unit'

begin
  require 'gdbm'
rescue LoadError
end

if defined? GDBM
  require 'tmpdir'
  require 'fileutils'

  class TestGDBM < Test::Unit::TestCase
    def TestGDBM.uname_s
      require 'rbconfig'
      case Config::CONFIG['target_os']
      when 'cygwin'
        require 'Win32API'
        uname = Win32API.new('cygwin1', 'uname', 'P', 'I')
        utsname = ' ' * 100
        raise 'cannot get system name' if uname.call(utsname) == -1

        utsname.unpack('A20' * 5)[0]
      else
        Config::CONFIG['target_os']
      end
    end
    SYSTEM = uname_s

    def setup
      @path = "tmptest_gdbm_"
      assert_instance_of(GDBM, @gdbm = GDBM.new(@path))

      # prepare to make readonly GDBM file
      GDBM.open("tmptest_gdbm_rdonly", 0400) {|gdbm|
        gdbm['foo'] = 'FOO'
      }
      assert_instance_of(GDBM, @gdbm_rdonly = GDBM.new("tmptest_gdbm_rdonly", nil))
    end
    def teardown
      assert_nil(@gdbm.close)
      assert_nil(@gdbm_rdonly.close)
      ObjectSpace.each_object(GDBM) do |obj|
        obj.close unless obj.closed?
      end
      File.delete *Dir.glob("*tmptest_gdbm*").to_a
      p Dir.glob("*tmptest_gdbm*") if $DEBUG
    end

    def check_size(expect, gdbm=@gdbm)
      assert_equal(expect, gdbm.size)
      n = 0
      gdbm.each { n+=1 }
      assert_equal(expect, n)
      if expect == 0
        assert_equal(true, gdbm.empty?)
      else
        assert_equal(false, gdbm.empty?)
      end
    end

    def have_fork?
      begin
        fork{}
        true
      rescue NotImplementedError
        false
      end
    end

    def test_s_new_has_no_block
      # GDBM.new ignore the block
      foo = true
      assert_instance_of(GDBM, gdbm = GDBM.new("tmptest_gdbm") { foo = false })
      assert_equal(foo, true)
      assert_nil(gdbm.close)
    end
    def test_s_open_create_new
      return if /^CYGWIN_9/ =~ SYSTEM

      save_mask = File.umask(0)
      begin
        assert_instance_of(GDBM, gdbm = GDBM.open("tmptest_gdbm"))
        gdbm.close
        assert_equal(File.stat("tmptest_gdbm").mode & 0777, 0666)
        assert_instance_of(GDBM, gdbm = GDBM.open("tmptest_gdbm2", 0644))
        gdbm.close
        assert_equal(File.stat("tmptest_gdbm2").mode & 0777, 0644)
      ensure
        File.umask save_mask
      end
    end
    def test_s_open_no_create
      assert_nil(gdbm = GDBM.open("tmptest_gdbm", nil),
                 "this test is failed on libgdbm 1.8.0")
    ensure
      gdbm.close if gdbm
    end
    def test_s_open_3rd_arg
      assert_instance_of(GDBM, gdbm = GDBM.open("tmptest_gdbm", 0644,
                                                GDBM::FAST))
      gdbm.close

      # gdbm 1.8.0 specific
      if defined? GDBM::SYNC
        assert_instance_of(GDBM, gdbm = GDBM.open("tmptest_gdbm", 0644,
                                                  GDBM::SYNC))
        gdbm.close
      end
      # gdbm 1.8.0 specific
      if defined? GDBM::NOLOCK
        assert_instance_of(GDBM, gdbm = GDBM.open("tmptest_gdbm", 0644,
                                                  GDBM::NOLOCK))
        gdbm.close
      end
    end
    def test_s_open_with_block
      assert_equal(GDBM.open("tmptest_gdbm") { :foo }, :foo)
    end
    def test_s_open_lock
      return unless have_fork?	# snip this test
      pid = fork() {
        assert_instance_of(GDBM, gdbm  = GDBM.open("tmptest_gdbm", 0644))
        sleep 2
      }
      begin
        sleep 1
        assert_raise(Errno::EWOULDBLOCK) {
          begin
            assert_instance_of(GDBM, gdbm2 = GDBM.open("tmptest_gdbm", 0644))
          rescue Errno::EAGAIN, Errno::EACCES
            raise Errno::EWOULDBLOCK
          end
        }
      ensure
        Process.wait pid
      end
    end

=begin
    # Is it guaranteed on many OS?
    def test_s_open_lock_one_process
      # locking on one process
      assert_instance_of(GDBM, gdbm  = GDBM.open("tmptest_gdbm", 0644))
      assert_raise(Errno::EWOULDBLOCK) {
        begin
          GDBM.open("tmptest_gdbm", 0644)
        rescue Errno::EAGAIN
          raise Errno::EWOULDBLOCK
        end
      }
    end
=end

    def test_s_open_nolock
      # gdbm 1.8.0 specific
      if not defined? GDBM::NOLOCK
        return
      end
      return unless have_fork?	# snip this test

      pid = fork() {
        assert_instance_of(GDBM, gdbm  = GDBM.open("tmptest_gdbm", 0644,
                                                  GDBM::NOLOCK))
        sleep 2
      }
      sleep 1
      begin
        gdbm2 = nil
        assert_nothing_raised(Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::EACCES) {
          assert_instance_of(GDBM, gdbm2 = GDBM.open("tmptest_gdbm", 0644))
        }
      ensure
        Process.wait pid
        gdbm2.close if gdbm2
      end

      p Dir.glob("tmptest_gdbm*") if $DEBUG

      pid = Process.fork() {
        assert_instance_of(GDBM, gdbm  = GDBM.open("tmptest_gdbm", 0644))
        sleep 2
      }
      begin
        sleep 1
        gdbm2 = nil
        assert_nothing_raised(Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::EACCES) {
          # this test is failed on Cygwin98 (???)
          assert_instance_of(GDBM, gdbm2 = GDBM.open("tmptest_gdbm", 0644,
                                                     GDBM::NOLOCK))
        }
      ensure
        Process.wait pid
        gdbm2.close if gdbm2
      end
    end

    def test_s_open_error
      return if /(ms|bcc)win|mingw|djgpp/ =~ RUBY_PLATFORM
      assert_instance_of(GDBM, gdbm = GDBM.open("tmptest_gdbm", 0))
      assert_raise(Errno::EACCES) {
        GDBM.open("tmptest_gdbm", 0)
      }
      gdbm.close
    end

    def test_close
      assert_instance_of(GDBM, gdbm = GDBM.open("tmptest_gdbm"))
      assert_nil(gdbm.close)

      # closed GDBM file
      assert_raise(RuntimeError) { gdbm.close }
    end

    def test_aref
      assert_equal('bar', @gdbm['foo'] = 'bar')
      assert_equal('bar', @gdbm['foo'])

      assert_nil(@gdbm['bar'])
    end

    def test_fetch
      assert_equal('bar', @gdbm['foo']='bar')
      assert_equal('bar', @gdbm.fetch('foo'))

      # key not found
      assert_raise(IndexError) {
        @gdbm.fetch('bar')
      }

      # test for `ifnone' arg
      assert_equal('baz', @gdbm.fetch('bar', 'baz'))

      # test for `ifnone' block
      assert_equal('foobar', @gdbm.fetch('bar') {|key| 'foo' + key })
    end

    def test_aset
      num = 0
      2.times {|i|
        assert_equal('foo', @gdbm['foo'] = 'foo')
        assert_equal('foo', @gdbm['foo'])
        assert_equal('bar', @gdbm['foo'] = 'bar')
        assert_equal('bar', @gdbm['foo'])

        num += 1 if i == 0
        assert_equal(num, @gdbm.size)

        # assign nil
        assert_equal('', @gdbm['bar'] = '')
        assert_equal('', @gdbm['bar'])

        num += 1 if i == 0
        assert_equal(num, @gdbm.size)

        # empty string
        assert_equal('', @gdbm[''] = '')
        assert_equal('', @gdbm[''])

        num += 1 if i == 0
        assert_equal(num, @gdbm.size)

        # Fixnum
        assert_equal('200', @gdbm['100'] = '200')
        assert_equal('200', @gdbm['100'])

        num += 1 if i == 0
        assert_equal(num, @gdbm.size)

        # Big key and value
        assert_equal('y' * 100, @gdbm['x' * 100] = 'y' * 100)
        assert_equal('y' * 100, @gdbm['x' * 100])

        num += 1 if i == 0
        assert_equal(num, @gdbm.size)
      }
    end

    def test_index
      assert_equal('bar', @gdbm['foo'] = 'bar')
      assert_equal('foo', @gdbm.index('bar'))
      assert_nil(@gdbm['bar'])
    end

    def test_values_at
      keys = %w(foo bar baz)
      values = %w(FOO BAR BAZ)
      @gdbm[keys[0]], @gdbm[keys[1]], @gdbm[keys[2]] = values
      assert_equal(values.reverse, @gdbm.values_at(*keys.reverse))
    end

    def test_select_with_block
      keys = %w(foo bar baz)
      values = %w(FOO BAR BAZ)
      @gdbm[keys[0]], @gdbm[keys[1]], @gdbm[keys[2]] = values
      ret = @gdbm.select {|k,v|
        assert_equal(k.upcase, v)
        k != "bar"
      }
      assert_equal([['baz', 'BAZ'], ['foo', 'FOO']],
                    ret.sort)
    end

    def test_length
      num = 10
      assert_equal(0, @gdbm.size)
      num.times {|i|
        i = i.to_s
        @gdbm[i] = i
      }
      assert_equal(num, @gdbm.size)

      @gdbm.shift

      assert_equal(num - 1, @gdbm.size)
    end

    def test_empty?
      assert_equal(true, @gdbm.empty?)
      @gdbm['foo'] = 'FOO'
      assert_equal(false, @gdbm.empty?)
    end

    def test_each_pair
      n = 0
      @gdbm.each_pair { n += 1 }
      assert_equal(0, n)

      keys = %w(foo bar baz)
      values = %w(FOO BAR BAZ)

      @gdbm[keys[0]], @gdbm[keys[1]], @gdbm[keys[2]] = values

      n = 0
      ret = @gdbm.each_pair {|key, val|
        assert_not_nil(i = keys.index(key))
        assert_equal(val, values[i])

        n += 1
      }
      assert_equal(keys.size, n)
      assert_equal(@gdbm, ret)
    end

    def test_each_value
      n = 0
      @gdbm.each_value { n += 1 }
      assert_equal(0, n)

      keys = %w(foo bar baz)
      values = %w(FOO BAR BAZ)

      @gdbm[keys[0]], @gdbm[keys[1]], @gdbm[keys[2]] = values

      n = 0
      ret = @gdbm.each_value {|val|
        assert_not_nil(key = @gdbm.index(val))
        assert_not_nil(i = keys.index(key))
        assert_equal(val, values[i])

        n += 1
      }
      assert_equal(keys.size, n)
      assert_equal(@gdbm, ret)
    end

    def test_each_key
      n = 0
      @gdbm.each_key { n += 1 }
      assert_equal(0, n)

      keys = %w(foo bar baz)
      values = %w(FOO BAR BAZ)

      @gdbm[keys[0]], @gdbm[keys[1]], @gdbm[keys[2]] = values

      n = 0
      ret = @gdbm.each_key {|key|
        assert_not_nil(i = keys.index(key))
        assert_equal(@gdbm[key], values[i])

        n += 1
      }
      assert_equal(keys.size, n)
      assert_equal(@gdbm, ret)
    end

    def test_keys
      assert_equal([], @gdbm.keys)

      keys = %w(foo bar baz)
      values = %w(FOO BAR BAZ)

      @gdbm[keys[0]], @gdbm[keys[1]], @gdbm[keys[2]] = values

      assert_equal(keys.sort, @gdbm.keys.sort)
      assert_equal(values.sort, @gdbm.values.sort)
    end

    def test_values
      test_keys
    end

    def test_shift
      assert_nil(@gdbm.shift)
      assert_equal(0, @gdbm.size)

      keys = %w(foo bar baz)
      values = %w(FOO BAR BAZ)

      @gdbm[keys[0]], @gdbm[keys[1]], @gdbm[keys[2]] = values

      ret_keys = []
      ret_values = []
      while ret = @gdbm.shift
        ret_keys.push ret[0]
        ret_values.push ret[1]

        assert_equal(keys.size - ret_keys.size, @gdbm.size)
      end

      assert_equal(keys.sort, ret_keys.sort)
      assert_equal(values.sort, ret_values.sort)
    end

    def test_delete
      keys = %w(foo bar baz)
      values = %w(FOO BAR BAZ)
      key = keys[1]

      assert_nil(@gdbm.delete(key))
      assert_equal(0, @gdbm.size)

      @gdbm[keys[0]], @gdbm[keys[1]], @gdbm[keys[2]] = values

      assert_equal('BAR', @gdbm.delete(key))
      assert_nil(@gdbm[key])
      assert_equal(2, @gdbm.size)

      assert_nil(@gdbm.delete(key))

      if /^CYGWIN_9/ !~ SYSTEM
        assert_raise(GDBMError) {
          @gdbm_rdonly.delete("foo")
        }

        assert_nil(@gdbm_rdonly.delete("bar"))
      end
    end
    def test_delete_with_block
      key = 'no called block'
      @gdbm[key] = 'foo'
      assert_equal('foo', @gdbm.delete(key) {|k| k.replace 'called block'})
      assert_equal('no called block', key)
      assert_equal(0, @gdbm.size)

      key = 'no called block'
      assert_equal(:blockval,
                    @gdbm.delete(key) {|k| k.replace 'called block'; :blockval})
      assert_equal('called block', key)
      assert_equal(0, @gdbm.size)
    end

    def test_delete_if
      v = "0"
      100.times {@gdbm[v] = v; v = v.next}

      ret = @gdbm.delete_if {|key, val| key.to_i < 50}
      assert_equal(@gdbm, ret)
      check_size(50, @gdbm)

      ret = @gdbm.delete_if {|key, val| key.to_i >= 50}
      assert_equal(@gdbm, ret)
      check_size(0, @gdbm)

      # break
      v = "0"
      100.times {@gdbm[v] = v; v = v.next}
      check_size(100, @gdbm)
      n = 0;
      @gdbm.delete_if {|key, val|
        break if n > 50
        n+=1
        true
      }
      assert_equal(51, n)
      check_size(49, @gdbm)

      @gdbm.clear

      # raise
      v = "0"
      100.times {@gdbm[v] = v; v = v.next}
      check_size(100, @gdbm)
      n = 0;
      begin
        @gdbm.delete_if {|key, val|
          raise "runtime error" if n > 50
          n+=1
          true
        }
      rescue
      end
      assert_equal(51, n)
      check_size(49, @gdbm)
    end

    def test_reject
      v = "0"
      100.times {@gdbm[v] = v; v = v.next}

      hash = @gdbm.reject {|key, val| key.to_i < 50}
      assert_instance_of(Hash, hash)
      assert_equal(100, @gdbm.size)

      assert_equal(50, hash.size)
      hash.each_pair {|key,val|
        assert_equal(false, key.to_i < 50)
        assert_equal(key, val)
      }

      hash = @gdbm.reject {|key, val| key.to_i < 100}
      assert_instance_of(Hash, hash)
      assert_equal(true, hash.empty?)
    end

    def test_clear
      v = "1"
      100.times {v = v.next; @gdbm[v] = v}

      assert_equal(@gdbm, @gdbm.clear)

      # validate GDBM#size
      i = 0
      @gdbm.each { i += 1 }
      assert_equal(@gdbm.size, i)
      assert_equal(0, i)
    end

    def test_invert
      v = "0"
      100.times {@gdbm[v] = v; v = v.next}

      hash = @gdbm.invert
      assert_instance_of(Hash, hash)
      assert_equal(100, hash.size)
      hash.each_pair {|key, val|
        assert_equal(key.to_i, val.to_i)
      }
    end

    def test_update
      hash = {}
      v = "0"
      100.times {v = v.next; hash[v] = v}

      @gdbm["101"] = "101"
      @gdbm.update hash
      assert_equal(101, @gdbm.size)
      @gdbm.each_pair {|key, val|
        assert_equal(key.to_i, val.to_i)
      }
    end

    def test_replace
      hash = {}
      v = "0"
      100.times {v = v.next; hash[v] = v}

      @gdbm["101"] = "101"
      @gdbm.replace hash
      assert_equal(100, @gdbm.size)
      @gdbm.each_pair {|key, val|
        assert_equal(key.to_i, val.to_i)
      }
    end

    def test_reorganize
      size1 = File.size(@path)
      i = "1"
      1000.times {i = i.next; @gdbm[i] = i}
      @gdbm.clear
      @gdbm.sync

      size2 = File.size(@path)
      @gdbm.reorganize
      size3 = File.size(@path)

      # p [size1, size2, size3]
      assert_equal(true, size1 < size2)
      # this test is failed on Cygwin98. `GDBM version 1.8.0, as of May 19, 1999'
      assert_equal(true, size3 < size2)
      assert_equal(size1, size3)
    end

    def test_sync
      assert_instance_of(GDBM, gdbm = GDBM.open('tmptest_gdbm', 0666, GDBM::FAST))
      assert_equal(gdbm.sync, gdbm)
      gdbm.close
      assert_instance_of(GDBM, gdbm = GDBM.open('tmptest_gdbm', 0666))
      assert_equal(gdbm.sync, gdbm)
      gdbm.close
    end

    def test_cachesize=
        assert_equal(@gdbm.cachesize = 1024, 1024)
    end

    def test_fastmode=
        assert_equal(@gdbm.fastmode = true, true)
    end

    def test_syncmode=
        assert_equal(@gdbm.syncmode = true, true)
    end

    def test_haskey?
      assert_equal('bar', @gdbm['foo']='bar')
      assert_equal(true,  @gdbm.has_key?('foo'))
      assert_equal(false, @gdbm.has_key?('bar'))
    end

    def test_has_value?
      assert_equal('bar', @gdbm['foo']='bar')
      assert_equal(true,  @gdbm.has_value?('bar'))
      assert_equal(false, @gdbm.has_value?('foo'))
    end

    def test_to_a
      v = "0"
      100.times {v = v.next; @gdbm[v] = v}

      ary = @gdbm.to_a
      assert_instance_of(Array, ary)
      assert_equal(100, ary.size)
      ary.each {|key,val|
        assert_equal(key.to_i, val.to_i)
      }
    end

    def test_to_hash
      v = "0"
      100.times {v = v.next; @gdbm[v] = v}

      hash = @gdbm.to_hash
      assert_instance_of(Hash, hash)
      assert_equal(100, hash.size)
      hash.each {|key,val|
        assert_equal(key.to_i, val.to_i)
      }
    end
  end

  class TestGDBM2 < Test::Unit::TestCase
    TMPROOT = "#{Dir.tmpdir}/ruby-gdbm.#{$$}"

    def setup
      Dir.mkdir TMPROOT
    end

    def teardown
      FileUtils.rm_rf TMPROOT if File.directory?(TMPROOT)
    end

    def test_reader_open
      GDBM.open("#{TMPROOT}/a.dbm") {}
      v = GDBM.open("#{TMPROOT}/a.dbm", nil, GDBM::READER) {|d|
        assert_raises(GDBMError) { d["k"] = "v" }
        true
      }
      assert(v)
    end

    def test_newdb_open
      GDBM.open("#{TMPROOT}/a.dbm") {|dbm|
        dbm["k"] = "v"
      } 
      v = GDBM.open("#{TMPROOT}/a.dbm", nil, GDBM::NEWDB) {|d|
        assert_equal(0, d.length)
        assert_nil(d["k"])
        true
      }
      assert(v)
    end

    def test_freeze
      GDBM.open("#{TMPROOT}/a.dbm") {|d|
        d.freeze
        assert_raises(TypeError) { d["k"] = "v" }
      }
    end
  end
end
require File.expand_path('../../../spec_helper', __FILE__)

describe "Float#eql?" do
  it "returns true if other is a Float equal to self" do
    1.0.should_not eql(1)
    0.0.should eql(0.0)
  end
end
require 'diff/lcs'
require 'diff/lcs/hunk'
require 'pp'

module RSpec
  module Expectations
    class Differ
      def initialize(ignore=nil)
      end

      # This is snagged from diff/lcs/ldiff.rb (which is a commandline tool)
      def diff_as_string(data_new, data_old)
        data_old = data_old.split(/\n/).map! { |e| e.chomp }
        data_new = data_new.split(/\n/).map! { |e| e.chomp }
        output = ""
        diffs = Diff::LCS.diff(data_old, data_new)
        return output if diffs.empty?
        oldhunk = hunk = nil  
        file_length_difference = 0
        diffs.each do |piece|
          begin
            hunk = Diff::LCS::Hunk.new(
              data_old, data_new, piece, context_lines, file_length_difference
            )
            file_length_difference = hunk.file_length_difference      
            next unless oldhunk      
            # Hunks may overlap, which is why we need to be careful when our
            # diff includes lines of context. Otherwise, we might print
            # redundant lines.
            if (context_lines > 0) and hunk.overlaps?(oldhunk)
              hunk.unshift(oldhunk)
            else
              output << oldhunk.diff(format)
            end
          ensure
            oldhunk = hunk
            output << "\n"
          end
        end  
        #Handle the last remaining hunk
        output << oldhunk.diff(format) << "\n"
      end  

      def diff_as_object(actual,expected)
        actual = String === actual ? actual : PP.pp(actual,"")
        expected = String === expected ? expected : PP.pp(expected,"")
        diff_as_string(actual, expected)
      end

    protected

      def format
        :unified
      end

      def context_lines
        3
      end
    end

  end
end
require 'rake/extensioncompiler'
HOST = Rake::ExtensionCompiler.mingw_host
TARGET = 'i386-pc-mingw32'

ZLIB    = 'zlib-1.2.5'
ICONV   = 'libiconv-1.13.1'
LIBXML  = 'libxml2-2.7.7'
LIBXSLT = 'libxslt-1.1.26'
RAKE_COMPILER_PKGCONFIG = File.expand_path(File.join(Dir.pwd, "tmp/cross/lib/pkgconfig/"))

### Build zlib ###
file "tmp/cross/download/#{ZLIB}" do |t|
  FileUtils.mkdir_p('tmp/cross/download')

  file = ZLIB
  url  = "http://zlib.net/#{file}.tar.gz"

  Dir.chdir('tmp/cross/download') do
    sh "wget #{url} || curl -O #{url}"
    sh "tar zxvf #{file}.tar.gz"
  end

  Dir.chdir t.name do
    mk = File.read('win32/Makefile.gcc')
    File.open('win32/Makefile.gcc', 'wb') do |f|
      f.puts "BINARY_PATH = #{CROSS_DIR}/bin"
      f.puts "LIBRARY_PATH = #{CROSS_DIR}/lib"
      f.puts "INCLUDE_PATH = #{CROSS_DIR}/include"

      # FIXME: need to make the cross compiler dynamic
      f.puts mk.sub(/^PREFIX\s*=\s*$/, "PREFIX = #{HOST}-") #.
        #sub(/^SHARED_MODE=0$/, 'SHARED_MODE=1').
        #sub(/^IMPLIB\s*=.*$/, 'IMPLIB=libz.dll.a')
    end
  end
end

file 'tmp/cross/lib/libz.a' => "tmp/cross/download/#{ZLIB}" do |t|
  Dir.chdir t.prerequisites.first do
    sh 'make -f win32/Makefile.gcc'
    sh 'make -f win32/Makefile.gcc install'
  end
end
### End build zlib ###

### Build iconv ###
file "tmp/cross/download/#{ICONV}" do |t|
  FileUtils.mkdir_p('tmp/cross/download')

  file = ICONV
  url  = "http://ftp.gnu.org/pub/gnu/libiconv/#{file}.tar.gz"

  Dir.chdir('tmp/cross/download') do
    sh "wget #{url} || curl -O #{url}"
    sh "tar zxvf #{file}.tar.gz"
  end

  Dir.chdir t.name do
    # FIXME: need to make the host dynamic
    sh "./configure --disable-shared --enable-static --host=#{HOST} --target=#{TARGET} --prefix=#{CROSS_DIR} CPPFLAGS='-mno-cygwin -Wall' CFLAGS='-mno-cygwin -O2 -g' CXXFLAGS='-mno-cygwin -O2 -g' LDFLAGS=-mno-cygwin"
  end
end

file 'tmp/cross/bin/iconv.exe' => "tmp/cross/download/#{ICONV}" do |t|
  Dir.chdir t.prerequisites.first do
    sh 'make'
    sh 'make install'
  end
end
### End build iconv ###

### Build libxml2 ###
file "tmp/cross/download/#{LIBXML}" do |t|
  FileUtils.mkdir_p('tmp/cross/download')

  file = LIBXML
  url  = "ftp://ftp.xmlsoft.org/libxml2/#{file}.tar.gz"

  Dir.chdir('tmp/cross/download') do
    sh "wget #{url} || curl -O #{url}"
    sh "tar zxvf #{file}.tar.gz"
  end

  Dir.chdir t.name do
    # FIXME: need to make the host dynamic
    sh "CFLAGS='-DIN_LIBXML' ./configure --host=#{HOST} --target=#{TARGET} --enable-static --disable-shared --prefix=#{CROSS_DIR} --with-zlib=#{CROSS_DIR} --with-iconv=#{CROSS_DIR} --without-python --without-readline"
  end
end

file 'tmp/cross/bin/xml2-config' => "tmp/cross/download/#{LIBXML}" do |t|
  Dir.chdir t.prerequisites.first do
    sh 'make LDFLAGS="-avoid-version"'
    sh 'make install'
  end
end
### End build libxml2 ###

### Build libxslt ###
file "tmp/cross/download/#{LIBXSLT}" do |t|
  FileUtils.mkdir_p('tmp/cross/download')

  file = LIBXSLT
  url  = "ftp://ftp.xmlsoft.org/libxml2/#{file}.tar.gz"

  Dir.chdir('tmp/cross/download') do
    sh "wget #{url} || curl -O #{url}"
    sh "tar zxvf #{file}.tar.gz"
  end

  Dir.chdir t.name do
    # FIXME: need to make the host dynamic
    sh "CFLAGS='-DIN_LIBXML' ./configure --host=#{HOST} --target=#{TARGET} --enable-static --disable-shared --prefix=#{CROSS_DIR} --with-libxml-prefix=#{CROSS_DIR} --without-python --without-crypto"
  end
end

file 'tmp/cross/bin/xslt-config' => "tmp/cross/download/#{LIBXSLT}" do |t|
  Dir.chdir t.prerequisites.first do
    sh 'make LDFLAGS="-avoid-version"'
    sh 'make install'
  end
end
### End build libxslt ###

file 'lib/nokogiri/nokogiri.rb' => 'cross:check' do
  File.open("lib/#{HOE.name}/#{HOE.name}.rb", 'wb') do |f|
    f.write <<-eoruby
require "#{HOE.name}/\#{RUBY_VERSION.sub(/\\.\\d+$/, '')}/#{HOE.name}"
    eoruby
  end
end

namespace :cross do
  task :iconv   => 'tmp/cross/bin/iconv.exe'
  task :zlib    => 'tmp/cross/lib/libz.a'
  task :libxml2 => ['cross:zlib', 'cross:iconv', 'tmp/cross/bin/xml2-config']
  task :libxslt => ['cross:libxml2', 'tmp/cross/bin/xslt-config']

  task :check => ["cross:libxslt"] do
    unless File.directory?(RAKE_COMPILER_PKGCONFIG)
      raise RuntimeError.new("looks like rake-compiler changed where pkgconfig info is kept. (#{RAKE_COMPILER_PKGCONFIG})")
    end
  end

  task :copy_dlls do
    Dir['tmp/cross/bin/*.dll'].each do |file|
      cp file, "ext/nokogiri"
    end
  end

  task :file_list => 'cross:copy_dlls' do
    HOE.spec.extensions = []
    HOE.spec.files += Dir["lib/#{HOE.name}/#{HOE.name}.rb"]
    HOE.spec.files += Dir["lib/#{HOE.name}/1.{8,9}/#{HOE.name}.so"]
    HOE.spec.files += Dir["ext/nokogiri/*.dll"]
  end
end

CLOBBER.include("lib/nokogiri/nokogiri.{so,dylib,rb,bundle}")
CLOBBER.include("lib/nokogiri/1.{8,9}")
CLOBBER.include("ext/nokogiri/*.dll")

if Rake::Task.task_defined?(:cross)
  Rake::Task[:cross].prerequisites << "lib/nokogiri/nokogiri.rb"
  Rake::Task[:cross].prerequisites << "cross:file_list"
end

desc "build a windows gem without all the ceremony."
task "gem:windows" do
  # check that rake-compiler config contains the right patchlevels of 1.8.6 and 1.9.1
  rake_compiler_config = YAML.load_file("#{ENV['HOME']}/.rake-compiler/config.yml")
  ["1.8.6-p383", "1.9.1-p243"].each do |version|
    majmin, patchlevel = version.split("-")
    rbconfig = "rbconfig-#{majmin}"
    unless rake_compiler_config.key?(rbconfig) && rake_compiler_config[rbconfig] =~ /-#{patchlevel}/
      raise "rake-compiler '#{rbconfig}' not #{patchlevel}. try running 'rake-compiler cross-ruby VERSION=#{version}'"
    end
  end

  system("env PKG_CONFIG_PATH=#{RAKE_COMPILER_PKGCONFIG} RUBY_CC_VERSION=1.8.6:1.9.1 rake cross native gem") || raise("build failed!")
end
require 'rubygems'
require 'rspec'
require 'rspec/autorun'
require 'rack/test'
require 'webmock/rspec'

include Rack::Test::Methods
include WebMock

require 'omniauth/basic'

WebMock.disable_net_connect!
# encoding: utf-8
module Support #:nodoc:
  module Authentication
    extend self

    def configured?
      begin
        master_uri = "mongodb://mongoid:test@localhost:27017/mongoid_test"
        Mongo::Connection.from_uri(master_uri)
        true
      rescue Mongo::AuthenticationError => e
        false
      end
    end

    def message
      %Q{
      ---------------------------------------------------------------------
      A user needs to be configured for authentication, otherwise some
      configuration specs will not get run. You may set it up from the
      mongo console:

        $ use mongoid_test;
        $ db.addUser("mongoid", "test");
      ---------------------------------------------------------------------
      }
    end
  end
end
require File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../fixtures/classes', __FILE__)
require File.expand_path('../shared/length', __FILE__)

describe "StringIO#size" do
  it_behaves_like :stringio_length, :size
end
module TZInfo
  module Definitions
    module Europe
      module Sofia
        include TimezoneDefinition
        
        timezone 'Europe/Sofia' do |tz|
          tz.offset :o0, 5596, 0, :LMT
          tz.offset :o1, 7016, 0, :IMT
          tz.offset :o2, 7200, 0, :EET
          tz.offset :o3, 3600, 0, :CET
          tz.offset :o4, 3600, 3600, :CEST
          tz.offset :o5, 7200, 3600, :EEST
          
          tz.transition 1879, 12, :o1, 52006653401, 21600
          tz.transition 1894, 11, :o2, 26062154123, 10800
          tz.transition 1942, 11, :o3, 58335973, 24
          tz.transition 1943, 3, :o4, 58339501, 24
          tz.transition 1943, 10, :o3, 58344037, 24
          tz.transition 1944, 4, :o4, 58348405, 24
          tz.transition 1944, 10, :o3, 58352773, 24
          tz.transition 1945, 4, :o2, 29178571, 12
          tz.transition 1979, 3, :o5, 291762000
          tz.transition 1979, 9, :o2, 307576800
          tz.transition 1980, 4, :o5, 323816400
          tz.transition 1980, 9, :o2, 339026400
          tz.transition 1981, 4, :o5, 355266000
          tz.transition 1981, 9, :o2, 370393200
          tz.transition 1982, 4, :o5, 386715600
          tz.transition 1982, 9, :o2, 401846400
          tz.transition 1983, 3, :o5, 417571200
          tz.transition 1983, 9, :o2, 433296000
          tz.transition 1984, 3, :o5, 449020800
          tz.transition 1984, 9, :o2, 465350400
          tz.transition 1985, 3, :o5, 481075200
          tz.transition 1985, 9, :o2, 496800000
          tz.transition 1986, 3, :o5, 512524800
          tz.transition 1986, 9, :o2, 528249600
          tz.transition 1987, 3, :o5, 543974400
          tz.transition 1987, 9, :o2, 559699200
          tz.transition 1988, 3, :o5, 575424000
          tz.transition 1988, 9, :o2, 591148800
          tz.transition 1989, 3, :o5, 606873600
          tz.transition 1989, 9, :o2, 622598400
          tz.transition 1990, 3, :o5, 638323200
          tz.transition 1990, 9, :o2, 654652800
          tz.transition 1991, 3, :o5, 670370400
          tz.transition 1991, 9, :o2, 686091600
          tz.transition 1992, 3, :o5, 701820000
          tz.transition 1992, 9, :o2, 717541200
          tz.transition 1993, 3, :o5, 733269600
          tz.transition 1993, 9, :o2, 748990800
          tz.transition 1994, 3, :o5, 764719200
          tz.transition 1994, 9, :o2, 780440400
          tz.transition 1995, 3, :o5, 796168800
          tz.transition 1995, 9, :o2, 811890000
          tz.transition 1996, 3, :o5, 828223200
          tz.transition 1996, 10, :o2, 846363600
          tz.transition 1997, 3, :o5, 859683600
          tz.transition 1997, 10, :o2, 877827600
          tz.transition 1998, 3, :o5, 891133200
          tz.transition 1998, 10, :o2, 909277200
          tz.transition 1999, 3, :o5, 922582800
          tz.transition 1999, 10, :o2, 941331600
          tz.transition 2000, 3, :o5, 954032400
          tz.transition 2000, 10, :o2, 972781200
          tz.transition 2001, 3, :o5, 985482000
          tz.transition 2001, 10, :o2, 1004230800
          tz.transition 2002, 3, :o5, 1017536400
          tz.transition 2002, 10, :o2, 1035680400
          tz.transition 2003, 3, :o5, 1048986000
          tz.transition 2003, 10, :o2, 1067130000
          tz.transition 2004, 3, :o5, 1080435600
          tz.transition 2004, 10, :o2, 1099184400
          tz.transition 2005, 3, :o5, 1111885200
          tz.transition 2005, 10, :o2, 1130634000
          tz.transition 2006, 3, :o5, 1143334800
          tz.transition 2006, 10, :o2, 1162083600
          tz.transition 2007, 3, :o5, 1174784400
          tz.transition 2007, 10, :o2, 1193533200
          tz.transition 2008, 3, :o5, 1206838800
          tz.transition 2008, 10, :o2, 1224982800
          tz.transition 2009, 3, :o5, 1238288400
          tz.transition 2009, 10, :o2, 1256432400
          tz.transition 2010, 3, :o5, 1269738000
          tz.transition 2010, 10, :o2, 1288486800
          tz.transition 2011, 3, :o5, 1301187600
          tz.transition 2011, 10, :o2, 1319936400
          tz.transition 2012, 3, :o5, 1332637200
          tz.transition 2012, 10, :o2, 1351386000
          tz.transition 2013, 3, :o5, 1364691600
          tz.transition 2013, 10, :o2, 1382835600
          tz.transition 2014, 3, :o5, 1396141200
          tz.transition 2014, 10, :o2, 1414285200
          tz.transition 2015, 3, :o5, 1427590800
          tz.transition 2015, 10, :o2, 1445734800
          tz.transition 2016, 3, :o5, 1459040400
          tz.transition 2016, 10, :o2, 1477789200
          tz.transition 2017, 3, :o5, 1490490000
          tz.transition 2017, 10, :o2, 1509238800
          tz.transition 2018, 3, :o5, 1521939600
          tz.transition 2018, 10, :o2, 1540688400
          tz.transition 2019, 3, :o5, 1553994000
          tz.transition 2019, 10, :o2, 1572138000
          tz.transition 2020, 3, :o5, 1585443600
          tz.transition 2020, 10, :o2, 1603587600
          tz.transition 2021, 3, :o5, 1616893200
          tz.transition 2021, 10, :o2, 1635642000
          tz.transition 2022, 3, :o5, 1648342800
          tz.transition 2022, 10, :o2, 1667091600
          tz.transition 2023, 3, :o5, 1679792400
          tz.transition 2023, 10, :o2, 1698541200
          tz.transition 2024, 3, :o5, 1711846800
          tz.transition 2024, 10, :o2, 1729990800
          tz.transition 2025, 3, :o5, 1743296400
          tz.transition 2025, 10, :o2, 1761440400
          tz.transition 2026, 3, :o5, 1774746000
          tz.transition 2026, 10, :o2, 1792890000
          tz.transition 2027, 3, :o5, 1806195600
          tz.transition 2027, 10, :o2, 1824944400
          tz.transition 2028, 3, :o5, 1837645200
          tz.transition 2028, 10, :o2, 1856394000
          tz.transition 2029, 3, :o5, 1869094800
          tz.transition 2029, 10, :o2, 1887843600
          tz.transition 2030, 3, :o5, 1901149200
          tz.transition 2030, 10, :o2, 1919293200
          tz.transition 2031, 3, :o5, 1932598800
          tz.transition 2031, 10, :o2, 1950742800
          tz.transition 2032, 3, :o5, 1964048400
          tz.transition 2032, 10, :o2, 1982797200
          tz.transition 2033, 3, :o5, 1995498000
          tz.transition 2033, 10, :o2, 2014246800
          tz.transition 2034, 3, :o5, 2026947600
          tz.transition 2034, 10, :o2, 2045696400
          tz.transition 2035, 3, :o5, 2058397200
          tz.transition 2035, 10, :o2, 2077146000
          tz.transition 2036, 3, :o5, 2090451600
          tz.transition 2036, 10, :o2, 2108595600
          tz.transition 2037, 3, :o5, 2121901200
          tz.transition 2037, 10, :o2, 2140045200
          tz.transition 2038, 3, :o5, 59172253, 24
          tz.transition 2038, 10, :o2, 59177461, 24
          tz.transition 2039, 3, :o5, 59180989, 24
          tz.transition 2039, 10, :o2, 59186197, 24
          tz.transition 2040, 3, :o5, 59189725, 24
          tz.transition 2040, 10, :o2, 59194933, 24
          tz.transition 2041, 3, :o5, 59198629, 24
          tz.transition 2041, 10, :o2, 59203669, 24
          tz.transition 2042, 3, :o5, 59207365, 24
          tz.transition 2042, 10, :o2, 59212405, 24
          tz.transition 2043, 3, :o5, 59216101, 24
          tz.transition 2043, 10, :o2, 59221141, 24
          tz.transition 2044, 3, :o5, 59224837, 24
          tz.transition 2044, 10, :o2, 59230045, 24
          tz.transition 2045, 3, :o5, 59233573, 24
          tz.transition 2045, 10, :o2, 59238781, 24
          tz.transition 2046, 3, :o5, 59242309, 24
          tz.transition 2046, 10, :o2, 59247517, 24
          tz.transition 2047, 3, :o5, 59251213, 24
          tz.transition 2047, 10, :o2, 59256253, 24
          tz.transition 2048, 3, :o5, 59259949, 24
          tz.transition 2048, 10, :o2, 59264989, 24
          tz.transition 2049, 3, :o5, 59268685, 24
          tz.transition 2049, 10, :o2, 59273893, 24
          tz.transition 2050, 3, :o5, 59277421, 24
          tz.transition 2050, 10, :o2, 59282629, 24
        end
      end
    end
  end
end
require File.expand_path('../../../spec_helper', __FILE__)
require 'bigdecimal'

describe "BigDecimal#floor" do
  before(:each) do
    @one = BigDecimal("1")
    @three = BigDecimal("3")
    @four = BigDecimal("4")
    @zero = BigDecimal("0")
    @mixed = BigDecimal("1.23456789")
    @mixed_big = BigDecimal("1.23456789E100")
    @pos_int = BigDecimal("2E5555")
    @neg_int = BigDecimal("-2E5555")
    @pos_frac = BigDecimal("2E-9999")
    @neg_frac = BigDecimal("-2E-9999")

    @infinity = BigDecimal("Infinity")
    @infinity_neg = BigDecimal("-Infinity")
    @nan = BigDecimal("NaN")
    @zero_pos = BigDecimal("+0")
    @zero_neg = BigDecimal("-0")
  end

  it "returns the greatest integer smaller or equal to self" do
    @pos_int.floor.should == @pos_int
    @neg_int.floor.should == @neg_int
    @pos_frac.floor.should == @zero
    @neg_frac.floor.should == BigDecimal("-1")
    @zero.floor.should == 0
    @zero_pos.floor.should == @zero_pos
    @zero_neg.floor.should == @zero_neg

    BigDecimal('2.3').floor.should == 2
    BigDecimal('2.5').floor.should == 2
    BigDecimal('2.9999').floor.should == 2
    BigDecimal('-2.3').floor.should == -3
    BigDecimal('-2.5').floor.should == -3
    BigDecimal('-2.9999').floor.should == -3
    BigDecimal('0.8').floor.should == 0
    BigDecimal('-0.8').floor.should == -1
  end

  ruby_version_is "" ... "1.9" do
    it "returns the same value, if self is special value" do
      @infinity.floor.should == @infinity
      @infinity_neg.floor.should == @infinity_neg
      @nan.floor.nan?.should == true
    end
  end

  ruby_version_is "1.9" do
    it "raise exception, if self is special value" do
      lambda { @infinity.floor }.should raise_error(FloatDomainError)
      lambda { @infinity_neg.floor }.should raise_error(FloatDomainError)
      lambda { @nan.floor }.should raise_error(FloatDomainError)
    end
  end

  it "returns n digits right of the decimal point if given n > 0" do
    @mixed.floor(1).should == BigDecimal("1.2")
    @mixed.floor(5).should == BigDecimal("1.23456")

    BigDecimal("-0.03").floor(1).should == BigDecimal("-0.1")
    BigDecimal("0.03").floor(1).should == BigDecimal("0")

    BigDecimal("23.45").floor(0).should == BigDecimal('23')
    BigDecimal("23.45").floor(1).should == BigDecimal('23.4')
    BigDecimal("23.45").floor(2).should == BigDecimal('23.45')

    BigDecimal("-23.45").floor(0).should == BigDecimal('-24')
    BigDecimal("-23.45").floor(1).should == BigDecimal('-23.5')
    BigDecimal("-23.45").floor(2).should == BigDecimal('-23.45')

    BigDecimal("2E-10").floor(0).should == @zero
    BigDecimal("2E-10").floor(9).should == @zero
    BigDecimal("2E-10").floor(10).should == BigDecimal('2E-10')
    BigDecimal("2E-10").floor(11).should == BigDecimal('2E-10')

    (1..10).each do |n|
      # 0.3, 0.33, 0.333, etc.
      (@one.div(@three,20)).floor(n).should == BigDecimal("0.#{'3'*n}")
      # 1.3, 1.33, 1.333, etc.
      (@four.div(@three,20)).floor(n).should == BigDecimal("1.#{'3'*n}")
      (BigDecimal('31').div(@three,20)).floor(n).should == BigDecimal("10.#{'3'*n}")
    end
    (1..10).each do |n|
      # -0.4, -0.34, -0.334, etc.
      (-@one.div(@three,20)).floor(n).should == BigDecimal("-0.#{'3'*(n-1)}4")
    end
    (1..10).each do |n|
      (@three.div(@one,20)).floor(n).should == @three
    end
    (1..10).each do |n|
      (-@three.div(@one,20)).floor(n).should == -@three
    end
  end

  it "sets n digits left of the decimal point to 0, if given n < 0" do
    BigDecimal("13345.234").floor(-2).should == BigDecimal("13300.0")
    @mixed_big.floor(-99).should == BigDecimal("0.12E101")
    @mixed_big.floor(-100).should == BigDecimal("0.1E101")
    @mixed_big.floor(-95).should == BigDecimal("0.123456E101")
    (1..10).each do |n|
      BigDecimal('1.8').floor(-n).should == @zero
    end
    BigDecimal("1E10").floor(-30).should == @zero
    BigDecimal("-1E10").floor(-30).should == BigDecimal('-1E30')
  end

end
require File.expand_path('../../../spec_helper', __FILE__)

describe :complex_denominator, :shared => true do
  it "returns the least common multiple denominator of the real and imaginary parts" do
    Complex(3, 4).denominator.should == 1
    Complex(3, bignum_value).denominator.should == 1

    Complex(3, Rational(3,4)).denominator.should == 4

    Complex(Rational(4,8), Rational(3,4)).denominator.should == 4
    Complex(Rational(3,8), Rational(3,4)).denominator.should == 8
  end
end
module VCR
  module Normalizers
    module Body
      def initialize(*args)
        super
        normalize_body
      end

      private

      def normalize_body
        # Ensure that the body is a raw string, in case the string instance
        # has been subclassed or extended with additional instance variables
        # or attributes, so that it is serialized to YAML as a raw string.
        # This is needed for rest-client.  See this ticket for more info:
        # http://github.com/myronmarston/vcr/issues/4
        self.body = case body
          when nil, ''; nil
          else String.new(body)
        end
      end
    end
  end
end
require File.dirname(__FILE__) + '/../spec_helper'
require 'mspec/guards/version'

# The VersionGuard specifies a version of Ruby with a String of
# the form: v = 'major.minor.tiny.patchlevel'.
#
# A VersionGuard instance can be created with a single String,
# which means any version >= each component of v.
# Or, the guard can be created with a Range, a..b, or a...b,
# where a, b are of the same form as v. The meaning of the Range
# is as typically understood: a..b means v >= a and v <= b;
# a...b means v >= a and v < b.

describe VersionGuard, "#ruby_version" do
  before :all do
    @verbose = $VERBOSE
    $VERBOSE = nil
  end

  after :all do
    $VERBOSE = @verbose
  end

  before :each do
    @ruby_version = Object.const_get :RUBY_VERSION
    @ruby_patch = Object.const_get :RUBY_PATCHLEVEL

    Object.const_set :RUBY_VERSION, '1.8.6'
    Object.const_set :RUBY_PATCHLEVEL, 114

    @guard = VersionGuard.new 'x.x.x.x'
  end

  after :each do
    Object.const_set :RUBY_VERSION, @ruby_version
    Object.const_set :RUBY_PATCHLEVEL, @ruby_patch
  end

  it "returns 'RUBY_VERSION.RUBY_PATCHLEVEL'" do
    @guard.ruby_version.should == 10108060114
  end
end

describe VersionGuard, "#match?" do
  before :all do
    @verbose = $VERBOSE
    $VERBOSE = nil
  end

  after :all do
    $VERBOSE = @verbose
  end

  before :each do
    @ruby_version = Object.const_get :RUBY_VERSION
    @ruby_patch = Object.const_get :RUBY_PATCHLEVEL

    Object.const_set :RUBY_VERSION, '1.8.6'
    Object.const_set :RUBY_PATCHLEVEL, 114
  end

  after :each do
    Object.const_set :RUBY_VERSION, @ruby_version
    Object.const_set :RUBY_PATCHLEVEL, @ruby_patch
  end

  it "returns true when the argument is equal to RUBY_VERSION and RUBY_PATCHLEVEL" do
    VersionGuard.new('1.8.6.114').match?.should == true
  end

  it "returns true when the argument is less than RUBY_VERSION and RUBY_PATCHLEVEL" do
    VersionGuard.new('1.8').match?.should == true
    VersionGuard.new('1.8.5').match?.should == true
  end

  it "returns false when the argument is greater than RUBY_VERSION and RUBY_PATCHLEVEL" do
    VersionGuard.new('1.8.7').match?.should == false
    VersionGuard.new('1.8.7.000').match?.should == false
    VersionGuard.new('1.8.7.10').match?.should == false
  end

  it "returns true when the argument range includes RUBY_VERSION and RUBY_PATCHLEVEL" do
    VersionGuard.new('1.8.5'..'1.8.7.111').match?.should == true
    VersionGuard.new('1.8'..'1.9').match?.should == true
    VersionGuard.new('1.8'...'1.9').match?.should == true
    VersionGuard.new('1.8'..'1.8.6.114').match?.should == true
    VersionGuard.new('1.8'...'1.8.6.115').match?.should == true
  end

  it "returns false when the argument range does not include RUBY_VERSION and RUBY_PATCHLEVEL" do
    VersionGuard.new('1.8.7'..'1.8.9').match?.should == false
    VersionGuard.new('1.8.4'..'1.8.5').match?.should == false
    VersionGuard.new('1.8.5'..'1.8.6.113').match?.should == false
    VersionGuard.new('1.8.4'...'1.8.6').match?.should == false
    VersionGuard.new('1.8.5'...'1.8.6.114').match?.should == false
  end
end

describe Object, "#ruby_version_is" do
  before :each do
    @guard = VersionGuard.new 'x.x.x.x'
    VersionGuard.stub!(:new).and_return(@guard)
    ScratchPad.clear
  end

  it "yields when #match? returns true" do
    @guard.stub!(:match?).and_return(true)
    ruby_version_is('x.x.x.x') { ScratchPad.record :yield }
    ScratchPad.recorded.should == :yield
  end

  it "does not yield when #match? returns false" do
    @guard.stub!(:match?).and_return(false)
    ruby_version_is('x.x.x.x') { ScratchPad.record :yield }
    ScratchPad.recorded.should_not == :yield
  end

  it "sets the name of the guard to :ruby_version_is" do
    ruby_version_is("") { }
    @guard.name.should == :ruby_version_is
  end

  it "calls #unregister even when an exception is raised in the guard block" do
    @guard.should_receive(:match?).and_return(true)
    @guard.should_receive(:unregister)
    lambda do
      ruby_version_is("") { raise Exception }
    end.should raise_error(Exception)
  end
end
#!/usr/bin/env ruby
require 'tk'
require 'tkextlib/iwidgets'

cb = Tk::Iwidgets::Checkbox.new
cb.add('bold',      :text=>'Bold')
cb.add('italic',    :text=>'Italic')
cb.add('underline', :text=>'Underline')
cb.select('underline')
cb.pack(:expand=>true, :fill=>:both, :padx=>10, :pady=>10)

Tk.mainloop
describe :file_writable_real, :shared => true do
  before :each do
    @file = tmp('i_exist')
  end

  after :each do
    rm_r @file
  end

  it "returns true if named file is writable by the real user id of the process, otherwise false" do
    File.open(@file,'w') { @object.send(@method, @file).should == true }
  end

  ruby_version_is "1.9" do
    it "accepts an object that has a #to_path method" do
      File.open(@file,'w') { @object.send(@method, mock_to_path(@file)).should == true }
    end
  end

  it "raises an ArgumentError if not passed one argument" do
    lambda { File.writable_real?        }.should raise_error(ArgumentError)
  end

  it "raises a TypeError if not passed a String type" do
    lambda { @object.send(@method, 1)     }.should raise_error(TypeError)
    lambda { @object.send(@method, nil)   }.should raise_error(TypeError)
    lambda { @object.send(@method, false) }.should raise_error(TypeError)
  end
end

describe :file_writable_real_missing, :shared => true do
  it "returns false if the file does not exist" do
    @object.send(@method, 'fake_file').should == false
  end
end
require File.expand_path('../../../../../spec_helper', __FILE__)
require 'net/http'

describe "Net::HTTPResponse#message" do
  it "returns self's response message" do
    res = Net::HTTPUnknownResponse.new("1.0", "???", "test response")
    res.message.should == "test response"
  end
end
module RSpec
  module Core
    module ObjectExtensions
      def describe(*args, &example_group_block)
        args << {} unless args.last.is_a?(Hash)
        RSpec::Core::ExampleGroup.describe(*args, &example_group_block).register
      end
    end
  end
end

class Object
  include RSpec::Core::ObjectExtensions
end
shared_examples_for "an http stubbing adapter" do |supported_http_libraries, supported_request_match_attributes, *other|
  before(:each) { VCR.stub!(:http_stubbing_adapter).and_return(subject) }
  subject { described_class }

  describe '.set_http_connections_allowed_to_default' do
    [true, false].each do |default|
      context "when VCR::Config.allow_http_connections_when_no_cassette is #{default}" do
        before(:each) { VCR::Config.allow_http_connections_when_no_cassette = default }

        it "sets http_connections_allowed to #{default}" do
          subject.http_connections_allowed = !default
          expect {
            subject.set_http_connections_allowed_to_default
          }.to change { subject.http_connections_allowed? }.from(!default).to(default)
        end
      end
    end
  end

  describe '.exclusively_enabled' do
    def adapter_enabled?(adapter)
      enabled = nil
      subject.exclusively_enabled { enabled = adapter.enabled? }
      enabled
    end

    VCR::HttpStubbingAdapters::Common.adapters.each do |adapter|
      if adapter == described_class
        it "yields with #{adapter} enabled" do
          adapter_enabled?(adapter).should == true
        end
      else
        it "yields without #{adapter} enabled" do
          adapter_enabled?(adapter).should == false
        end
      end
    end

    it 're-enables all adapters afterwards' do
      VCR::HttpStubbingAdapters::Common.adapters.each { |a| a.should be_enabled }
      subject.exclusively_enabled { }
      VCR::HttpStubbingAdapters::Common.adapters.each { |a| a.should be_enabled }
    end
  end

  describe '.stub_requests' do
    let(:request)     { VCR::Request.new(:get, 'http://example.com/') }
    let(:status)      { VCR::ResponseStatus.new(200, 'OK') }
    let(:response)    { VCR::Response.new(status) }
    let(:interaction) { VCR::HTTPInteraction.new(request, response) }

    it 'works when the request and response has no headers' do
      expect {
        subject.stub_requests([interaction], [:method, :uri])
      }.not_to raise_error
    end
  end

  if other.include?(:needs_net_http_extension)
    describe '.request_uri' do
      it 'returns the uri for the given http request' do
        net_http = Net::HTTP.new('example.com', 80)
        request = Net::HTTP::Get.new('/foo/bar')
        subject.request_uri(net_http, request).should == 'http://example.com:80/foo/bar'
      end

      it 'handles basic auth' do
        net_http = Net::HTTP.new('example.com',80)
        request = Net::HTTP::Get.new('/auth.txt')
        request.basic_auth 'user', 'pass'
        subject.request_uri(net_http, request).should == 'http://user:pass@example.com:80/auth.txt'
      end
    end

    describe '.request_stubbed? using specific match_attributes' do
      let(:interactions) { VCR::YAML.load_file(File.join(VCR::SPEC_ROOT, 'fixtures', YAML_SERIALIZATION_VERSION, 'match_requests_on.yml')) }

      @supported_request_match_attributes = supported_request_match_attributes
      def self.matching_on(attribute, valid1, valid2, invalid, &block)
        supported_request_match_attributes = @supported_request_match_attributes

        describe ":#{attribute}" do
          if supported_request_match_attributes.include?(attribute)
            before(:each) { subject.stub_requests(interactions, [attribute]) }
            module_eval(&block)

            [valid1, valid2].each do |val|
              it "returns true for a #{val.inspect} request" do
                subject.request_stubbed?(request(val), [attribute]).should == true
              end
            end

            it "returns false for another #{attribute}"  do
              subject.request_stubbed?(request(invalid), [attribute]).should == false
            end
          else
            it 'raises an error indicating matching requests on this attribute is not supported' do
              expect { subject.request_stubbed?(VCR::Request.new, [attribute]) }.to raise_error(/does not support matching requests on #{attribute}/)
            end
          end
        end
      end

      matching_on :method, :get, :post, :put do
        def request(http_method)
          VCR::Request.new(http_method, 'http://some-wrong-domain.com/', nil, {})
        end
      end

      matching_on :host, 'example1.com', 'example2.com', 'example3.com' do
        def request(host)
          VCR::Request.new(:get, "http://#{host}/some/wrong/path", nil, {})
        end
      end

      matching_on :uri, 'http://example.com/uri1', 'http://example.com/uri2', 'http://example.com/uri3' do
        def request(uri)
          VCR::Request.new(:get, uri, nil, {})
        end
      end

      matching_on :path, '/path1', '/path2', '/path3' do
        def request(path)
          VCR::Request.new(:get, "http://example.com#{path}", nil, {})
        end
      end

      matching_on :body, 'param=val1', 'param=val2', 'param=val3' do
        def request(body)
          VCR::Request.new(:put, "http://wrong-domain.com/wrong/path", body, {})
        end
      end

      matching_on :headers, { 'X-HTTP-HEADER1' => 'val1' }, { 'X-HTTP-HEADER1' => 'val2' }, { 'X-HTTP-HEADER1' => 'val3' } do
        def request(headers)
          VCR::Request.new(:get, "http://wrong-domain.com/wrong/path", nil, headers)
        end
      end
    end
  end

  supported_http_libraries.each do |library|
    it_behaves_like 'an http library', library, supported_request_match_attributes, *other
  end
end

require_relative 'test_base'
require 'dl/func'

module DL
  class TestFunc < TestBase
    def test_name
      f = Function.new(CFunc.new(@libc['strcpy'], TYPE_VOIDP, 'strcpy'),
                       [TYPE_VOIDP, TYPE_VOIDP])
      assert_equal 'strcpy', f.name
    end

    def test_to_i
      cfunc = CFunc.new(@libc['strcpy'], TYPE_VOIDP, 'strcpy')
      f = Function.new(cfunc, [TYPE_VOIDP, TYPE_VOIDP])
      assert_equal cfunc.to_i, f.to_i
    end

    def test_random
      f = Function.new(CFunc.new(@libc['srand'], TYPE_VOID, 'srand'),
                       [-TYPE_LONG])
      assert_nil f.call(10)
    end

    def test_sinf
      begin
        f = Function.new(CFunc.new(@libm['sinf'], TYPE_FLOAT, 'sinf'),
                         [TYPE_FLOAT])
      rescue DL::DLError
        skip "libm may not have sinf()"
      end
      assert_in_delta 1.0, f.call(90 * Math::PI / 180), 0.0001
    end

    def test_sin
      f = Function.new(CFunc.new(@libm['sin'], TYPE_DOUBLE, 'sin'),
                       [TYPE_DOUBLE])
      assert_in_delta 1.0, f.call(90 * Math::PI / 180), 0.0001
    end

    def test_strcpy()
      f = Function.new(CFunc.new(@libc['strcpy'], TYPE_VOIDP, 'strcpy'),
                       [TYPE_VOIDP, TYPE_VOIDP])
      buff = "000"
      str = f.call(buff, "123")
      assert_equal("123", buff)
      assert_equal("123", str.to_s)
    end

    def test_string()
      stress, GC.stress = GC.stress, true
      f = Function.new(CFunc.new(@libc['strcpy'], TYPE_VOIDP, 'strcpy'),
                       [TYPE_VOIDP, TYPE_VOIDP])
      buff = "000"
      str = f.call(buff, "123")
      assert_equal("123", buff)
      assert_equal("123", str.to_s)
    ensure
      GC.stress = stress
    end   

    def test_isdigit()
      f = Function.new(CFunc.new(@libc['isdigit'], TYPE_INT, 'isdigit'),
                       [TYPE_INT])
      r1 = f.call(?1.ord)
      r2 = f.call(?2.ord)
      rr = f.call(?r.ord)
      assert_positive(r1)
      assert_positive(r2)
      assert_zero(rr)
    end

    def test_atof()
      f = Function.new(CFunc.new(@libc['atof'], TYPE_DOUBLE, 'atof'),
                       [TYPE_VOIDP])
      r = f.call("12.34")
      assert_match(12.00..13.00, r)
    end

    def test_strtod()
      f = Function.new(CFunc.new(@libc['strtod'], TYPE_DOUBLE, 'strtod'),
                       [TYPE_VOIDP, TYPE_VOIDP])
      buff1 = CPtr["12.34"]
      buff2 = buff1 + 4
      r = f.call(buff1, - buff2)
      assert_in_delta(12.34, r, 0.001)
    end

    def test_qsort1()
      cb = Function.new(CFunc.new(0, TYPE_INT, '<callback>qsort'),
                        [TYPE_VOIDP, TYPE_VOIDP]){|x,y| CPtr.new(x)[0] <=> CPtr.new(y)[0]}
      qsort = Function.new(CFunc.new(@libc['qsort'], TYPE_VOID, 'qsort'),
                           [TYPE_VOIDP, TYPE_INT, TYPE_INT, TYPE_VOIDP])
      buff = "9341"
      qsort.call(buff, buff.size, 1, cb)
      assert_equal("1349", buff)
    end

    def test_qsort2()
      cb = TempFunction.new(CFunc.new(0, TYPE_INT, '<callback>qsort'),
                               [TYPE_VOIDP, TYPE_VOIDP])
      qsort = Function.new(CFunc.new(@libc['qsort'], TYPE_VOID, 'qsort'),
                           [TYPE_VOIDP, TYPE_INT, TYPE_INT, TYPE_VOIDP])
      buff = "9341"
      qsort.call(buff, buff.size, 1, cb){|x,y| CPtr.new(x)[0] <=> CPtr.new(y)[0]}
      assert_equal("1349", buff)
    end
  end
end
#!/usr/bin/env ruby
#--
# Copyright 2004, 2005 by Jim Weirich (jim@weirichhouse.org).
# All rights reserved.

# Permission is granted for use, copying, modification, distribution,
# and distribution of modified versions of this work as long as the
# above copyright notice is included.
#++

# Provide a flexible and easy to use Builder for creating XML markup.
# See XmlBuilder for usage details.

require 'builder/xmlbase'

module Builder

  # Create XML markup easily.  All (well, almost all) methods sent to
  # an XmlMarkup object will be translated to the equivalent XML
  # markup.  Any method with a block will be treated as an XML markup
  # tag with nested markup in the block.
  #
  # Examples will demonstrate this easier than words.  In the
  # following, +xm+ is an +XmlMarkup+ object.
  #
  #   xm.em("emphasized")             # => <em>emphasized</em>
  #   xm.em { xmm.b("emp & bold") }   # => <em><b>emph &amp; bold</b></em>
  #   xm.a("A Link", "href"=>"http://onestepback.org")
  #                                   # => <a href="http://onestepback.org">A Link</a>
  #   xm.div { br }                    # => <div><br/></div>
  #   xm.target("name"=>"compile", "option"=>"fast")
  #                                   # => <target option="fast" name="compile"\>
  #                                   # NOTE: order of attributes is not specified.
  #
  #   xm.instruct!                   # <?xml version="1.0" encoding="UTF-8"?>
  #   xm.html {                      # <html>
  #     xm.head {                    #   <head>
  #       xm.title("History")        #     <title>History</title>
  #     }                            #   </head>
  #     xm.body {                    #   <body>
  #       xm.comment! "HI"           #     <!-- HI -->
  #       xm.h1("Header")            #     <h1>Header</h1>
  #       xm.p("paragraph")          #     <p>paragraph</p>
  #     }                            #   </body>
  #   }                              # </html>
  #
  # == Notes:
  #
  # * The order that attributes are inserted in markup tags is
  #   undefined. 
  #
  # * Sometimes you wish to insert text without enclosing tags.  Use
  #   the <tt>text!</tt> method to accomplish this.
  #
  #   Example:
  #
  #     xm.div {                          # <div>
  #       xm.text! "line"; xm.br          #   line<br/>
  #       xm.text! "another line"; xmbr   #    another line<br/>
  #     }                                 # </div>
  #
  # * The special XML characters <, >, and & are converted to &lt;,
  #   &gt; and &amp; automatically.  Use the <tt><<</tt> operation to
  #   insert text without modification.
  #
  # * Sometimes tags use special characters not allowed in ruby
  #   identifiers.  Use the <tt>tag!</tt> method to handle these
  #   cases.
  #
  #   Example:
  #
  #     xml.tag!("SOAP:Envelope") { ... }
  #
  #   will produce ...
  #
  #     <SOAP:Envelope> ... </SOAP:Envelope>"
  #
  #   <tt>tag!</tt> will also take text and attribute arguments (after
  #   the tag name) like normal markup methods.  (But see the next
  #   bullet item for a better way to handle XML namespaces).
  #   
  # * Direct support for XML namespaces is now available.  If the
  #   first argument to a tag call is a symbol, it will be joined to
  #   the tag to produce a namespace:tag combination.  It is easier to
  #   show this than describe it.
  #
  #     xml.SOAP :Envelope do ... end
  #
  #   Just put a space before the colon in a namespace to produce the
  #   right form for builder (e.g. "<tt>SOAP:Envelope</tt>" =>
  #   "<tt>xml.SOAP :Envelope</tt>")
  #
  # * XmlMarkup builds the markup in any object (called a _target_)
  #   that accepts the <tt><<</tt> method.  If no target is given,
  #   then XmlMarkup defaults to a string target.
  # 
  #   Examples:
  #
  #     xm = Builder::XmlMarkup.new
  #     result = xm.title("yada")
  #     # result is a string containing the markup.
  #
  #     buffer = ""
  #     xm = Builder::XmlMarkup.new(buffer)
  #     # The markup is appended to buffer (using <<)
  #
  #     xm = Builder::XmlMarkup.new(STDOUT)
  #     # The markup is written to STDOUT (using <<)
  #
  #     xm = Builder::XmlMarkup.new
  #     x2 = Builder::XmlMarkup.new(:target=>xm)
  #     # Markup written to +x2+ will be send to +xm+.
  #   
  # * Indentation is enabled by providing the number of spaces to
  #   indent for each level as a second argument to XmlBuilder.new.
  #   Initial indentation may be specified using a third parameter.
  #
  #   Example:
  #
  #     xm = Builder.new(:indent=>2)
  #     # xm will produce nicely formatted and indented XML.
  #  
  #     xm = Builder.new(:indent=>2, :margin=>4)
  #     # xm will produce nicely formatted and indented XML with 2
  #     # spaces per indent and an over all indentation level of 4.
  #
  #     builder = Builder::XmlMarkup.new(:target=>$stdout, :indent=>2)
  #     builder.name { |b| b.first("Jim"); b.last("Weirich) }
  #     # prints:
  #     #     <name>
  #     #       <first>Jim</first>
  #     #       <last>Weirich</last>
  #     #     </name>
  #
  # * The instance_eval implementation which forces self to refer to
  #   the message receiver as self is now obsolete.  We now use normal
  #   block calls to execute the markup block.  This means that all
  #   markup methods must now be explicitly send to the xml builder.
  #   For instance, instead of
  #
  #      xml.div { strong("text") }
  #
  #   you need to write:
  #
  #      xml.div { xml.strong("text") }
  #
  #   Although more verbose, the subtle change in semantics within the
  #   block was found to be prone to error.  To make this change a
  #   little less cumbersome, the markup block now gets the markup
  #   object sent as an argument, allowing you to use a shorter alias
  #   within the block.
  #
  #   For example:
  #
  #     xml_builder = Builder::XmlMarkup.new
  #     xml_builder.div { |xml|
  #       xml.stong("text")
  #     }
  #
  class XmlMarkup < XmlBase

    # Create an XML markup builder.  Parameters are specified by an
    # option hash.
    #
    # :target=><em>target_object</em>::
    #    Object receiving the markup.  +out+ must respond to the
    #    <tt><<</tt> operator.  The default is a plain string target.
    #    
    # :indent=><em>indentation</em>::
    #    Number of spaces used for indentation.  The default is no
    #    indentation and no line breaks.
    #    
    # :margin=><em>initial_indentation_level</em>::
    #    Amount of initial indentation (specified in levels, not
    #    spaces).
    #    
    # :escape_attrs=><b>OBSOLETE</em>::
    #    The :escape_attrs option is no longer supported by builder
    #    (and will be quietly ignored).  String attribute values are
    #    now automatically escaped.  If you need unescaped attribute
    #    values (perhaps you are using entities in the attribute
    #    values), then give the value as a Symbol.  This allows much
    #    finer control over escaping attribute values.
    #    
    def initialize(options={})
      indent = options[:indent] || 0
      margin = options[:margin] || 0
      super(indent, margin)
      @target = options[:target] || ""
    end
    
    # Return the target of the builder.
    def target!
      @target
    end

    def comment!(comment_text)
      _ensure_no_block block_given?
      _special("<!-- ", " -->", comment_text, nil)
    end

    # Insert an XML declaration into the XML markup.
    #
    # For example:
    #
    #   xml.declare! :ELEMENT, :blah, "yada"
    #       # => <!ELEMENT blah "yada">
    def declare!(inst, *args, &block)
      _indent
      @target << "<!#{inst}"
      args.each do |arg|
        case arg
        when String
          @target << %{ "#{arg}"} # " WART
        when Symbol
          @target << " #{arg}"
        end
      end
      if block_given?
        @target << " ["
        _newline
        _nested_structures(block)
        @target << "]"
      end
      @target << ">"
      _newline
    end

    # Insert a processing instruction into the XML markup.  E.g.
    #
    # For example:
    #
    #    xml.instruct!
    #        #=> <?xml version="1.0" encoding="UTF-8"?>
    #    xml.instruct! :aaa, :bbb=>"ccc"
    #        #=> <?aaa bbb="ccc"?>
    #
    def instruct!(directive_tag=:xml, attrs={})
      _ensure_no_block block_given?
      if directive_tag == :xml
        a = { :version=>"1.0", :encoding=>"UTF-8" }
        attrs = a.merge attrs
      end
      _special(
      "<?#{directive_tag}",
      "?>",
      nil,
      attrs,
      [:version, :encoding, :standalone])
    end

    # Insert a CDATA section into the XML markup.
    #
    # For example:
    #
    #    xml.cdata!("text to be included in cdata")
    #        #=> <![CDATA[text to be included in cdata]]>
    #
    def cdata!(text)
      _ensure_no_block block_given?
      _special("<![CDATA[", "]]>", text, nil)
    end
    
    private

    # NOTE: All private methods of a builder object are prefixed when
    # a "_" character to avoid possible conflict with XML tag names.

    # Insert text directly in to the builder's target.
    def _text(text)
      @target << text
    end
    
    # Insert special instruction. 
    def _special(open, close, data=nil, attrs=nil, order=[])
      _indent
      @target << open
      @target << data if data
      _insert_attributes(attrs, order) if attrs
      @target << close
      _newline
    end

    # Start an XML tag.  If <tt>end_too</tt> is true, then the start
    # tag is also the end tag (e.g.  <br/>
    def _start_tag(sym, attrs, end_too=false)
      @target << "<#{sym}"
      _insert_attributes(attrs)
      @target << "/" if end_too
      @target << ">"
    end
    
    # Insert an ending tag.
    def _end_tag(sym)
      @target << "</#{sym}>"
    end

    # Insert the attributes (given in the hash).
    def _insert_attributes(attrs, order=[])
      return if attrs.nil?
      order.each do |k|
        v = attrs[k]
        @target << %{ #{k}="#{_attr_value(v)}"} if v # " WART
      end
      attrs.each do |k, v|
        @target << %{ #{k}="#{_attr_value(v)}"} unless order.member?(k) # " WART
      end
    end

    def _attr_value(value)
      case value
      when Symbol
        value.to_s
      else
        _escape_quote(value.to_s)
      end
    end

    def _ensure_no_block(got_block)
      if got_block
        fail IllegalBlockError,
        "Blocks are not allowed on XML instructions"
      end
    end

  end

end
require File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../fixtures/source_location', __FILE__)

ruby_version_is "1.9" do
  describe "Proc#source_location" do
    before(:each) do
      @proc = ProcSpecs::SourceLocation.my_proc
      @lambda = ProcSpecs::SourceLocation.my_lambda
      @proc_new = ProcSpecs::SourceLocation.my_proc_new
    end

    it "returns an Array" do
      @proc.source_location.should be_an_instance_of(Array)
      @proc_new.source_location.should be_an_instance_of(Array)
      @lambda.source_location.should be_an_instance_of(Array)
    end

    it "sets the first value to the path of the file in which the proc was defined" do
      file = @proc.source_location.first
      file.should be_an_instance_of(String)
      file.should == File.dirname(__FILE__) + '/fixtures/source_location.rb'

      file = @proc_new.source_location.first
      file.should be_an_instance_of(String)
      file.should == File.dirname(__FILE__) + '/fixtures/source_location.rb'

      file = @lambda.source_location.first
      file.should be_an_instance_of(String)
      file.should == File.dirname(__FILE__) + '/fixtures/source_location.rb'
    end

    it "sets the last value to a Fixnum representing the line on which the proc was defined" do
      line = @proc.source_location.last
      line.should be_an_instance_of(Fixnum)
      line.should == 4

      line = @proc_new.source_location.last
      line.should be_an_instance_of(Fixnum)
      line.should == 12

      line = @lambda.source_location.last
      line.should be_an_instance_of(Fixnum)
      line.should == 8
    end

    it "works even if the proc was created on the same line" do
      proc { true }.source_location.should == [__FILE__, __LINE__]
      Proc.new { true }.source_location.should == [__FILE__, __LINE__]
      lambda { true }.source_location.should == [__FILE__, __LINE__]
    end

    it "returns the first line of a multi-line proc (i.e. the line containing 'proc do')" do
      ProcSpecs::SourceLocation.my_multiline_proc.source_location.last.should == 16
      ProcSpecs::SourceLocation.my_multiline_proc_new.source_location.last.should == 30
      ProcSpecs::SourceLocation.my_multiline_lambda.source_location.last.should == 23
    end

    it "returns the location of the proc's body; not necessarily the proc itself" do
      ProcSpecs::SourceLocation.my_detached_proc.source_location.last.should == 37
      ProcSpecs::SourceLocation.my_detached_proc_new.source_location.last.should == 47
      ProcSpecs::SourceLocation.my_detached_lambda.source_location.last.should == 42
    end
  end
end
# -----------------------------------------------------------------------------
# 
# A container file for one-off tests
# 
# -----------------------------------------------------------------------------
# Copyright 2010 Daniel Azuma
# 
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# * Neither the name of the copyright holder, nor the names of any other
#   contributors to this software, may be used to endorse or promote products
#   derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# -----------------------------------------------------------------------------
;


require 'test/unit'
require 'rgeo'


module RGeo
  module Tests  # :nodoc:
    
    class TestOneOff < ::Test::Unit::TestCase  # :nodoc:
      
      
      def setup
        # @mercator_factory = ::RGeo::Geographic.simple_mercator_factory
        # @spherical_factory = ::RGeo::Geographic.spherical_factory(:has_z_coordinate => true)
        # @projected_factory = ::RGeo::Geographic.projected_factory(:projection_proj4 => '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs', :projection_srid => 3857, :has_z_coordinate => true)
        # @geos_factory = ::RGeo::Geos.factory(:srid => 4326, :has_z_coordinate => true)
        # @cartesian_factory = ::RGeo::Cartesian.simple_factory(:srid => 1, :has_z_coordinate => true)
      end
      
      
      def test_dummy
      end
      
      
    end
    
  end
end
require 'rdoc'

module RDoc::RI

  class Error < RDoc::Error; end

end

#
#  tentry widget
#                               by Hidetoshi NAGAI (nagai@ai.kyutech.ac.jp)
#
require 'tk'
require 'tkextlib/tile.rb'

module Tk
  module Tile
    class TEntry < Tk::Entry
    end
    Entry = TEntry
  end
end

class Tk::Tile::TEntry < Tk::Entry
  include Tk::Tile::TileWidget

  if Tk::Tile::USE_TTK_NAMESPACE
    TkCommandNames = ['::ttk::entry'.freeze].freeze
  else
    TkCommandNames = ['::tentry'.freeze].freeze
  end
  WidgetClassName = 'TEntry'.freeze
  WidgetClassNames[WidgetClassName] ||= self

  def __optkey_aliases
    {:vcmd=>:validatecommand, :invcmd=>:invalidcommand}
  end
  private :__optkey_aliases

  def __boolval_optkeys
    super() << 'exportselection'
  end
  private :__boolval_optkeys

  def __strval_optkeys
    super() << 'show'
  end
  private :__strval_optkeys

  def self.style(*args)
    [self::WidgetClassName, *(args.map!{|a| _get_eval_string(a)})].join('.')
  end
end

#Tk.__set_toplevel_aliases__(:Ttk, Tk::Tile::Entry, :TkEntry)
Tk.__set_loaded_toplevel_aliases__('tkextlib/tile/tentry.rb',
                                   :Ttk, Tk::Tile::Entry, :TkEntry)
require 'oauth/request_proxy/base'
require 'uri'
require 'rack'

module OAuth::RequestProxy
  class RackRequest < OAuth::RequestProxy::Base
    proxies Rack::Request

    def method
      request.env["rack.methodoverride.original_method"] || request.request_method
    end

    def uri
      request.url
    end

    def parameters
      if options[:clobber_request]
        options[:parameters] || {}
      else
        params = request_params.merge(query_params).merge(header_params)
        params.merge(options[:parameters] || {})
      end
    end

    def signature
      parameters['oauth_signature']
    end

  protected

    def query_params
      request.GET
    end

    def request_params
      request.POST
    end
  end
end
require "childprocess"
require "tmpdir"
require "fileutils"
require "date"
require 'base64'

have_lib = lambda { |lib|
  begin
    require lib
    true
  rescue LoadError
    false
  end
}

unless have_lib["yajl/json_gem"] || have_lib["json"]
  raise LoadError, <<-END

       You need to require rubygems or install one of these gems:

           yajl-ruby (best on MRI)
           json
           json-jruby (native JRuby)
           json_pure (any platform)

  END
end

require "selenium/webdriver/common"

module Selenium
  module WebDriver
    Point     = Struct.new(:x, :y)
    Dimension = Struct.new(:width, :height)

    autoload :Android, 'selenium/webdriver/android'
    autoload :Chrome,  'selenium/webdriver/chrome'
    autoload :IE,      'selenium/webdriver/ie'
    autoload :IPhone,  'selenium/webdriver/iphone'
    autoload :Remote,  'selenium/webdriver/remote'
    autoload :Firefox, 'selenium/webdriver/firefox'

    # @api private

    def self.root
      @root ||= File.expand_path(File.join(File.dirname(__FILE__), ".."))
    end

    #
    # Create a new Driver instance with the correct bridge for the given browser
    #
    # @param browser [:ie, :internet_explorer, :remote, :chrome, :firefox, :ff, :android, :iphone]
    #   the driver type to use
    # @param *rest
    #   arguments passed to Bridge.new
    #
    # @return [Driver]
    #
    # @see Selenium::WebDriver::Remote::Bridge
    # @see Selenium::WebDriver::Firefox::Bridge
    # @see Selenium::WebDriver::IE::Bridge
    # @see Selenium::WebDriver::Chrome::Bridge
    # @see Selenium::WebDriver::Android::Bridge
    # @see Selenium::WebDriver::IPhone::Bridge
    #
    # @example
    #
    #   WebDriver.for :firefox, :profile => "some-profile"
    #   WebDriver.for :firefox, :profile => Profile.new
    #   WebDriver.for :remote,  :url => "http://localhost:4444/wd/hub", :desired_capabilities => caps
    #

    def self.for(*args)
      WebDriver::Driver.for(*args)
    end

  end # WebDriver
end # Selenium

Thread.abort_on_exception = true
require 'autotest/cucumber_mixin'
require 'autotest/rails_rspec'

class Autotest::CucumberRailsRspec < Autotest::RailsRspec
  include CucumberMixin
end
module EventMachine
  module Protocols
    # Implements the Memcache protocol (http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt).
    # Requires memcached >= 1.2.4 w/ noreply support
    #
    # == Usage example
    #
    #   EM.run{
    #     cache = EM::P::Memcache.connect 'localhost', 11211
    #
    #     cache.set :a, 'hello'
    #     cache.set :b, 'hi'
    #     cache.set :c, 'how are you?'
    #     cache.set :d, ''
    #
    #     cache.get(:a){ |v| p v }
    #     cache.get_hash(:a, :b, :c, :d){ |v| p v }
    #     cache.get(:a,:b,:c,:d){ |a,b,c,d| p [a,b,c,d] }
    #
    #     cache.get(:a,:z,:b,:y,:d){ |a,z,b,y,d| p [a,z,b,y,d] }
    #
    #     cache.get(:missing){ |m| p [:missing=, m] }
    #     cache.set(:missing, 'abc'){ p :stored }
    #     cache.get(:missing){ |m| p [:missing=, m] }
    #     cache.del(:missing){ p :deleted }
    #     cache.get(:missing){ |m| p [:missing=, m] }
    #   }
    #
    module Memcache
      include EM::Deferrable

      ##
      # constants

      # :stopdoc:
      unless defined? Cempty
        Cstored    = 'STORED'.freeze
        Cend       = 'END'.freeze
        Cdeleted   = 'DELETED'.freeze
        Cunknown   = 'NOT_FOUND'.freeze
        Cerror     = 'ERROR'.freeze

        Cempty     = ''.freeze
        Cdelimiter = "\r\n".freeze
      end
      # :startdoc:

      ##
      # commands

      # Get the value associated with one or multiple keys
      #
      #  cache.get(:a){ |v| p v }
      #  cache.get(:a,:b,:c,:d){ |a,b,c,d| p [a,b,c,d] }
      #
      def get *keys
        raise ArgumentError unless block_given?

        callback{
          keys = keys.map{|k| k.to_s.gsub(/\s/,'_') }
          send_data "get #{keys.join(' ')}\r\n"
          @get_cbs << [keys, proc{ |values|
            yield *keys.map{ |k| values[k] }
          }]
        }
      end

      # Set the value for a given key
      #
      #  cache.set :a, 'hello'
      #  cache.set(:missing, 'abc'){ puts "stored the value!" }
      #
      def set key, val, exptime = 0, &cb
        callback{
          val = val.to_s
          send_cmd :set, key, 0, exptime, val.respond_to?(:bytesize) ? val.bytesize : val.size, !block_given?
          send_data val
          send_data Cdelimiter
          @set_cbs << cb if cb
        }
      end

      # Gets multiple values as a hash
      #
      #  cache.get_hash(:a, :b, :c, :d){ |h| puts h[:a] }
      #
      def get_hash *keys
        raise ArgumentError unless block_given?

        get *keys do |*values|
          yield keys.inject({}){ |hash, k| hash.update k => values[keys.index(k)] }
        end
      end

      # Delete the value associated with a key
      #
      #  cache.del :a
      #  cache.del(:b){ puts "deleted the value!" }
      #
      def delete key, expires = 0, &cb
        callback{
          send_data "delete #{key} #{expires}#{cb ? '' : ' noreply'}\r\n"
          @del_cbs << cb if cb
        }
      end
      alias del delete

      # Connect to a memcached server (must support NOREPLY, memcached >= 1.2.4)
      def self.connect host = 'localhost', port = 11211
        EM.connect host, port, self, host, port
      end

      # :stopdoc:

      def send_cmd cmd, key, flags = 0, exptime = 0, bytes = 0, noreply = false # :nodoc:
        send_data "#{cmd} #{key} #{flags} #{exptime} #{bytes}#{noreply ? ' noreply' : ''}\r\n"
      end
      private :send_cmd

      ##
      # errors

      class ParserError < StandardError
      end

      ##
      # em hooks

      def initialize host, port = 11211
        @host, @port = host, port
      end

      def connection_completed
        @get_cbs = []
        @set_cbs = []
        @del_cbs = []

        @values = {}

        @reconnecting = false
        @connected = true
        succeed
        # set_delimiter "\r\n"
        # set_line_mode
      end

      #--
      # 19Feb09 Switched to a custom parser, LineText2 is recursive and can cause
      #         stack overflows when there is too much data.
      # include EM::P::LineText2
      def receive_data data
        (@buffer||='') << data

        while index = @buffer.index(Cdelimiter)
          begin
            line = @buffer.slice!(0,index+2)
            process_cmd line
          rescue ParserError
            @buffer[0...0] = line
            break
          end
        end
      end

      #--
      # def receive_line line
      def process_cmd line
        case line.strip
        when /^VALUE\s+(.+?)\s+(\d+)\s+(\d+)/ # VALUE <key> <flags> <bytes>
          bytes = Integer($3)
          # set_binary_mode bytes+2
          # @cur_key = $1
          if @buffer.size >= bytes + 2
            @values[$1] = @buffer.slice!(0,bytes)
            @buffer.slice!(0,2) # \r\n
          else
            raise ParserError
          end

        when Cend # END
          if entry = @get_cbs.shift
            keys, cb = entry
            cb.call(@values)
          end
          @values = {}

        when Cstored # STORED
          if cb = @set_cbs.shift
            cb.call(true)
          end

        when Cdeleted # DELETED
          if cb = @del_cbs.shift
            cb.call(true)
          end

        when Cunknown # NOT_FOUND
          if cb = @del_cbs.shift
            cb.call(false)
          end

        else
          p [:MEMCACHE_UNKNOWN, line]
        end
      end

      #--
      # def receive_binary_data data
      #   @values[@cur_key] = data[0..-3]
      # end

      def unbind
        if @connected or @reconnecting
          EM.add_timer(1){ reconnect @host, @port }
          @connected = false
          @reconnecting = true
          @deferred_status = nil
        else
          raise 'Unable to connect to memcached server'
        end
      end

      # :startdoc:
    end
  end
end

if __FILE__ == $0
  # ruby -I ext:lib -r eventmachine -rubygems lib/protocols/memcache.rb
  require 'em/spec'

  class TestConnection # :nodoc:
    include EM::P::Memcache
    def send_data data
      sent_data << data
    end
    def sent_data
      @sent_data ||= ''
    end

    def initialize
      connection_completed
    end
  end

  EM.describe EM::Protocols::Memcache do

    before{
      @c = TestConnection.new
    }

    should 'send get requests' do
      @c.get('a'){}
      @c.sent_data.should == "get a\r\n"
      done
    end

    should 'send set requests' do
      @c.set('a', 1){}
      @c.sent_data.should == "set a 0 0 1\r\n1\r\n"
      done
    end

    should 'use noreply on set without block' do
      @c.set('a', 1)
      @c.sent_data.should == "set a 0 0 1 noreply\r\n1\r\n"
      done
    end

    should 'send delete requests' do
      @c.del('a')
      @c.sent_data.should == "delete a 0 noreply\r\n"
      done
    end

    should 'work when get returns no values' do
      @c.get('a'){ |a|
        a.should.be.nil
        done
      }

      @c.receive_data "END\r\n"
    end

    should 'invoke block on set' do
      @c.set('a', 1){
        done
      }

      @c.receive_data "STORED\r\n"
    end

    should 'invoke block on delete' do
      @c.delete('a'){ |found|
        found.should.be.false
      }
      @c.delete('b'){ |found|
        found.should.be.true
        done
      }

      @c.receive_data "NOT_FOUND\r\n"
      @c.receive_data "DELETED\r\n"
    end

    should 'parse split responses' do
      @c.get('a'){ |a|
        a.should == 'abc'
        done
      }

      @c.receive_data "VAL"
      @c.receive_data "UE a 0 "
      @c.receive_data "3\r\n"
      @c.receive_data "ab"
      @c.receive_data "c"
      @c.receive_data "\r\n"
      @c.receive_data "EN"
      @c.receive_data "D\r\n"
    end

  end
end#!/usr/bin/env ruby -w
# encoding: UTF-8

# tc_serialization.rb
#
#  Created by James Edward Gray II on 2005-10-31.
#  Copyright 2005 James Edward Gray II. You can redistribute or modify this code
#  under the terms of Ruby's license.

require "test/unit"

require "csv"

# An example of how to provide custom CSV serialization.
class Hash
  def self.csv_load( meta, headers, fields )
    self[*headers.zip(fields).to_a.flatten.map { |e| eval(e) }]
  end

  def csv_headers
    keys.map { |key| key.inspect }
  end

  def csv_dump( headers )
    headers.map { |header| fetch(eval(header)).inspect }
  end
end

class TestSerialization < Test::Unit::TestCase

  ### Classes Used to Test Serialization ###

  class ReadOnlyName
    def initialize( first, last )
      @first, @last = first, last
    end

    attr_reader :first, :last

    def ==( other )
      %w{first last}.all? { |att| send(att) == other.send(att) }
    end
  end

  Name = Struct.new(:first, :last)

  class FullName < Name
    def initialize( first, last, suffix = nil )
      super(first, last)

      @suffix = suffix
    end

    attr_accessor :suffix

    def ==( other )
      %w{first last suffix}.all? { |att| send(att) == other.send(att) }
    end
  end

  ### Tests ###

  def test_class_dump
    @names = [ %w{James Gray},
              %w{Dana Gray},
              %w{Greg Brown} ].map do |first, last|
      ReadOnlyName.new(first, last)
    end

    assert_nothing_raised(Exception) do
      @data = CSV.dump(@names)
    end
    assert_equal(<<-END_CLASS_DUMP.gsub(/^\s*/, ""), @data)
    class,TestSerialization::ReadOnlyName
    @first,@last
    James,Gray
    Dana,Gray
    Greg,Brown
    END_CLASS_DUMP
  end

  def test_struct_dump
    @names = [ %w{James Gray},
              %w{Dana Gray},
              %w{Greg Brown} ].map do |first, last|
      Name.new(first, last)
    end

    assert_nothing_raised(Exception) do
      @data = CSV.dump(@names)
    end
    assert_equal(<<-END_STRUCT_DUMP.gsub(/^\s*/, ""), @data)
    class,TestSerialization::Name
    first=,last=
    James,Gray
    Dana,Gray
    Greg,Brown
    END_STRUCT_DUMP
  end

  def test_inherited_struct_dump
    @names = [ %w{James Gray II},
              %w{Dana Gray},
              %w{Greg Brown} ].map do |first, last, suffix|
      FullName.new(first, last, suffix)
    end

    assert_nothing_raised(Exception) do
      @data = CSV.dump(@names)
    end
    assert_equal(<<-END_STRUCT_DUMP.gsub(/^\s*/, ""), @data)
    class,TestSerialization::FullName
    @suffix,first=,last=
    II,James,Gray
    ,Dana,Gray
    ,Greg,Brown
    END_STRUCT_DUMP
  end

  def test_load
    %w{ test_class_dump
        test_struct_dump
        test_inherited_struct_dump }.each do |test|
      send(test)
      CSV.load(@data).each do |loaded|
        assert_instance_of(@names.first.class, loaded)
        assert_equal(@names.shift, loaded)
      end
    end
  end

  def test_io
    test_class_dump

    data_file = File.join(File.dirname(__FILE__), "temp_test_data.csv")
    CSV.dump(@names, File.open(data_file, "wb"))

    assert(File.exist?(data_file))
    assert_equal(<<-END_IO_DUMP.gsub(/^\s*/, ""), File.read(data_file))
    class,TestSerialization::ReadOnlyName
    @first,@last
    James,Gray
    Dana,Gray
    Greg,Brown
    END_IO_DUMP

    assert_equal(@names, CSV.load(File.open(data_file)))

    File.unlink(data_file)
  end

  def test_custom_dump_and_load
    obj = {1 => "simple", test: Hash}
    assert_equal(obj, CSV.load(CSV.dump([obj])).first)
  end
end
require 'net/ssh/buffer'
require 'net/ssh/loggable'
require 'net/ssh/ruby_compat'

module Net; module SSH

  # This module is used to extend sockets and other IO objects, to allow
  # them to be buffered for both read and write. This abstraction makes it
  # quite easy to write a select-based event loop
  # (see Net::SSH::Connection::Session#listen_to).
  #
  # The general idea is that instead of calling #read directly on an IO that
  # has been extended with this module, you call #fill (to add pending input
  # to the internal read buffer), and then #read_available (to read from that
  # buffer). Likewise, you don't call #write directly, you call #enqueue to
  # add data to the write buffer, and then #send_pending or #wait_for_pending_sends
  # to actually send the data across the wire.
  #
  # In this way you can easily use the object as an argument to IO.select,
  # calling #fill when it is available for read, or #send_pending when it is
  # available for write, and then call #enqueue and #read_available during
  # the idle times.
  #
  #   socket = TCPSocket.new(address, port)
  #   socket.extend(Net::SSH::BufferedIo)
  #
  #   ssh.listen_to(socket)
  #
  #   ssh.loop do
  #     if socket.available > 0
  #       puts socket.read_available
  #       socket.enqueue("response\n")
  #     end
  #   end
  #
  # Note that this module must be used to extend an instance, and should not
  # be included in a class. If you do want to use it via an include, then you
  # must make sure to invoke the private #initialize_buffered_io method in
  # your class' #initialize method:
  #
  #   class Foo < IO
  #     include Net::SSH::BufferedIo
  #
  #     def initialize
  #       initialize_buffered_io
  #       # ...
  #     end
  #   end
  module BufferedIo
    include Loggable

    # Called when the #extend is called on an object, with this module as the
    # argument. It ensures that the modules instance variables are all properly
    # initialized.
    def self.extended(object) #:nodoc:
      # need to use __send__ because #send is overridden in Socket
      object.__send__(:initialize_buffered_io)
    end

    # Tries to read up to +n+ bytes of data from the remote end, and appends
    # the data to the input buffer. It returns the number of bytes read, or 0
    # if no data was available to be read.
    def fill(n=8192)
      input.consume!
      data = recv(n)
      debug { "read #{data.length} bytes" }
      input.append(data)
      return data.length
    end

    # Read up to +length+ bytes from the input buffer. If +length+ is nil,
    # all available data is read from the buffer. (See #available.)
    def read_available(length=nil)
      input.read(length || available)
    end

    # Returns the number of bytes available to be read from the input buffer.
    # (See #read_available.)
    def available
      input.available
    end

    # Enqueues data in the output buffer, to be written when #send_pending
    # is called. Note that the data is _not_ sent immediately by this method!
    def enqueue(data)
      output.append(data)
    end

    # Returns +true+ if there is data waiting in the output buffer, and
    # +false+ otherwise.
    def pending_write?
      output.length > 0
    end

    # Sends as much of the pending output as possible. Returns +true+ if any
    # data was sent, and +false+ otherwise.
    def send_pending
      if output.length > 0
        sent = send(output.to_s, 0)
        debug { "sent #{sent} bytes" }
        output.consume!(sent)
        return sent > 0
      else
        return false
      end
    end

    # Calls #send_pending repeatedly, if necessary, blocking until the output
    # buffer is empty.
    def wait_for_pending_sends
      send_pending
      while output.length > 0
        result = Net::SSH::Compat.io_select(nil, [self]) or next
        next unless result[1].any?
        send_pending
      end
    end

    public # these methods are primarily for use in tests

      def write_buffer #:nodoc:
        output.to_s
      end

      def read_buffer #:nodoc:
        input.to_s
      end

    private

      #--
      # Can't use attr_reader here (after +private+) without incurring the
      # wrath of "ruby -w". We hates it.
      #++

      def input; @input; end
      def output; @output; end

      # Initializes the intput and output buffers for this object. This method
      # is called automatically when the module is mixed into an object via
      # Object#extend (see Net::SSH::BufferedIo.extended), but must be called
      # explicitly in the +initialize+ method of any class that uses
      # Module#include to add this module.
      def initialize_buffered_io
        @input = Net::SSH::Buffer.new
        @output = Net::SSH::Buffer.new
      end
  end


  
  # Fixes for two issues by Miklós Fazekas:
  #
  #   * if client closes a forwarded connection, but the server is 
  #     reading, net-ssh terminates with IOError socket closed.
  #   * if client force closes (RST) a forwarded connection, but 
  #     server is reading, net-ssh terminates with [an exception]
  #
  # See: 
  # 
  #    http://net-ssh.lighthouseapp.com/projects/36253/tickets/7
  #    http://github.com/net-ssh/net-ssh/tree/portfwfix
  #
  module ForwardedBufferedIo
    def fill(n=8192)
      begin
        super(n)
      rescue Errno::ECONNRESET => e
        debug { "connection was reset => shallowing exception:#{e}" }
        return 0
      rescue IOError => e                                 
        if e.message =~ /closed/ then 
          debug { "connection was reset => shallowing exception:#{e}" }
          return 0
        else
          raise
        end 
      end
    end
    
    def send_pending
      begin
        super                                                          
      rescue Errno::ECONNRESET => e
        debug { "connection was reset => shallowing exception:#{e}" }
        return 0
      rescue IOError => e
        if e.message =~ /closed/ then 
          debug { "connection was reset => shallowing exception:#{e}" }
          return 0
        else
          raise
        end
      end
    end
  end
  
end; end
require "helper"

module Nokogiri
  module XML
    class Node
      class TestSaveOptions < Nokogiri::TestCase
        SaveOptions.constants.each do |constant|
          class_eval %{
            def test_predicate_#{constant.downcase}
              options = SaveOptions.new(SaveOptions::#{constant})
              assert options.#{constant.downcase}?

              assert SaveOptions.new.#{constant.downcase}.#{constant.downcase}?
            end
          }
        end
      end
    end
  end
end
# encoding: utf-8
#--
# Addressable, Copyright (c) 2006-2007 Bob Aman
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#++

require "addressable/uri"

if !"".respond_to?("force_encoding")
  class String
    def force_encoding(encoding)
      @encoding = encoding
    end

    def encoding
      @encoding ||= Encoding::ASCII_8BIT
    end
  end

  class Encoding
    def initialize(name)
      @name = name
    end

    def to_s
      return @name
    end

    UTF_8 = Encoding.new("UTF-8")
    ASCII_8BIT = Encoding.new("US-ASCII")
  end
end

module URI
  class HTTP
    def initialize(uri)
      @uri = uri
    end

    def to_s
      return @uri.to_s
    end
  end
end

describe Addressable::URI, "when created with a non-numeric port number" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.new(:port => "bogus")
    end).should raise_error(Addressable::URI::InvalidURIError)
  end
end

describe Addressable::URI, "when created with a non-string scheme" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.new(:scheme => :bogus)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when created with a non-string user" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.new(:user => :bogus)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when created with a non-string password" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.new(:password => :bogus)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when created with a non-string userinfo" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.new(:userinfo => :bogus)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when created with a non-string host" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.new(:host => :bogus)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when created with a non-string authority" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.new(:authority => :bogus)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when created with a non-string authority" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.new(:authority => :bogus)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when created with a non-string path" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.new(:path => :bogus)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when created with a non-string query" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.new(:query => :bogus)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when created with a non-string fragment" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.new(:fragment => :bogus)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when created with a scheme but no hierarchical " +
    "segment" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.parse("http:")
    end).should raise_error(Addressable::URI::InvalidURIError)
  end
end

describe Addressable::URI, "when created from nil components" do
  before do
    @uri = Addressable::URI.new
  end

  it "should have a nil site value" do
    @uri.site.should == nil
  end

  it "should have an empty path" do
    @uri.path.should == ""
  end

  it "should be an empty uri" do
    @uri.to_s.should == ""
  end

  it "should raise an error if the scheme is set to whitespace" do
    (lambda do
      @uri.scheme = "\t \n"
    end).should raise_error(Addressable::URI::InvalidURIError)
  end

  it "should raise an error if the scheme is set to all digits" do
    (lambda do
      @uri.scheme = "123"
    end).should raise_error(Addressable::URI::InvalidURIError)
  end

  it "should raise an error if set into an invalid state" do
    (lambda do
      @uri.user = "user"
    end).should raise_error(Addressable::URI::InvalidURIError)
  end

  it "should raise an error if set into an invalid state" do
    (lambda do
      @uri.password = "pass"
    end).should raise_error(Addressable::URI::InvalidURIError)
  end

  it "should raise an error if set into an invalid state" do
    (lambda do
      @uri.scheme = "http"
      @uri.fragment = "fragment"
    end).should raise_error(Addressable::URI::InvalidURIError)
  end

  it "should raise an error if set into an invalid state" do
    (lambda do
      @uri.fragment = "fragment"
      @uri.scheme = "http"
    end).should raise_error(Addressable::URI::InvalidURIError)
  end
end

describe Addressable::URI, "when created from string components" do
  before do
    @uri = Addressable::URI.new(
      :scheme => "http", :host => "example.com"
    )
  end

  it "should have a site value of 'http://example.com'" do
    @uri.site.should == "http://example.com"
  end

  it "should be equal to the equivalent parsed URI" do
    @uri.should == Addressable::URI.parse("http://example.com")
  end

  it "should raise an error if invalid components omitted" do
    (lambda do
      @uri.omit(:bogus)
    end).should raise_error(ArgumentError)
    (lambda do
      @uri.omit(:scheme, :bogus, :path)
    end).should raise_error(ArgumentError)
  end
end

describe Addressable::URI, "when created with a nil host but " +
    "non-nil authority components" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.new(:user => "user", :password => "pass", :port => 80)
    end).should raise_error(Addressable::URI::InvalidURIError)
  end
end

describe Addressable::URI, "when created with both an authority and a user" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.new(
        :user => "user", :authority => "user@example.com:80"
      )
    end).should raise_error(ArgumentError)
  end
end

describe Addressable::URI, "when created with an authority and no port" do
  before do
    @uri = Addressable::URI.new(:authority => "user@example.com")
  end

  it "should not infer a port" do
    @uri.port.should == nil
    @uri.inferred_port.should == nil
  end

  it "should have a site value of '//user@example.com'" do
    @uri.site.should == "//user@example.com"
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

describe Addressable::URI, "when created with both a userinfo and a user" do
  it "should raise an error" do
    (lambda do
      Addressable::URI.new(:user => "user", :userinfo => "user:pass")
    end).should raise_error(ArgumentError)
  end
end

describe Addressable::URI, "when created with a path that hasn't been " +
    "prefixed with a '/' but a host specified" do
  before do
    @uri = Addressable::URI.new(
      :scheme => "http", :host => "example.com", :path => "path"
    )
  end

  it "should prefix a '/' to the path" do
    @uri.should == Addressable::URI.parse("http://example.com/path")
  end

  it "should have a site value of 'http://example.com'" do
    @uri.site.should == "http://example.com"
  end

  it "should have an origin of 'http://example.com" do
    @uri.origin.should == 'http://example.com'
  end
end

describe Addressable::URI, "when created with a path that hasn't been " +
    "prefixed with a '/' but no host specified" do
  before do
    @uri = Addressable::URI.new(
      :scheme => "http", :path => "path"
    )
  end

  it "should not prefix a '/' to the path" do
    @uri.should == Addressable::URI.parse("http:path")
  end

  it "should have a site value of 'http:'" do
    @uri.site.should == "http:"
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

describe Addressable::URI, "when parsed from an Addressable::URI object" do
  it "should return the object" do
    uri = Addressable::URI.parse("http://example.com/")
    (lambda do
      Addressable::URI.parse(uri).object_id.should == uri.object_id
    end).should_not raise_error
  end

  it "should return the object" do
    uri = Addressable::URI.parse("http://example.com/")
    (lambda do
      Addressable::URI.heuristic_parse(uri).object_id.should == uri.object_id
    end).should_not raise_error
  end
end

describe Addressable::URI, "when parsed from something that looks " +
    "like a URI object" do
  it "should parse without error" do
    uri = Addressable::URI.parse(URI::HTTP.new("http://example.com/"))
    (lambda do
      Addressable::URI.parse(uri)
    end).should_not raise_error
  end
end

describe Addressable::URI, "when parsed from ''" do
  before do
    @uri = Addressable::URI.parse("")
  end

  it "should have no scheme" do
    @uri.scheme.should == nil
  end

  it "should not be considered to be ip-based" do
    @uri.should_not be_ip_based
  end

  it "should have a path of ''" do
    @uri.path.should == ""
  end

  it "should have a request URI of '/'" do
    @uri.request_uri.should == "/"
  end

  it "should be considered relative" do
    @uri.should be_relative
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

# Section 1.1.2 of RFC 3986
describe Addressable::URI, "when parsed from " +
    "'ftp://ftp.is.co.za/rfc/rfc1808.txt'" do
  before do
    @uri = Addressable::URI.parse("ftp://ftp.is.co.za/rfc/rfc1808.txt")
  end

  it "should use the 'ftp' scheme" do
    @uri.scheme.should == "ftp"
  end

  it "should be considered to be ip-based" do
    @uri.should be_ip_based
  end

  it "should have a host of 'ftp.is.co.za'" do
    @uri.host.should == "ftp.is.co.za"
  end

  it "should have a path of '/rfc/rfc1808.txt'" do
    @uri.path.should == "/rfc/rfc1808.txt"
  end

  it "should not have a request URI" do
    @uri.request_uri.should == nil
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should have an origin of 'ftp://ftp.is.co.za'" do
    @uri.origin.should == 'ftp://ftp.is.co.za'
  end
end

# Section 1.1.2 of RFC 3986
describe Addressable::URI, "when parsed from " +
    "'http://www.ietf.org/rfc/rfc2396.txt'" do
  before do
    @uri = Addressable::URI.parse("http://www.ietf.org/rfc/rfc2396.txt")
  end

  it "should use the 'http' scheme" do
    @uri.scheme.should == "http"
  end

  it "should be considered to be ip-based" do
    @uri.should be_ip_based
  end

  it "should have a host of 'www.ietf.org'" do
    @uri.host.should == "www.ietf.org"
  end

  it "should have a path of '/rfc/rfc2396.txt'" do
    @uri.path.should == "/rfc/rfc2396.txt"
  end

  it "should have a request URI of '/rfc/rfc2396.txt'" do
    @uri.request_uri.should == "/rfc/rfc2396.txt"
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should correctly omit components" do
    @uri.omit(:scheme).to_s.should == "//www.ietf.org/rfc/rfc2396.txt"
    @uri.omit(:path).to_s.should == "http://www.ietf.org"
  end

  it "should correctly omit components destructively" do
    @uri.omit!(:scheme)
    @uri.to_s.should == "//www.ietf.org/rfc/rfc2396.txt"
  end

  it "should have an origin of 'http://www.ietf.org'" do
    @uri.origin.should == 'http://www.ietf.org'
  end
end

# Section 1.1.2 of RFC 3986
describe Addressable::URI, "when parsed from " +
    "'ldap://[2001:db8::7]/c=GB?objectClass?one'" do
  before do
    @uri = Addressable::URI.parse("ldap://[2001:db8::7]/c=GB?objectClass?one")
  end

  it "should use the 'ldap' scheme" do
    @uri.scheme.should == "ldap"
  end

  it "should be considered to be ip-based" do
    @uri.should be_ip_based
  end

  it "should have a host of '[2001:db8::7]'" do
    @uri.host.should == "[2001:db8::7]"
  end

  it "should have a path of '/c=GB'" do
    @uri.path.should == "/c=GB"
  end

  it "should not have a request URI" do
    @uri.request_uri.should == nil
  end

  it "should not allow request URI assignment" do
    (lambda do
      @uri.request_uri = "/"
    end).should raise_error(Addressable::URI::InvalidURIError)
  end

  it "should have a query of 'objectClass?one'" do
    @uri.query.should == "objectClass?one"
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should correctly omit components" do
    @uri.omit(:scheme, :authority).to_s.should == "/c=GB?objectClass?one"
    @uri.omit(:path).to_s.should == "ldap://[2001:db8::7]?objectClass?one"
  end

  it "should correctly omit components destructively" do
    @uri.omit!(:scheme, :authority)
    @uri.to_s.should == "/c=GB?objectClass?one"
  end

  it "should raise an error if omission would create an invalid URI" do
    (lambda do
      @uri.omit(:authority, :path)
    end).should raise_error(Addressable::URI::InvalidURIError)
  end

  it "should have an origin of 'ldap://[2001:db8::7]'" do
    @uri.origin.should == 'ldap://[2001:db8::7]'
  end
end

# Section 1.1.2 of RFC 3986
describe Addressable::URI, "when parsed from " +
    "'mailto:John.Doe@example.com'" do
  before do
    @uri = Addressable::URI.parse("mailto:John.Doe@example.com")
  end

  it "should use the 'mailto' scheme" do
    @uri.scheme.should == "mailto"
  end

  it "should not be considered to be ip-based" do
    @uri.should_not be_ip_based
  end

  it "should have a path of 'John.Doe@example.com'" do
    @uri.path.should == "John.Doe@example.com"
  end

  it "should not have a request URI" do
    @uri.request_uri.should == nil
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

# Section 1.1.2 of RFC 3986
describe Addressable::URI, "when parsed from " +
    "'news:comp.infosystems.www.servers.unix'" do
  before do
    @uri = Addressable::URI.parse("news:comp.infosystems.www.servers.unix")
  end

  it "should use the 'news' scheme" do
    @uri.scheme.should == "news"
  end

  it "should not be considered to be ip-based" do
    @uri.should_not be_ip_based
  end

  it "should have a path of 'comp.infosystems.www.servers.unix'" do
    @uri.path.should == "comp.infosystems.www.servers.unix"
  end

  it "should not have a request URI" do
    @uri.request_uri.should == nil
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

# Section 1.1.2 of RFC 3986
describe Addressable::URI, "when parsed from " +
    "'tel:+1-816-555-1212'" do
  before do
    @uri = Addressable::URI.parse("tel:+1-816-555-1212")
  end

  it "should use the 'tel' scheme" do
    @uri.scheme.should == "tel"
  end

  it "should not be considered to be ip-based" do
    @uri.should_not be_ip_based
  end

  it "should have a path of '+1-816-555-1212'" do
    @uri.path.should == "+1-816-555-1212"
  end

  it "should not have a request URI" do
    @uri.request_uri.should == nil
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

# Section 1.1.2 of RFC 3986
describe Addressable::URI, "when parsed from " +
    "'telnet://192.0.2.16:80/'" do
  before do
    @uri = Addressable::URI.parse("telnet://192.0.2.16:80/")
  end

  it "should use the 'telnet' scheme" do
    @uri.scheme.should == "telnet"
  end

  it "should have a host of '192.0.2.16'" do
    @uri.host.should == "192.0.2.16"
  end

  it "should have a port of '80'" do
    @uri.port.should == 80
  end

  it "should be considered to be ip-based" do
    @uri.should be_ip_based
  end

  it "should have a path of '/'" do
    @uri.path.should == "/"
  end

  it "should not have a request URI" do
    @uri.request_uri.should == nil
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should have an origin of 'telnet://192.0.2.16:80'" do
    @uri.origin.should == 'telnet://192.0.2.16:80'
  end
end

# Section 1.1.2 of RFC 3986
describe Addressable::URI, "when parsed from " +
    "'urn:oasis:names:specification:docbook:dtd:xml:4.1.2'" do
  before do
    @uri = Addressable::URI.parse(
      "urn:oasis:names:specification:docbook:dtd:xml:4.1.2")
  end

  it "should use the 'urn' scheme" do
    @uri.scheme.should == "urn"
  end

  it "should not be considered to be ip-based" do
    @uri.should_not be_ip_based
  end

  it "should have a path of " +
      "'oasis:names:specification:docbook:dtd:xml:4.1.2'" do
    @uri.path.should == "oasis:names:specification:docbook:dtd:xml:4.1.2"
  end

  it "should not have a request URI" do
    @uri.request_uri.should == nil
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com'" do
  before do
    @uri = Addressable::URI.parse("http://example.com")
  end

  it "when inspected, should have the correct URI" do
    @uri.inspect.should include("http://example.com")
  end

  it "when inspected, should have the correct class name" do
    @uri.inspect.should include("Addressable::URI")
  end

  it "when inspected, should have the correct object id" do
    @uri.inspect.should include("%#0x" % @uri.object_id)
  end

  it "should use the 'http' scheme" do
    @uri.scheme.should == "http"
  end

  it "should be considered to be ip-based" do
    @uri.should be_ip_based
  end

  it "should have an authority segment of 'example.com'" do
    @uri.authority.should == "example.com"
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should be considered ip-based" do
    @uri.should be_ip_based
  end

  it "should have no username" do
    @uri.user.should == nil
  end

  it "should have no password" do
    @uri.password.should == nil
  end

  it "should use port 80" do
    @uri.inferred_port.should == 80
  end

  it "should not have a specified port" do
    @uri.port.should == nil
  end

  it "should have an empty path" do
    @uri.path.should == ""
  end

  it "should have no query string" do
    @uri.query.should == nil
    @uri.query_values.should == nil
  end

  it "should have a request URI of '/'" do
    @uri.request_uri.should == "/"
  end

  it "should have no fragment" do
    @uri.fragment.should == nil
  end

  it "should be considered absolute" do
    @uri.should be_absolute
  end

  it "should not be considered relative" do
    @uri.should_not be_relative
  end

  it "should not be exactly equal to 42" do
    @uri.eql?(42).should == false
  end

  it "should not be equal to 42" do
    (@uri == 42).should == false
  end

  it "should not be roughly equal to 42" do
    (@uri === 42).should == false
  end

  it "should be exactly equal to http://example.com" do
    @uri.eql?(Addressable::URI.parse("http://example.com")).should == true
  end

  it "should be roughly equal to http://example.com/" do
    (@uri === Addressable::URI.parse("http://example.com/")).should == true
  end

  it "should be roughly equal to the string 'http://example.com/'" do
    (@uri === "http://example.com/").should == true
  end

  it "should not be roughly equal to the string " +
      "'http://example.com:bogus/'" do
    (lambda do
      (@uri === "http://example.com:bogus/").should == false
    end).should_not raise_error
  end

  it "should result in itself when joined with itself" do
    @uri.join(@uri).to_s.should == "http://example.com"
    @uri.join!(@uri).to_s.should == "http://example.com"
  end

  it "should be equivalent to http://EXAMPLE.com" do
    @uri.should == Addressable::URI.parse("http://EXAMPLE.com")
  end

  it "should be equivalent to http://EXAMPLE.com:80/" do
    @uri.should == Addressable::URI.parse("http://EXAMPLE.com:80/")
  end

  it "should have the same hash as http://example.com" do
    @uri.hash.should == Addressable::URI.parse("http://example.com").hash
  end

  it "should have the same hash as http://EXAMPLE.com after assignment" do
    @uri.host = "EXAMPLE.com"
    @uri.hash.should == Addressable::URI.parse("http://EXAMPLE.com").hash
  end

  it "should have a different hash from http://EXAMPLE.com" do
    @uri.hash.should_not == Addressable::URI.parse("http://EXAMPLE.com").hash
  end

  # Section 6.2.3 of RFC 3986
  it "should be equivalent to http://example.com/" do
    @uri.should == Addressable::URI.parse("http://example.com/")
  end

  # Section 6.2.3 of RFC 3986
  it "should be equivalent to http://example.com:/" do
    @uri.should == Addressable::URI.parse("http://example.com:/")
  end

  # Section 6.2.3 of RFC 3986
  it "should be equivalent to http://example.com:80/" do
    @uri.should == Addressable::URI.parse("http://example.com:80/")
  end

  # Section 6.2.2.1 of RFC 3986
  it "should be equivalent to http://EXAMPLE.COM/" do
    @uri.should == Addressable::URI.parse("http://EXAMPLE.COM/")
  end

  it "should have a route of '/path/' to 'http://example.com/path/'" do
    @uri.route_to("http://example.com/path/").should ==
      Addressable::URI.parse("/path/")
  end

  it "should have a route of '/' from 'http://example.com/path/'" do
    @uri.route_from("http://example.com/path/").should ==
      Addressable::URI.parse("/")
  end

  it "should have a route of '#' to 'http://example.com/'" do
    @uri.route_to("http://example.com/").should ==
      Addressable::URI.parse("#")
  end

  it "should have a route of 'http://elsewhere.com/' to " +
      "'http://elsewhere.com/'" do
    @uri.route_to("http://elsewhere.com/").should ==
      Addressable::URI.parse("http://elsewhere.com/")
  end

  it "when joined with 'relative/path' should be " +
      "'http://example.com/relative/path'" do
    @uri.join('relative/path').should ==
      Addressable::URI.parse("http://example.com/relative/path")
  end

  it "when joined with a bogus object a TypeError should be raised" do
    (lambda do
      @uri.join(42)
    end).should raise_error(TypeError)
  end

  it "should have the correct username after assignment" do
    @uri.user = "newuser"
    @uri.user.should == "newuser"
    @uri.password.should == nil
    @uri.to_s.should == "http://newuser@example.com"
  end

  it "should have the correct username after assignment" do
    @uri.user = "user@123!"
    @uri.user.should == "user@123!"
    @uri.normalized_user.should == "user%40123%21"
    @uri.password.should == nil
    @uri.normalize.to_s.should == "http://user%40123%21@example.com/"
  end

  it "should have the correct password after assignment" do
    @uri.password = "newpass"
    @uri.password.should == "newpass"
    @uri.user.should == ""
    @uri.to_s.should == "http://:newpass@example.com"
  end

  it "should have the correct password after assignment" do
    @uri.password = "secret@123!"
    @uri.password.should == "secret@123!"
    @uri.normalized_password.should == "secret%40123%21"
    @uri.user.should == ""
    @uri.normalize.to_s.should == "http://:secret%40123%21@example.com/"
    @uri.omit(:password).to_s.should == "http://example.com"
  end

  it "should have the correct user/pass after repeated assignment" do
    @uri.user = nil
    @uri.user.should == nil
    @uri.password = "newpass"
    @uri.password.should == "newpass"
    # Username cannot be nil if the password is set
    @uri.user.should == ""
    @uri.to_s.should == "http://:newpass@example.com"
    @uri.user = "newuser"
    @uri.user.should == "newuser"
    @uri.password = nil
    @uri.password.should == nil
    @uri.to_s.should == "http://newuser@example.com"
    @uri.user = "newuser"
    @uri.user.should == "newuser"
    @uri.password = ""
    @uri.password.should == ""
    @uri.to_s.should == "http://newuser:@example.com"
    @uri.password = "newpass"
    @uri.password.should == "newpass"
    @uri.user = nil
    # Username cannot be nil if the password is set
    @uri.user.should == ""
    @uri.to_s.should == "http://:newpass@example.com"
  end

  it "should have the correct user/pass after userinfo assignment" do
    @uri.user = "newuser"
    @uri.user.should == "newuser"
    @uri.password = "newpass"
    @uri.password.should == "newpass"
    @uri.userinfo = nil
    @uri.userinfo.should == nil
    @uri.user.should == nil
    @uri.password.should == nil
  end

  it "should correctly convert to a hash" do
    @uri.to_hash.should == {
      :scheme => "http",
      :user => nil,
      :password => nil,
      :host => "example.com",
      :port => nil,
      :path => "",
      :query => nil,
      :fragment => nil
    }
  end

  it "should be identical to its duplicate" do
    @uri.should == @uri.dup
  end

  it "should have an origin of 'http://example.com'" do
    @uri.origin.should == 'http://example.com'
  end
end

# Section 5.1.2 of RFC 2616
describe Addressable::URI, "when parsed from " +
    "'http://www.w3.org/pub/WWW/TheProject.html'" do
  before do
    @uri = Addressable::URI.parse("http://www.w3.org/pub/WWW/TheProject.html")
  end

  it "should have the correct request URI" do
    @uri.request_uri.should == "/pub/WWW/TheProject.html"
  end

  it "should have the correct request URI after assignment" do
    @uri.request_uri = "/some/where/else.html?query?string"
    @uri.request_uri.should == "/some/where/else.html?query?string"
    @uri.path.should == "/some/where/else.html"
    @uri.query.should == "query?string"
  end

  it "should have the correct request URI after assignment" do
    @uri.request_uri = "?x=y"
    @uri.request_uri.should == "/?x=y"
    @uri.path.should == "/"
    @uri.query.should == "x=y"
  end

  it "should raise an error if the site value is set to something bogus" do
    (lambda do
      @uri.site = 42
    end).should raise_error(TypeError)
  end

  it "should raise an error if the request URI is set to something bogus" do
    (lambda do
      @uri.request_uri = 42
    end).should raise_error(TypeError)
  end

  it "should correctly convert to a hash" do
    @uri.to_hash.should == {
      :scheme => "http",
      :user => nil,
      :password => nil,
      :host => "www.w3.org",
      :port => nil,
      :path => "/pub/WWW/TheProject.html",
      :query => nil,
      :fragment => nil
    }
  end

  it "should have an origin of 'http://www.w3.org'" do
    @uri.origin.should == 'http://www.w3.org'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/")
  end

  # Based on http://intertwingly.net/blog/2004/07/31/URI-Equivalence
  it "should be equivalent to http://example.com" do
    @uri.should == Addressable::URI.parse("http://example.com")
  end

  # Based on http://intertwingly.net/blog/2004/07/31/URI-Equivalence
  it "should be equivalent to HTTP://example.com/" do
    @uri.should == Addressable::URI.parse("HTTP://example.com/")
  end

  # Based on http://intertwingly.net/blog/2004/07/31/URI-Equivalence
  it "should be equivalent to http://example.com:/" do
    @uri.should == Addressable::URI.parse("http://example.com:/")
  end

  # Based on http://intertwingly.net/blog/2004/07/31/URI-Equivalence
  it "should be equivalent to http://example.com:80/" do
    @uri.should == Addressable::URI.parse("http://example.com:80/")
  end

  # Based on http://intertwingly.net/blog/2004/07/31/URI-Equivalence
  it "should be equivalent to http://Example.com/" do
    @uri.should == Addressable::URI.parse("http://Example.com/")
  end

  it "should have the correct username after assignment" do
    @uri.user = nil
    @uri.user.should == nil
    @uri.password.should == nil
    @uri.to_s.should == "http://example.com/"
  end

  it "should have the correct password after assignment" do
    @uri.password = nil
    @uri.password.should == nil
    @uri.user.should == nil
    @uri.to_s.should == "http://example.com/"
  end

  it "should have a request URI of '/'" do
    @uri.request_uri.should == "/"
  end

  it "should correctly convert to a hash" do
    @uri.to_hash.should == {
      :scheme => "http",
      :user => nil,
      :password => nil,
      :host => "example.com",
      :port => nil,
      :path => "/",
      :query => nil,
      :fragment => nil
    }
  end

  it "should be identical to its duplicate" do
    @uri.should == @uri.dup
  end

  it "should have the same hash as its duplicate" do
    @uri.hash.should == @uri.dup.hash
  end

  it "should have a different hash from its equivalent String value" do
    @uri.hash.should_not == @uri.to_s.hash
  end

  it "should have the same hash as an equal URI" do
    @uri.hash.should == Addressable::URI.parse("http://example.com/").hash
  end

  it "should be equivalent to http://EXAMPLE.com" do
    @uri.should == Addressable::URI.parse("http://EXAMPLE.com")
  end

  it "should be equivalent to http://EXAMPLE.com:80/" do
    @uri.should == Addressable::URI.parse("http://EXAMPLE.com:80/")
  end

  it "should have the same hash as http://example.com/" do
    @uri.hash.should == Addressable::URI.parse("http://example.com/").hash
  end

  it "should have the same hash as http://example.com after assignment" do
    @uri.path = ""
    @uri.hash.should == Addressable::URI.parse("http://example.com").hash
  end

  it "should have the same hash as http://example.com/? after assignment" do
    @uri.query = ""
    @uri.hash.should == Addressable::URI.parse("http://example.com/?").hash
  end

  it "should have the same hash as http://example.com/? after assignment" do
    @uri.query_values = {}
    @uri.hash.should == Addressable::URI.parse("http://example.com/?").hash
  end

  it "should have the same hash as http://example.com/# after assignment" do
    @uri.fragment = ""
    @uri.hash.should == Addressable::URI.parse("http://example.com/#").hash
  end

  it "should have a different hash from http://example.com" do
    @uri.hash.should_not == Addressable::URI.parse("http://example.com").hash
  end

  it "should have an origin of 'http://example.com'" do
    @uri.origin.should == 'http://example.com'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://@example.com/'" do
  before do
    @uri = Addressable::URI.parse("http://@example.com/")
  end

  it "should be equivalent to http://example.com" do
    @uri.should == Addressable::URI.parse("http://example.com")
  end

  it "should correctly convert to a hash" do
    @uri.to_hash.should == {
      :scheme => "http",
      :user => "",
      :password => nil,
      :host => "example.com",
      :port => nil,
      :path => "/",
      :query => nil,
      :fragment => nil
    }
  end

  it "should be identical to its duplicate" do
    @uri.should == @uri.dup
  end

  it "should have an origin of 'http://example.com'" do
    @uri.origin.should == 'http://example.com'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com./'" do
  before do
    @uri = Addressable::URI.parse("http://example.com./")
  end

  it "should be equivalent to http://example.com" do
    @uri.should == Addressable::URI.parse("http://example.com")
  end

  it "should not be considered to be in normal form" do
    @uri.normalize.should_not be_eql(@uri)
  end

  it "should be identical to its duplicate" do
    @uri.should == @uri.dup
  end

  it "should have an origin of 'http://example.com'" do
    @uri.origin.should == 'http://example.com'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://:@example.com/'" do
  before do
    @uri = Addressable::URI.parse("http://:@example.com/")
  end

  it "should be equivalent to http://example.com" do
    @uri.should == Addressable::URI.parse("http://example.com")
  end

  it "should correctly convert to a hash" do
    @uri.to_hash.should == {
      :scheme => "http",
      :user => "",
      :password => "",
      :host => "example.com",
      :port => nil,
      :path => "/",
      :query => nil,
      :fragment => nil
    }
  end

  it "should be identical to its duplicate" do
    @uri.should == @uri.dup
  end

  it "should have an origin of 'http://example.com'" do
    @uri.origin.should == 'http://example.com'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/~smith/'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/~smith/")
  end

  # Based on http://intertwingly.net/blog/2004/07/31/URI-Equivalence
  it "should be equivalent to http://example.com/%7Esmith/" do
    @uri.should == Addressable::URI.parse("http://example.com/%7Esmith/")
  end

  # Based on http://intertwingly.net/blog/2004/07/31/URI-Equivalence
  it "should be equivalent to http://example.com/%7esmith/" do
    @uri.should == Addressable::URI.parse("http://example.com/%7esmith/")
  end

  it "should be identical to its duplicate" do
    @uri.should == @uri.dup
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/%E8'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/%E8")
  end

  it "should not raise an exception when normalized" do
    (lambda do
      @uri.normalize
    end).should_not raise_error(ArgumentError)
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should not change if encoded with the normalizing algorithm" do
    Addressable::URI.normalized_encode(@uri).to_s.should ==
      "http://example.com/%E8"
    Addressable::URI.normalized_encode(@uri, Addressable::URI).to_s.should ===
      "http://example.com/%E8"
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/path%2Fsegment/'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/path%2Fsegment/")
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should be equal to 'http://example.com/path%2Fsegment/'" do
    @uri.normalize.should be_eql(
      Addressable::URI.parse("http://example.com/path%2Fsegment/")
    )
  end

  it "should not be equal to 'http://example.com/path/segment/'" do
    @uri.should_not ==
      Addressable::URI.parse("http://example.com/path/segment/")
  end

  it "should not be equal to 'http://example.com/path/segment/'" do
    @uri.normalize.should_not be_eql(
      Addressable::URI.parse("http://example.com/path/segment/")
    )
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/?%F6'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/?%F6")
  end

  it "should not raise an exception when normalized" do
    (lambda do
      @uri.normalize
    end).should_not raise_error(ArgumentError)
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should not change if encoded with the normalizing algorithm" do
    Addressable::URI.normalized_encode(@uri).to_s.should ==
      "http://example.com/?%F6"
    Addressable::URI.normalized_encode(@uri, Addressable::URI).to_s.should ===
      "http://example.com/?%F6"
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/#%F6'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/#%F6")
  end

  it "should not raise an exception when normalized" do
    (lambda do
      @uri.normalize
    end).should_not raise_error(ArgumentError)
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should not change if encoded with the normalizing algorithm" do
    Addressable::URI.normalized_encode(@uri).to_s.should ==
      "http://example.com/#%F6"
    Addressable::URI.normalized_encode(@uri, Addressable::URI).to_s.should ===
      "http://example.com/#%F6"
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/%C3%87'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/%C3%87")
  end

  # Based on http://intertwingly.net/blog/2004/07/31/URI-Equivalence
  it "should be equivalent to 'http://example.com/C%CC%A7'" do
    @uri.should == Addressable::URI.parse("http://example.com/C%CC%A7")
  end

  it "should not change if encoded with the normalizing algorithm" do
    Addressable::URI.normalized_encode(@uri).to_s.should ==
      "http://example.com/%C3%87"
    Addressable::URI.normalized_encode(@uri, Addressable::URI).to_s.should ===
      "http://example.com/%C3%87"
  end

  it "should raise an error if encoding with an unexpected return type" do
    (lambda do
      Addressable::URI.normalized_encode(@uri, Integer)
    end).should raise_error(TypeError)
  end

  it "if percent encoded should be 'http://example.com/C%25CC%25A7'" do
    Addressable::URI.encode(@uri).to_s.should ==
      "http://example.com/%25C3%2587"
  end

  it "if percent encoded should be 'http://example.com/C%25CC%25A7'" do
    Addressable::URI.encode(@uri, Addressable::URI).should ==
      Addressable::URI.parse("http://example.com/%25C3%2587")
  end

  it "should raise an error if encoding with an unexpected return type" do
    (lambda do
      Addressable::URI.encode(@uri, Integer)
    end).should raise_error(TypeError)
  end

  it "should be identical to its duplicate" do
    @uri.should == @uri.dup
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/?q=string'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/?q=string")
  end

  it "should use the 'http' scheme" do
    @uri.scheme.should == "http"
  end

  it "should have an authority segment of 'example.com'" do
    @uri.authority.should == "example.com"
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should have no username" do
    @uri.user.should == nil
  end

  it "should have no password" do
    @uri.password.should == nil
  end

  it "should use port 80" do
    @uri.inferred_port.should == 80
  end

  it "should have a path of '/'" do
    @uri.path.should == "/"
  end

  it "should have a query string of 'q=string'" do
    @uri.query.should == "q=string"
  end

  it "should have no fragment" do
    @uri.fragment.should == nil
  end

  it "should be considered absolute" do
    @uri.should be_absolute
  end

  it "should not be considered relative" do
    @uri.should_not be_relative
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should be identical to its duplicate" do
    @uri.should == @uri.dup
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com:80/'" do
  before do
    @uri = Addressable::URI.parse("http://example.com:80/")
  end

  it "should use the 'http' scheme" do
    @uri.scheme.should == "http"
  end

  it "should have an authority segment of 'example.com:80'" do
    @uri.authority.should == "example.com:80"
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should have no username" do
    @uri.user.should == nil
  end

  it "should have no password" do
    @uri.password.should == nil
  end

  it "should use port 80" do
    @uri.port.should == 80
  end

  it "should have a path of '/'" do
    @uri.path.should == "/"
  end

  it "should have no query string" do
    @uri.query.should == nil
  end

  it "should have no fragment" do
    @uri.fragment.should == nil
  end

  it "should be considered absolute" do
    @uri.should be_absolute
  end

  it "should not be considered relative" do
    @uri.should_not be_relative
  end

  it "should be exactly equal to http://example.com:80/" do
    @uri.eql?(Addressable::URI.parse("http://example.com:80/")).should == true
  end

  it "should be roughly equal to http://example.com/" do
    (@uri === Addressable::URI.parse("http://example.com/")).should == true
  end

  it "should be roughly equal to the string 'http://example.com/'" do
    (@uri === "http://example.com/").should == true
  end

  it "should not be roughly equal to the string " +
      "'http://example.com:bogus/'" do
    (lambda do
      (@uri === "http://example.com:bogus/").should == false
    end).should_not raise_error
  end

  it "should result in itself when joined with itself" do
    @uri.join(@uri).to_s.should == "http://example.com:80/"
    @uri.join!(@uri).to_s.should == "http://example.com:80/"
  end

  # Section 6.2.3 of RFC 3986
  it "should be equal to http://example.com/" do
    @uri.should == Addressable::URI.parse("http://example.com/")
  end

  # Section 6.2.3 of RFC 3986
  it "should be equal to http://example.com:/" do
    @uri.should == Addressable::URI.parse("http://example.com:/")
  end

  # Section 6.2.3 of RFC 3986
  it "should be equal to http://example.com:80/" do
    @uri.should == Addressable::URI.parse("http://example.com:80/")
  end

  # Section 6.2.2.1 of RFC 3986
  it "should be equal to http://EXAMPLE.COM/" do
    @uri.should == Addressable::URI.parse("http://EXAMPLE.COM/")
  end

  it "should correctly convert to a hash" do
    @uri.to_hash.should == {
      :scheme => "http",
      :user => nil,
      :password => nil,
      :host => "example.com",
      :port => 80,
      :path => "/",
      :query => nil,
      :fragment => nil
    }
  end

  it "should be identical to its duplicate" do
    @uri.should == @uri.dup
  end

  it "should have an origin of 'http://example.com'" do
    @uri.origin.should == 'http://example.com'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com:8080/'" do
  before do
    @uri = Addressable::URI.parse("http://example.com:8080/")
  end

  it "should use the 'http' scheme" do
    @uri.scheme.should == "http"
  end

  it "should have an authority segment of 'example.com:8080'" do
    @uri.authority.should == "example.com:8080"
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should have no username" do
    @uri.user.should == nil
  end

  it "should have no password" do
    @uri.password.should == nil
  end

  it "should use port 8080" do
    @uri.port.should == 8080
  end

  it "should have a path of '/'" do
    @uri.path.should == "/"
  end

  it "should have no query string" do
    @uri.query.should == nil
  end

  it "should have no fragment" do
    @uri.fragment.should == nil
  end

  it "should be considered absolute" do
    @uri.should be_absolute
  end

  it "should not be considered relative" do
    @uri.should_not be_relative
  end

  it "should be exactly equal to http://example.com:8080/" do
    @uri.eql?(Addressable::URI.parse(
      "http://example.com:8080/")).should == true
  end

  it "should have a route of 'http://example.com:8080/' from " +
      "'http://example.com/path/to/'" do
    @uri.route_from("http://example.com/path/to/").should ==
      Addressable::URI.parse("http://example.com:8080/")
  end

  it "should have a route of 'http://example.com:8080/' from " +
      "'http://example.com:80/path/to/'" do
    @uri.route_from("http://example.com:80/path/to/").should ==
      Addressable::URI.parse("http://example.com:8080/")
  end

  it "should have a route of '/' from " +
      "'http://example.com:8080/path/to/'" do
    @uri.route_from("http://example.com:8080/path/to/").should ==
      Addressable::URI.parse("/")
  end

  it "should have a route of 'http://example.com:8080/' from " +
      "'http://user:pass@example.com/path/to/'" do
    @uri.route_from("http://user:pass@example.com/path/to/").should ==
      Addressable::URI.parse("http://example.com:8080/")
  end

  it "should correctly convert to a hash" do
    @uri.to_hash.should == {
      :scheme => "http",
      :user => nil,
      :password => nil,
      :host => "example.com",
      :port => 8080,
      :path => "/",
      :query => nil,
      :fragment => nil
    }
  end

  it "should be identical to its duplicate" do
    @uri.should == @uri.dup
  end

  it "should have an origin of 'http://example.com:8080'" do
    @uri.origin.should == 'http://example.com:8080'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com:%38%30/'" do
  before do
    @uri = Addressable::URI.parse("http://example.com:%38%30/")
  end

  it "should have the correct port" do
    @uri.port.should == 80
  end

  it "should not be considered to be in normal form" do
    @uri.normalize.should_not be_eql(@uri)
  end

  it "should normalize to 'http://example.com/'" do
    @uri.normalize.should === "http://example.com/"
  end

  it "should have an origin of 'http://example.com'" do
    @uri.origin.should == 'http://example.com'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/..'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/..")
  end

  it "should have the correct port" do
    @uri.inferred_port.should == 80
  end

  it "should not be considered to be in normal form" do
    @uri.normalize.should_not be_eql(@uri)
  end

  it "should normalize to 'http://example.com/'" do
    @uri.normalize.should === "http://example.com/"
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/../..'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/../..")
  end

  it "should have the correct port" do
    @uri.inferred_port.should == 80
  end

  it "should not be considered to be in normal form" do
    @uri.normalize.should_not be_eql(@uri)
  end

  it "should normalize to 'http://example.com/'" do
    @uri.normalize.should === "http://example.com/"
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/path/to/resource/'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/path/to/resource/")
  end

  it "should use the 'http' scheme" do
    @uri.scheme.should == "http"
  end

  it "should have an authority segment of 'example.com'" do
    @uri.authority.should == "example.com"
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should have no username" do
    @uri.user.should == nil
  end

  it "should have no password" do
    @uri.password.should == nil
  end

  it "should use port 80" do
    @uri.inferred_port.should == 80
  end

  it "should have a path of '/path/to/resource/'" do
    @uri.path.should == "/path/to/resource/"
  end

  it "should have no query string" do
    @uri.query.should == nil
  end

  it "should have no fragment" do
    @uri.fragment.should == nil
  end

  it "should be considered absolute" do
    @uri.should be_absolute
  end

  it "should not be considered relative" do
    @uri.should_not be_relative
  end

  it "should be exactly equal to http://example.com:8080/" do
    @uri.eql?(Addressable::URI.parse(
      "http://example.com/path/to/resource/")).should == true
  end

  it "should have a route of 'resource/' from " +
      "'http://example.com/path/to/'" do
    @uri.route_from("http://example.com/path/to/").should ==
      Addressable::URI.parse("resource/")
  end

  it "should have a route of 'resource/' from " +
      "'http://example.com:80/path/to/'" do
    @uri.route_from("http://example.com:80/path/to/").should ==
      Addressable::URI.parse("resource/")
  end

  it "should have a route of 'http://example.com/path/to/' from " +
      "'http://example.com:8080/path/to/'" do
    @uri.route_from("http://example.com:8080/path/to/").should ==
      Addressable::URI.parse("http://example.com/path/to/resource/")
  end

  it "should have a route of 'http://example.com/path/to/' from " +
      "'http://user:pass@example.com/path/to/'" do
    @uri.route_from("http://user:pass@example.com/path/to/").should ==
      Addressable::URI.parse("http://example.com/path/to/resource/")
  end

  it "should have a route of '/path/to/resource/' from " +
      "'http://example.com/to/resource/'" do
    @uri.route_from("http://example.com/to/resource/").should ==
      Addressable::URI.parse("/path/to/resource/")
  end

  it "should correctly convert to a hash" do
    @uri.to_hash.should == {
      :scheme => "http",
      :user => nil,
      :password => nil,
      :host => "example.com",
      :port => nil,
      :path => "/path/to/resource/",
      :query => nil,
      :fragment => nil
    }
  end

  it "should be identical to its duplicate" do
    @uri.should == @uri.dup
  end
end

describe Addressable::URI, "when parsed from " +
    "'relative/path/to/resource'" do
  before do
    @uri = Addressable::URI.parse("relative/path/to/resource")
  end

  it "should not have a scheme" do
    @uri.scheme.should == nil
  end

  it "should not be considered ip-based" do
    @uri.should_not be_ip_based
  end

  it "should not have an authority segment" do
    @uri.authority.should == nil
  end

  it "should not have a host" do
    @uri.host.should == nil
  end

  it "should have no username" do
    @uri.user.should == nil
  end

  it "should have no password" do
    @uri.password.should == nil
  end

  it "should not have a port" do
    @uri.port.should == nil
  end

  it "should have a path of 'relative/path/to/resource'" do
    @uri.path.should == "relative/path/to/resource"
  end

  it "should have no query string" do
    @uri.query.should == nil
  end

  it "should have no fragment" do
    @uri.fragment.should == nil
  end

  it "should not be considered absolute" do
    @uri.should_not be_absolute
  end

  it "should be considered relative" do
    @uri.should be_relative
  end

  it "should raise an error if routing is attempted" do
    (lambda do
      @uri.route_to("http://example.com/")
    end).should raise_error(ArgumentError, /relative\/path\/to\/resource/)
    (lambda do
      @uri.route_from("http://example.com/")
    end).should raise_error(ArgumentError, /relative\/path\/to\/resource/)
  end

  it "when joined with 'another/relative/path' should be " +
      "'relative/path/to/another/relative/path'" do
    @uri.join('another/relative/path').should ==
      Addressable::URI.parse("relative/path/to/another/relative/path")
  end

  it "should be identical to its duplicate" do
    @uri.should == @uri.dup
  end
end

describe Addressable::URI, "when parsed from " +
    "'relative_path_with_no_slashes'" do
  before do
    @uri = Addressable::URI.parse("relative_path_with_no_slashes")
  end

  it "should not have a scheme" do
    @uri.scheme.should == nil
  end

  it "should not be considered ip-based" do
    @uri.should_not be_ip_based
  end

  it "should not have an authority segment" do
    @uri.authority.should == nil
  end

  it "should not have a host" do
    @uri.host.should == nil
  end

  it "should have no username" do
    @uri.user.should == nil
  end

  it "should have no password" do
    @uri.password.should == nil
  end

  it "should not have a port" do
    @uri.port.should == nil
  end

  it "should have a path of 'relative_path_with_no_slashes'" do
    @uri.path.should == "relative_path_with_no_slashes"
  end

  it "should have no query string" do
    @uri.query.should == nil
  end

  it "should have no fragment" do
    @uri.fragment.should == nil
  end

  it "should not be considered absolute" do
    @uri.should_not be_absolute
  end

  it "should be considered relative" do
    @uri.should be_relative
  end

  it "when joined with 'another_relative_path' should be " +
      "'another_relative_path'" do
    @uri.join('another_relative_path').should ==
      Addressable::URI.parse("another_relative_path")
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/file.txt'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/file.txt")
  end

  it "should have a scheme of 'http'" do
    @uri.scheme.should == "http"
  end

  it "should have an authority segment of 'example.com'" do
    @uri.authority.should == "example.com"
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should have no username" do
    @uri.user.should == nil
  end

  it "should have no password" do
    @uri.password.should == nil
  end

  it "should use port 80" do
    @uri.inferred_port.should == 80
  end

  it "should have a path of '/file.txt'" do
    @uri.path.should == "/file.txt"
  end

  it "should have a basename of 'file.txt'" do
    @uri.basename.should == "file.txt"
  end

  it "should have an extname of '.txt'" do
    @uri.extname.should == ".txt"
  end

  it "should have no query string" do
    @uri.query.should == nil
  end

  it "should have no fragment" do
    @uri.fragment.should == nil
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/file.txt;parameter'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/file.txt;parameter")
  end

  it "should have a scheme of 'http'" do
    @uri.scheme.should == "http"
  end

  it "should have an authority segment of 'example.com'" do
    @uri.authority.should == "example.com"
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should have no username" do
    @uri.user.should == nil
  end

  it "should have no password" do
    @uri.password.should == nil
  end

  it "should use port 80" do
    @uri.inferred_port.should == 80
  end

  it "should have a path of '/file.txt;parameter'" do
    @uri.path.should == "/file.txt;parameter"
  end

  it "should have a basename of 'file.txt'" do
    @uri.basename.should == "file.txt"
  end

  it "should have an extname of '.txt'" do
    @uri.extname.should == ".txt"
  end

  it "should have no query string" do
    @uri.query.should == nil
  end

  it "should have no fragment" do
    @uri.fragment.should == nil
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/file.txt;x=y'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/file.txt;x=y")
  end

  it "should have a scheme of 'http'" do
    @uri.scheme.should == "http"
  end

  it "should have a scheme of 'http'" do
    @uri.scheme.should == "http"
  end

  it "should have an authority segment of 'example.com'" do
    @uri.authority.should == "example.com"
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should have no username" do
    @uri.user.should == nil
  end

  it "should have no password" do
    @uri.password.should == nil
  end

  it "should use port 80" do
    @uri.inferred_port.should == 80
  end

  it "should have a path of '/file.txt;x=y'" do
    @uri.path.should == "/file.txt;x=y"
  end

  it "should have an extname of '.txt'" do
    @uri.extname.should == ".txt"
  end

  it "should have no query string" do
    @uri.query.should == nil
  end

  it "should have no fragment" do
    @uri.fragment.should == nil
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end
end

describe Addressable::URI, "when parsed from " +
    "'svn+ssh://developername@rubyforge.org/var/svn/project'" do
  before do
    @uri = Addressable::URI.parse(
      "svn+ssh://developername@rubyforge.org/var/svn/project"
    )
  end

  it "should have a scheme of 'svn+ssh'" do
    @uri.scheme.should == "svn+ssh"
  end

  it "should be considered to be ip-based" do
    @uri.should be_ip_based
  end

  it "should have a path of '/var/svn/project'" do
    @uri.path.should == "/var/svn/project"
  end

  it "should have a username of 'developername'" do
    @uri.user.should == "developername"
  end

  it "should have no password" do
    @uri.password.should == nil
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end
end

describe Addressable::URI, "when parsed from " +
    "'ssh+svn://developername@RUBYFORGE.ORG/var/svn/project'" do
  before do
    @uri = Addressable::URI.parse(
      "ssh+svn://developername@RUBYFORGE.ORG/var/svn/project"
    )
  end

  it "should have a scheme of 'ssh+svn'" do
    @uri.scheme.should == "ssh+svn"
  end

  it "should have a normalized scheme of 'svn+ssh'" do
    @uri.normalized_scheme.should == "svn+ssh"
  end

  it "should have a normalized site of 'svn+ssh'" do
    @uri.normalized_site.should == "svn+ssh://developername@rubyforge.org"
  end

  it "should not be considered to be ip-based" do
    @uri.should_not be_ip_based
  end

  it "should have a path of '/var/svn/project'" do
    @uri.path.should == "/var/svn/project"
  end

  it "should have a username of 'developername'" do
    @uri.user.should == "developername"
  end

  it "should have no password" do
    @uri.password.should == nil
  end

  it "should not be considered to be in normal form" do
    @uri.normalize.should_not be_eql(@uri)
  end
end

describe Addressable::URI, "when parsed from " +
    "'mailto:user@example.com'" do
  before do
    @uri = Addressable::URI.parse("mailto:user@example.com")
  end

  it "should have a scheme of 'mailto'" do
    @uri.scheme.should == "mailto"
  end

  it "should not be considered to be ip-based" do
    @uri.should_not be_ip_based
  end

  it "should have a path of 'user@example.com'" do
    @uri.path.should == "user@example.com"
  end

  it "should have no user" do
    @uri.user.should == nil
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end
end

describe Addressable::URI, "when parsed from " +
    "'tag:example.com,2006-08-18:/path/to/something'" do
  before do
    @uri = Addressable::URI.parse(
      "tag:example.com,2006-08-18:/path/to/something")
  end

  it "should have a scheme of 'tag'" do
    @uri.scheme.should == "tag"
  end

  it "should be considered to be ip-based" do
    @uri.should_not be_ip_based
  end

  it "should have a path of " +
      "'example.com,2006-08-18:/path/to/something'" do
    @uri.path.should == "example.com,2006-08-18:/path/to/something"
  end

  it "should have no user" do
    @uri.user.should == nil
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/x;y/'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/x;y/")
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/?x=1&y=2'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/?x=1&y=2")
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end
end

describe Addressable::URI, "when parsed from " +
    "'view-source:http://example.com/'" do
  before do
    @uri = Addressable::URI.parse("view-source:http://example.com/")
  end

  it "should have a scheme of 'view-source'" do
    @uri.scheme.should == "view-source"
  end

  it "should have a path of 'http://example.com/'" do
    @uri.path.should == "http://example.com/"
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://user:pass@example.com/path/to/resource?query=x#fragment'" do
  before do
    @uri = Addressable::URI.parse(
      "http://user:pass@example.com/path/to/resource?query=x#fragment")
  end

  it "should use the 'http' scheme" do
    @uri.scheme.should == "http"
  end

  it "should have an authority segment of 'user:pass@example.com'" do
    @uri.authority.should == "user:pass@example.com"
  end

  it "should have a username of 'user'" do
    @uri.user.should == "user"
  end

  it "should have a password of 'pass'" do
    @uri.password.should == "pass"
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should use port 80" do
    @uri.inferred_port.should == 80
  end

  it "should have a path of '/path/to/resource'" do
    @uri.path.should == "/path/to/resource"
  end

  it "should have a query string of 'query=x'" do
    @uri.query.should == "query=x"
  end

  it "should have a fragment of 'fragment'" do
    @uri.fragment.should == "fragment"
  end

  it "should be considered to be in normal form" do
    @uri.normalize.should be_eql(@uri)
  end

  it "should have a route of '/path/' to " +
      "'http://user:pass@example.com/path/'" do
    @uri.route_to("http://user:pass@example.com/path/").should ==
      Addressable::URI.parse("/path/")
  end

  it "should have a route of '/path/to/resource?query=x#fragment' " +
      "from 'http://user:pass@example.com/path/'" do
    @uri.route_from("http://user:pass@example.com/path/").should ==
      Addressable::URI.parse("to/resource?query=x#fragment")
  end

  it "should have a route of '?query=x#fragment' " +
      "from 'http://user:pass@example.com/path/to/resource'" do
    @uri.route_from("http://user:pass@example.com/path/to/resource").should ==
      Addressable::URI.parse("?query=x#fragment")
  end

  it "should have a route of '#fragment' " +
      "from 'http://user:pass@example.com/path/to/resource?query=x'" do
    @uri.route_from(
      "http://user:pass@example.com/path/to/resource?query=x").should ==
        Addressable::URI.parse("#fragment")
  end

  it "should have a route of '#fragment' from " +
      "'http://user:pass@example.com/path/to/resource?query=x#fragment'" do
    @uri.route_from(
      "http://user:pass@example.com/path/to/resource?query=x#fragment"
    ).should == Addressable::URI.parse("#fragment")
  end

  it "should have a route of 'http://elsewhere.com/' to " +
      "'http://elsewhere.com/'" do
    @uri.route_to("http://elsewhere.com/").should ==
      Addressable::URI.parse("http://elsewhere.com/")
  end

  it "should have a route of " +
      "'http://user:pass@example.com/path/to/resource?query=x#fragment' " +
      "from 'http://example.com/path/to/'" do
    @uri.route_from("http://elsewhere.com/path/to/").should ==
      Addressable::URI.parse(
        "http://user:pass@example.com/path/to/resource?query=x#fragment")
  end

  it "should have the correct scheme after assignment" do
    @uri.scheme = "ftp"
    @uri.scheme.should == "ftp"
    @uri.to_s.should ==
      "ftp://user:pass@example.com/path/to/resource?query=x#fragment"
    @uri.to_str.should ==
      "ftp://user:pass@example.com/path/to/resource?query=x#fragment"
    @uri.scheme = "bogus!"
    @uri.scheme.should == "bogus!"
    @uri.normalized_scheme.should == "bogus%21"
    @uri.normalize.to_s.should ==
      "bogus%21://user:pass@example.com/path/to/resource?query=x#fragment"
    @uri.normalize.to_str.should ==
      "bogus%21://user:pass@example.com/path/to/resource?query=x#fragment"
  end

  it "should have the correct site segment after assignment" do
    @uri.site = "https://newuser:newpass@example.com:443"
    @uri.scheme.should == "https"
    @uri.authority.should == "newuser:newpass@example.com:443"
    @uri.user.should == "newuser"
    @uri.password.should == "newpass"
    @uri.userinfo.should == "newuser:newpass"
    @uri.normalized_userinfo.should == "newuser:newpass"
    @uri.host.should == "example.com"
    @uri.port.should == 443
    @uri.inferred_port.should == 443
    @uri.to_s.should ==
      "https://newuser:newpass@example.com:443" +
      "/path/to/resource?query=x#fragment"
  end

  it "should have the correct authority segment after assignment" do
    @uri.authority = "newuser:newpass@example.com:80"
    @uri.authority.should == "newuser:newpass@example.com:80"
    @uri.user.should == "newuser"
    @uri.password.should == "newpass"
    @uri.userinfo.should == "newuser:newpass"
    @uri.normalized_userinfo.should == "newuser:newpass"
    @uri.host.should == "example.com"
    @uri.port.should == 80
    @uri.inferred_port.should == 80
    @uri.to_s.should ==
      "http://newuser:newpass@example.com:80" +
      "/path/to/resource?query=x#fragment"
  end

  it "should have the correct userinfo segment after assignment" do
    @uri.userinfo = "newuser:newpass"
    @uri.userinfo.should == "newuser:newpass"
    @uri.authority.should == "newuser:newpass@example.com"
    @uri.user.should == "newuser"
    @uri.password.should == "newpass"
    @uri.host.should == "example.com"
    @uri.port.should == nil
    @uri.inferred_port.should == 80
    @uri.to_s.should ==
      "http://newuser:newpass@example.com" +
      "/path/to/resource?query=x#fragment"
  end

  it "should have the correct username after assignment" do
    @uri.user = "newuser"
    @uri.user.should == "newuser"
    @uri.authority.should == "newuser:pass@example.com"
  end

  it "should have the correct password after assignment" do
    @uri.password = "newpass"
    @uri.password.should == "newpass"
    @uri.authority.should == "user:newpass@example.com"
  end

  it "should have the correct host after assignment" do
    @uri.host = "newexample.com"
    @uri.host.should == "newexample.com"
    @uri.authority.should == "user:pass@newexample.com"
  end

  it "should have the correct port after assignment" do
    @uri.port = 8080
    @uri.port.should == 8080
    @uri.authority.should == "user:pass@example.com:8080"
  end

  it "should have the correct path after assignment" do
    @uri.path = "/newpath/to/resource"
    @uri.path.should == "/newpath/to/resource"
    @uri.to_s.should ==
      "http://user:pass@example.com/newpath/to/resource?query=x#fragment"
  end

  it "should have the correct scheme and authority after nil assignment" do
    @uri.site = nil
    @uri.scheme.should == nil
    @uri.authority.should == nil
    @uri.to_s.should == "/path/to/resource?query=x#fragment"
  end

  it "should have the correct scheme and authority after assignment" do
    @uri.site = "file://"
    @uri.scheme.should == "file"
    @uri.authority.should == ""
    @uri.to_s.should == "file:///path/to/resource?query=x#fragment"
  end

  it "should have the correct path after nil assignment" do
    @uri.path = nil
    @uri.path.should == ""
    @uri.to_s.should ==
      "http://user:pass@example.com?query=x#fragment"
  end

  it "should have the correct query string after assignment" do
    @uri.query = "newquery=x"
    @uri.query.should == "newquery=x"
    @uri.to_s.should ==
      "http://user:pass@example.com/path/to/resource?newquery=x#fragment"
    @uri.query = nil
    @uri.query.should == nil
    @uri.to_s.should ==
      "http://user:pass@example.com/path/to/resource#fragment"
  end

  it "should have the correct query string after hash assignment" do
    @uri.query_values = {"?uestion mark"=>"=sign", "hello"=>"g\xC3\xBCnther"}
    @uri.query.split("&").should include("%3Fuestion%20mark=%3Dsign")
    @uri.query.split("&").should include("hello=g%C3%BCnther")
    @uri.query_values.should == {
      "?uestion mark"=>"=sign", "hello"=>"g\xC3\xBCnther"
    }
  end

  it "should have the correct query string after flag hash assignment" do
    @uri.query_values = {'flag?1' => true, 'fl=ag2' => true, 'flag3' => true}
    @uri.query.split("&").should include("flag%3F1")
    @uri.query.split("&").should include("fl%3Dag2")
    @uri.query.split("&").should include("flag3")
    @uri.query_values.should == {
      'flag?1' => true, 'fl=ag2' => true, 'flag3' => true
    }
  end

  it "should raise an error if query values are set to a bogus type" do
    (lambda do
      @uri.query_values = "bogus"
    end).should raise_error(TypeError)
  end

  it "should have the correct fragment after assignment" do
    @uri.fragment = "newfragment"
    @uri.fragment.should == "newfragment"
    @uri.to_s.should ==
      "http://user:pass@example.com/path/to/resource?query=x#newfragment"

    @uri.fragment = nil
    @uri.fragment.should == nil
    @uri.to_s.should ==
      "http://user:pass@example.com/path/to/resource?query=x"
  end

  it "should have the correct values after a merge" do
    @uri.merge(:fragment => "newfragment").to_s.should ==
      "http://user:pass@example.com/path/to/resource?query=x#newfragment"
  end

  it "should have the correct values after a merge" do
    @uri.merge(:fragment => nil).to_s.should ==
      "http://user:pass@example.com/path/to/resource?query=x"
  end

  it "should have the correct values after a merge" do
    @uri.merge(:userinfo => "newuser:newpass").to_s.should ==
      "http://newuser:newpass@example.com/path/to/resource?query=x#fragment"
  end

  it "should have the correct values after a merge" do
    @uri.merge(:userinfo => nil).to_s.should ==
      "http://example.com/path/to/resource?query=x#fragment"
  end

  it "should have the correct values after a merge" do
    @uri.merge(:path => "newpath").to_s.should ==
      "http://user:pass@example.com/newpath?query=x#fragment"
  end

  it "should have the correct values after a merge" do
    @uri.merge(:port => "42", :path => "newpath", :query => "").to_s.should ==
      "http://user:pass@example.com:42/newpath?#fragment"
  end

  it "should have the correct values after a merge" do
    @uri.merge(:authority => "foo:bar@baz:42").to_s.should ==
      "http://foo:bar@baz:42/path/to/resource?query=x#fragment"
    # Ensure the operation was not destructive
    @uri.to_s.should ==
      "http://user:pass@example.com/path/to/resource?query=x#fragment"
  end

  it "should have the correct values after a destructive merge" do
    @uri.merge!(:authority => "foo:bar@baz:42")
    # Ensure the operation was destructive
    @uri.to_s.should ==
      "http://foo:bar@baz:42/path/to/resource?query=x#fragment"
  end

  it "should fail to merge with bogus values" do
    (lambda do
      @uri.merge(:port => "bogus")
    end).should raise_error(Addressable::URI::InvalidURIError)
  end

  it "should fail to merge with bogus values" do
    (lambda do
      @uri.merge(:authority => "bar@baz:bogus")
    end).should raise_error(Addressable::URI::InvalidURIError)
  end

  it "should fail to merge with bogus parameters" do
    (lambda do
      @uri.merge(42)
    end).should raise_error(TypeError)
  end

  it "should fail to merge with bogus parameters" do
    (lambda do
      @uri.merge("http://example.com/")
    end).should raise_error(TypeError)
  end

  it "should fail to merge with both authority and subcomponents" do
    (lambda do
      @uri.merge(:authority => "foo:bar@baz:42", :port => "42")
    end).should raise_error(ArgumentError)
  end

  it "should fail to merge with both userinfo and subcomponents" do
    (lambda do
      @uri.merge(:userinfo => "foo:bar", :user => "foo")
    end).should raise_error(ArgumentError)
  end

  it "should be identical to its duplicate" do
    @uri.should == @uri.dup
  end

  it "should have an origin of 'http://example.com'" do
    @uri.origin.should == 'http://example.com'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/?q&&x=b'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/?q&&x=b")
  end

  it "should have a query of 'q&&x=b'" do
    @uri.query.should == "q&&x=b"
  end

  it "should have query_values of {'q' => true, 'x' => 'b'}" do
    @uri.query_values.should == {'q' => true, 'x' => 'b'}
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/?q=a+b'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/?q=a+b")
  end

  it "should have a query of 'q=a+b'" do
    @uri.query.should == "q=a+b"
  end

  it "should have query_values of {'q' => 'a b'}" do
    @uri.query_values.should == {'q' => 'a b'}
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/?q=a%2bb'" do
  before do
    @uri = Addressable::URI.parse("http://example.com/?q=a%2bb")
  end

  it "should have a query of 'q=a+b'" do
    @uri.query.should == "q=a%2bb"
  end

  it "should have query_values of {'q' => 'a+b'}" do
    @uri.query_values.should == {'q' => 'a+b'}
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/?q='" do
  before do
    @uri = Addressable::URI.parse("http://example.com/?q=")
  end

  it "should have a query of 'q='" do
    @uri.query.should == "q="
  end

  it "should have query_values of {'q' => ''}" do
    @uri.query_values.should == {'q' => ''}
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://user@example.com'" do
  before do
    @uri = Addressable::URI.parse("http://user@example.com")
  end

  it "should use the 'http' scheme" do
    @uri.scheme.should == "http"
  end

  it "should have a username of 'user'" do
    @uri.user.should == "user"
  end

  it "should have no password" do
    @uri.password.should == nil
  end

  it "should have a userinfo of 'user'" do
    @uri.userinfo.should == "user"
  end

  it "should have a normalized userinfo of 'user'" do
    @uri.normalized_userinfo.should == "user"
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should use port 80" do
    @uri.inferred_port.should == 80
  end

  it "should have the correct username after assignment" do
    @uri.user = "newuser"
    @uri.user.should == "newuser"
    @uri.password.should == nil
    @uri.to_s.should == "http://newuser@example.com"
  end

  it "should have the correct password after assignment" do
    @uri.password = "newpass"
    @uri.password.should == "newpass"
    @uri.to_s.should == "http://user:newpass@example.com"
  end

  it "should have the correct userinfo segment after assignment" do
    @uri.userinfo = "newuser:newpass"
    @uri.userinfo.should == "newuser:newpass"
    @uri.user.should == "newuser"
    @uri.password.should == "newpass"
    @uri.host.should == "example.com"
    @uri.port.should == nil
    @uri.inferred_port.should == 80
    @uri.to_s.should == "http://newuser:newpass@example.com"
  end

  it "should have the correct userinfo segment after nil assignment" do
    @uri.userinfo = nil
    @uri.userinfo.should == nil
    @uri.user.should == nil
    @uri.password.should == nil
    @uri.host.should == "example.com"
    @uri.port.should == nil
    @uri.inferred_port.should == 80
    @uri.to_s.should == "http://example.com"
  end

  it "should have the correct authority segment after assignment" do
    @uri.authority = "newuser@example.com"
    @uri.authority.should == "newuser@example.com"
    @uri.user.should == "newuser"
    @uri.password.should == nil
    @uri.host.should == "example.com"
    @uri.port.should == nil
    @uri.inferred_port.should == 80
    @uri.to_s.should == "http://newuser@example.com"
  end

  it "should raise an error after nil assignment of authority segment" do
    (lambda do
      # This would create an invalid URI
      @uri.authority = nil
    end).should raise_error
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://user:@example.com'" do
  before do
    @uri = Addressable::URI.parse("http://user:@example.com")
  end

  it "should use the 'http' scheme" do
    @uri.scheme.should == "http"
  end

  it "should have a username of 'user'" do
    @uri.user.should == "user"
  end

  it "should have a password of ''" do
    @uri.password.should == ""
  end

  it "should have a normalized userinfo of 'user:'" do
    @uri.normalized_userinfo.should == "user:"
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should use port 80" do
    @uri.inferred_port.should == 80
  end

  it "should have the correct username after assignment" do
    @uri.user = "newuser"
    @uri.user.should == "newuser"
    @uri.password.should == ""
    @uri.to_s.should == "http://newuser:@example.com"
  end

  it "should have the correct password after assignment" do
    @uri.password = "newpass"
    @uri.password.should == "newpass"
    @uri.to_s.should == "http://user:newpass@example.com"
  end

  it "should have the correct authority segment after assignment" do
    @uri.authority = "newuser:@example.com"
    @uri.authority.should == "newuser:@example.com"
    @uri.user.should == "newuser"
    @uri.password.should == ""
    @uri.host.should == "example.com"
    @uri.port.should == nil
    @uri.inferred_port.should == 80
    @uri.to_s.should == "http://newuser:@example.com"
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://:pass@example.com'" do
  before do
    @uri = Addressable::URI.parse("http://:pass@example.com")
  end

  it "should use the 'http' scheme" do
    @uri.scheme.should == "http"
  end

  it "should have a username of ''" do
    @uri.user.should == ""
  end

  it "should have a password of 'pass'" do
    @uri.password.should == "pass"
  end

  it "should have a userinfo of ':pass'" do
    @uri.userinfo.should == ":pass"
  end

  it "should have a normalized userinfo of ':pass'" do
    @uri.normalized_userinfo.should == ":pass"
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should use port 80" do
    @uri.inferred_port.should == 80
  end

  it "should have the correct username after assignment" do
    @uri.user = "newuser"
    @uri.user.should == "newuser"
    @uri.password.should == "pass"
    @uri.to_s.should == "http://newuser:pass@example.com"
  end

  it "should have the correct password after assignment" do
    @uri.password = "newpass"
    @uri.password.should == "newpass"
    @uri.user.should == ""
    @uri.to_s.should == "http://:newpass@example.com"
  end

  it "should have the correct authority segment after assignment" do
    @uri.authority = ":newpass@example.com"
    @uri.authority.should == ":newpass@example.com"
    @uri.user.should == ""
    @uri.password.should == "newpass"
    @uri.host.should == "example.com"
    @uri.port.should == nil
    @uri.inferred_port.should == 80
    @uri.to_s.should == "http://:newpass@example.com"
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://:@example.com'" do
  before do
    @uri = Addressable::URI.parse("http://:@example.com")
  end

  it "should use the 'http' scheme" do
    @uri.scheme.should == "http"
  end

  it "should have a username of ''" do
    @uri.user.should == ""
  end

  it "should have a password of ''" do
    @uri.password.should == ""
  end

  it "should have a normalized userinfo of nil" do
    @uri.normalized_userinfo.should == nil
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should use port 80" do
    @uri.inferred_port.should == 80
  end

  it "should have the correct username after assignment" do
    @uri.user = "newuser"
    @uri.user.should == "newuser"
    @uri.password.should == ""
    @uri.to_s.should == "http://newuser:@example.com"
  end

  it "should have the correct password after assignment" do
    @uri.password = "newpass"
    @uri.password.should == "newpass"
    @uri.user.should == ""
    @uri.to_s.should == "http://:newpass@example.com"
  end

  it "should have the correct authority segment after assignment" do
    @uri.authority = ":@newexample.com"
    @uri.authority.should == ":@newexample.com"
    @uri.user.should == ""
    @uri.password.should == ""
    @uri.host.should == "newexample.com"
    @uri.port.should == nil
    @uri.inferred_port.should == 80
    @uri.to_s.should == "http://:@newexample.com"
  end
end

describe Addressable::URI, "when parsed from " +
    "'#example'" do
  before do
    @uri = Addressable::URI.parse("#example")
  end

  it "should be considered relative" do
    @uri.should be_relative
  end

  it "should have a host of nil" do
    @uri.host.should == nil
  end

  it "should have a site of nil" do
    @uri.site.should == nil
  end

  it "should have a normalized_site of nil" do
    @uri.normalized_site.should == nil
  end

  it "should have a path of ''" do
    @uri.path.should == ""
  end

  it "should have a query string of nil" do
    @uri.query.should == nil
  end

  it "should have a fragment of 'example'" do
    @uri.fragment.should == "example"
  end
end

describe Addressable::URI, "when parsed from " +
    "the network-path reference '//example.com/'" do
  before do
    @uri = Addressable::URI.parse("//example.com/")
  end

  it "should be considered relative" do
    @uri.should be_relative
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should have a path of '/'" do
    @uri.path.should == "/"
  end

  it "should raise an error if routing is attempted" do
    (lambda do
      @uri.route_to("http://example.com/")
    end).should raise_error(ArgumentError, /\/\/example.com\//)
    (lambda do
      @uri.route_from("http://example.com/")
    end).should raise_error(ArgumentError, /\/\/example.com\//)
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

describe Addressable::URI, "when parsed from " +
    "'feed://http://example.com/'" do
  before do
    @uri = Addressable::URI.parse("feed://http://example.com/")
  end

  it "should have a host of 'http'" do
    @uri.host.should == "http"
  end

  it "should have a path of '//example.com/'" do
    @uri.path.should == "//example.com/"
  end
end

describe Addressable::URI, "when parsed from " +
    "'feed:http://example.com/'" do
  before do
    @uri = Addressable::URI.parse("feed:http://example.com/")
  end

  it "should have a path of 'http://example.com/'" do
    @uri.path.should == "http://example.com/"
  end

  it "should normalize to 'http://example.com/'" do
    @uri.normalize.to_s.should == "http://example.com/"
    @uri.normalize!.to_s.should == "http://example.com/"
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

describe Addressable::URI, "when parsed from " +
    "'example://a/b/c/%7Bfoo%7D'" do
  before do
    @uri = Addressable::URI.parse("example://a/b/c/%7Bfoo%7D")
  end

  # Section 6.2.2 of RFC 3986
  it "should be equivalent to eXAMPLE://a/./b/../b/%63/%7bfoo%7d" do
    @uri.should ==
      Addressable::URI.parse("eXAMPLE://a/./b/../b/%63/%7bfoo%7d")
  end

  it "should have an origin of 'example://a'" do
    @uri.origin.should == 'example://a'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://example.com/indirect/path/./to/../resource/'" do
  before do
    @uri = Addressable::URI.parse(
      "http://example.com/indirect/path/./to/../resource/")
  end

  it "should use the 'http' scheme" do
    @uri.scheme.should == "http"
  end

  it "should have a host of 'example.com'" do
    @uri.host.should == "example.com"
  end

  it "should use port 80" do
    @uri.inferred_port.should == 80
  end

  it "should have a path of '/indirect/path/./to/../resource/'" do
    @uri.path.should == "/indirect/path/./to/../resource/"
  end

  # Section 6.2.2.3 of RFC 3986
  it "should have a normalized path of '/indirect/path/resource/'" do
    @uri.normalize.path.should == "/indirect/path/resource/"
    @uri.normalize!.path.should == "/indirect/path/resource/"
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://under_score.example.com/'" do
  it "should not cause an error" do
    (lambda do
      Addressable::URI.parse("http://under_score.example.com/")
    end).should_not raise_error
  end
end

describe Addressable::URI, "when parsed from " +
    "'./this:that'" do
  before do
    @uri = Addressable::URI.parse("./this:that")
  end

  it "should be considered relative" do
    @uri.should be_relative
  end

  it "should have no scheme" do
    @uri.scheme.should == nil
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

describe Addressable::URI, "when parsed from " +
    "'this:that'" do
  before do
    @uri = Addressable::URI.parse("this:that")
  end

  it "should be considered absolute" do
    @uri.should be_absolute
  end

  it "should have a scheme of 'this'" do
    @uri.scheme.should == "this"
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

describe Addressable::URI, "when parsed from '?'" do
  before do
    @uri = Addressable::URI.parse("?")
  end

  it "should have the correct subscript notation query values" do
    @uri.query_values.should == {}
    @uri.query_values(:notation => :subscript).should == {}
  end

  it "should have the correct dot notation query values" do
    @uri.query_values(:notation => :dot).should == {}
  end

  it "should have the correct flat notation query values" do
    @uri.query_values(:notation => :flat).should == {}
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

describe Addressable::URI, "when parsed from '?one=1&two=2&three=3'" do
  before do
    @uri = Addressable::URI.parse("?one=1&two=2&three=3")
  end

  it "should have the correct query values" do
    @uri.query_values.should == {"one" => "1", "two" => "2", "three" => "3"}
  end

  it "should raise an error for invalid query value notations" do
    (lambda do
      @uri.query_values(:notation => :bogus)
    end).should raise_error(ArgumentError)
  end

  it "should have the correct flat array notation query values" do
    @uri.query_values(:notation => :flat_array).should == [
      ["one", "1"], ["two", "2"], ["three", "3"]
    ]
  end

  it "should have a 'null' origin" do
    @uri.origin.should == 'null'
  end
end

describe Addressable::URI, "when parsed from '?one=1=uno&two=2=dos'" do
  before do
    @uri = Addressable::URI.parse("?one=1=uno&two=2=dos")
  end

  it "should have the correct query values" do
    @uri.query_values.should == {"one" => "1=uno", "two" => "2=dos"}
  end

  it "should have the correct flat array notation query values" do
    @uri.query_values(:notation => :flat_array).should == [
      ["one", "1=uno"], ["two", "2=dos"]
    ]
  end
end

describe Addressable::URI, "when parsed from '?one[two][three]=four'" do
  before do
    @uri = Addressable::URI.parse("?one[two][three]=four")
  end

  it "should have the correct query values" do
    @uri.query_values.should == {"one" => {"two" => {"three" => "four"}}}
  end

  it "should have the correct flat notation query values" do
    @uri.query_values(:notation => :flat).should == {
      "one[two][three]" => "four"
    }
  end

  it "should have the correct flat array notation query values" do
    @uri.query_values(:notation => :flat_array).should == [
      ["one[two][three]", "four"]
    ]
  end
end

describe Addressable::URI, "when parsed from '?one.two.three=four'" do
  before do
    @uri = Addressable::URI.parse("?one.two.three=four")
  end

  it "should have the correct dot notation query values" do
    @uri.query_values(:notation => :dot).should == {
      "one" => {"two" => {"three" => "four"}}
    }
  end

  it "should have the correct flat notation query values" do
    @uri.query_values(:notation => :flat).should == {
      "one.two.three" => "four"
    }
  end

  it "should have the correct flat array notation query values" do
    @uri.query_values(:notation => :flat_array).should == [
      ["one.two.three", "four"]
    ]
  end
end

describe Addressable::URI, "when parsed from " +
    "'?one[two][three]=four&one[two][five]=six'" do
  before do
    @uri = Addressable::URI.parse("?one[two][three]=four&one[two][five]=six")
  end

  it "should have the correct dot notation query values" do
    @uri.query_values(:notation => :subscript).should == {
      "one" => {"two" => {"three" => "four", "five" => "six"}}
    }
  end

  it "should have the correct flat notation query values" do
    @uri.query_values(:notation => :flat).should == {
      "one[two][three]" => "four",
      "one[two][five]" => "six"
    }
  end

  it "should have the correct flat array notation query values" do
    @uri.query_values(:notation => :flat_array).should == [
      ["one[two][three]", "four"], ["one[two][five]", "six"]
    ]
  end
end

describe Addressable::URI, "when parsed from " +
    "'?one.two.three=four&one.two.five=six'" do
  before do
    @uri = Addressable::URI.parse("?one.two.three=four&one.two.five=six")
  end

  it "should have the correct dot notation query values" do
    @uri.query_values(:notation => :dot).should == {
      "one" => {"two" => {"three" => "four", "five" => "six"}}
    }
  end

  it "should have the correct flat notation query values" do
    @uri.query_values(:notation => :flat).should == {
      "one.two.three" => "four",
      "one.two.five" => "six"
    }
  end

  it "should have the correct flat array notation query values" do
    @uri.query_values(:notation => :flat_array).should == [
      ["one.two.three", "four"], ["one.two.five", "six"]
    ]
  end
end

describe Addressable::URI, "when parsed from " +
    "'?one=two&one=three'" do
  before do
    @uri = Addressable::URI.parse(
      "?one=two&one=three"
    )
  end

  it "should have correct flat_array notation query values" do
    @uri.query_values(:notation => :flat_array).should ==
      [['one', 'two'], ['one', 'three']]
  end
end

describe Addressable::URI, "when parsed from " +
    "'?one[two][three][]=four&one[two][three][]=five'" do
  before do
    @uri = Addressable::URI.parse(
      "?one[two][three][]=four&one[two][three][]=five"
    )
  end

  it "should have the correct subscript notation query values" do
    @uri.query_values(:notation => :subscript).should == {
      "one" => {"two" => {"three" => ["four", "five"]}}
    }
  end

  it "should raise an error if a key is repeated in the flat notation" do
    (lambda do
      @uri.query_values(:notation => :flat)
    end).should raise_error(ArgumentError)
  end

  it "should not raise an error if a key is " +
      "repeated in the flat array notation" do
    (lambda do
      @uri.query_values(:notation => :flat_array)
    end).should_not raise_error
  end
end

describe Addressable::URI, "when parsed from " +
    "'?one[two][three][0]=four&one[two][three][1]=five'" do
  before do
    @uri = Addressable::URI.parse(
      "?one[two][three][0]=four&one[two][three][1]=five"
    )
  end

  it "should have the correct subscript notation query values" do
    @uri.query_values(:notation => :subscript).should == {
      "one" => {"two" => {"three" => ["four", "five"]}}
    }
  end
end

describe Addressable::URI, "when parsed from " +
    "'?one[two][three][1]=four&one[two][three][0]=five'" do
  before do
    @uri = Addressable::URI.parse(
      "?one[two][three][1]=four&one[two][three][0]=five"
    )
  end

  it "should have the correct subscript notation query values" do
    @uri.query_values(:notation => :subscript).should == {
      "one" => {"two" => {"three" => ["five", "four"]}}
    }
  end
end

describe Addressable::URI, "when parsed from " +
    "'?one[two][three][2]=four&one[two][three][1]=five'" do
  before do
    @uri = Addressable::URI.parse(
      "?one[two][three][2]=four&one[two][three][1]=five"
    )
  end

  it "should have the correct subscript notation query values" do
    @uri.query_values(:notation => :subscript).should == {
      "one" => {"two" => {"three" => ["five", "four"]}}
    }
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://www.詹姆斯.com/'" do
  before do
    @uri = Addressable::URI.parse("http://www.詹姆斯.com/")
  end

  it "should be equivalent to 'http://www.xn--8ws00zhy3a.com/'" do
    @uri.should ==
      Addressable::URI.parse("http://www.xn--8ws00zhy3a.com/")
  end

  it "should not have domain name encoded during normalization" do
    Addressable::URI.normalized_encode(@uri.to_s).should ==
      "http://www.詹姆斯.com/"
  end

  it "should have an origin of 'http://www.xn--8ws00zhy3a.com'" do
    @uri.origin.should == 'http://www.xn--8ws00zhy3a.com'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://www.詹姆斯.com/ some spaces /'" do
  before do
    @uri = Addressable::URI.parse("http://www.詹姆斯.com/ some spaces /")
  end

  it "should be equivalent to " +
      "'http://www.xn--8ws00zhy3a.com/%20some%20spaces%20/'" do
    @uri.should ==
      Addressable::URI.parse(
        "http://www.xn--8ws00zhy3a.com/%20some%20spaces%20/")
  end

  it "should not have domain name encoded during normalization" do
    Addressable::URI.normalized_encode(@uri.to_s).should ==
      "http://www.詹姆斯.com/%20some%20spaces%20/"
  end

  it "should have an origin of 'http://www.xn--8ws00zhy3a.com'" do
    @uri.origin.should == 'http://www.xn--8ws00zhy3a.com'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://www.xn--8ws00zhy3a.com/'" do
  before do
    @uri = Addressable::URI.parse("http://www.xn--8ws00zhy3a.com/")
  end

  it "should be displayed as http://www.詹姆斯.com/" do
    @uri.display_uri.to_s.should == "http://www.詹姆斯.com/"
  end

  it "should properly force the encoding" do
    display_string = @uri.display_uri.to_str
    display_string.should == "http://www.詹姆斯.com/"
    if display_string.respond_to?(:encoding)
      display_string.encoding.to_s.should == Encoding::UTF_8.to_s
    end
  end

  it "should have an origin of 'http://www.xn--8ws00zhy3a.com'" do
    @uri.origin.should == 'http://www.xn--8ws00zhy3a.com'
  end
end

describe Addressable::URI, "when parsed from " +
    "'http://www.詹姆斯.com/atomtests/iri/詹.html'" do
  before do
    @uri = Addressable::URI.parse("http://www.詹姆斯.com/atomtests/iri/詹.html")
  end

  it "should normalize to " +
      "http://www.xn--8ws00zhy3a.com/atomtests/iri/%E8%A9%B9.html" do
    @uri.normalize.to_s.should ==
      "http://www.xn--8ws00zhy3a.com/atomtests/iri/%E8%A9%B9.html"
    @uri.normalize!.to_s.should ==
      "http://www.xn--8ws00zhy3a.com/atomtests/iri/%E8%A9%B9.html"
  end
end

describe Addressable::URI, "when parsed from a percent-encoded IRI" do
  before do
    @uri = Addressable::URI.parse(
      "http://www.%E3%81%BB%E3%82%93%E3%81%A8%E3%81%86%E3%81%AB%E3%81%AA" +
      "%E3%81%8C%E3%81%84%E3%82%8F%E3%81%91%E3%81%AE%E3%82%8F%E3%81%8B%E3" +
      "%82%89%E3%81%AA%E3%81%84%E3%81%A9%E3%82%81%E3%81%84%E3%82%93%E3%82" +
      "%81%E3%81%84%E3%81%AE%E3%82%89%E3%81%B9%E3%82%8B%E3%81%BE%E3%81%A0" +
      "%E3%81%AA%E3%81%8C%E3%81%8F%E3%81%97%E3%81%AA%E3%81%84%E3%81%A8%E3" +
      "%81%9F%E3%82%8A%E3%81%AA%E3%81%84.w3.mag.keio.ac.jp"
    )
  end

  it "should normalize to something sane" do
    @uri.normalize.to_s.should ==
      "http://www.xn--n8jaaaaai5bhf7as8fsfk3jnknefdde3f" +
      "g11amb5gzdb4wi9bya3kc6lra.w3.mag.keio.ac.jp/"
    @uri.normalize!.to_s.should ==
      "http://www.xn--n8jaaaaai5bhf7as8fsfk3jnknefdde3f" +
      "g11amb5gzdb4wi9bya3kc6lra.w3.mag.keio.ac.jp/"
  end

  it "should have the correct origin" do
    @uri.origin.should == (
      "http://www.xn--n8jaaaaai5bhf7as8fsfk3jnknefdde3f" +
      "g11amb5gzdb4wi9bya3kc6lra.w3.mag.keio.ac.jp"
    )
  end
end

describe Addressable::URI, "with a base uri of 'http://a/b/c/d;p?q'" do
  before do
    @uri = Addressable::URI.parse("http://a/b/c/d;p?q")
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with 'g:h' should resolve to g:h" do
    (@uri + "g:h").to_s.should == "g:h"
    Addressable::URI.join(@uri, "g:h").to_s.should == "g:h"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with 'g' should resolve to http://a/b/c/g" do
    (@uri + "g").to_s.should == "http://a/b/c/g"
    Addressable::URI.join(@uri.to_s, "g").to_s.should == "http://a/b/c/g"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with './g' should resolve to http://a/b/c/g" do
    (@uri + "./g").to_s.should == "http://a/b/c/g"
    Addressable::URI.join(@uri.to_s, "./g").to_s.should == "http://a/b/c/g"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with 'g/' should resolve to http://a/b/c/g/" do
    (@uri + "g/").to_s.should == "http://a/b/c/g/"
    Addressable::URI.join(@uri.to_s, "g/").to_s.should == "http://a/b/c/g/"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with '/g' should resolve to http://a/g" do
    (@uri + "/g").to_s.should == "http://a/g"
    Addressable::URI.join(@uri.to_s, "/g").to_s.should == "http://a/g"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with '//g' should resolve to http://g" do
    (@uri + "//g").to_s.should == "http://g"
    Addressable::URI.join(@uri.to_s, "//g").to_s.should == "http://g"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with '?y' should resolve to http://a/b/c/d;p?y" do
    (@uri + "?y").to_s.should == "http://a/b/c/d;p?y"
    Addressable::URI.join(@uri.to_s, "?y").to_s.should == "http://a/b/c/d;p?y"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with 'g?y' should resolve to http://a/b/c/g?y" do
    (@uri + "g?y").to_s.should == "http://a/b/c/g?y"
    Addressable::URI.join(@uri.to_s, "g?y").to_s.should == "http://a/b/c/g?y"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with '#s' should resolve to http://a/b/c/d;p?q#s" do
    (@uri + "#s").to_s.should == "http://a/b/c/d;p?q#s"
    Addressable::URI.join(@uri.to_s, "#s").to_s.should ==
      "http://a/b/c/d;p?q#s"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with 'g#s' should resolve to http://a/b/c/g#s" do
    (@uri + "g#s").to_s.should == "http://a/b/c/g#s"
    Addressable::URI.join(@uri.to_s, "g#s").to_s.should == "http://a/b/c/g#s"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with 'g?y#s' should resolve to http://a/b/c/g?y#s" do
    (@uri + "g?y#s").to_s.should == "http://a/b/c/g?y#s"
    Addressable::URI.join(
      @uri.to_s, "g?y#s").to_s.should == "http://a/b/c/g?y#s"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with ';x' should resolve to http://a/b/c/;x" do
    (@uri + ";x").to_s.should == "http://a/b/c/;x"
    Addressable::URI.join(@uri.to_s, ";x").to_s.should == "http://a/b/c/;x"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with 'g;x' should resolve to http://a/b/c/g;x" do
    (@uri + "g;x").to_s.should == "http://a/b/c/g;x"
    Addressable::URI.join(@uri.to_s, "g;x").to_s.should == "http://a/b/c/g;x"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with 'g;x?y#s' should resolve to http://a/b/c/g;x?y#s" do
    (@uri + "g;x?y#s").to_s.should == "http://a/b/c/g;x?y#s"
    Addressable::URI.join(
      @uri.to_s, "g;x?y#s").to_s.should == "http://a/b/c/g;x?y#s"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with '' should resolve to http://a/b/c/d;p?q" do
    (@uri + "").to_s.should == "http://a/b/c/d;p?q"
    Addressable::URI.join(@uri.to_s, "").to_s.should == "http://a/b/c/d;p?q"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with '.' should resolve to http://a/b/c/" do
    (@uri + ".").to_s.should == "http://a/b/c/"
    Addressable::URI.join(@uri.to_s, ".").to_s.should == "http://a/b/c/"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with './' should resolve to http://a/b/c/" do
    (@uri + "./").to_s.should == "http://a/b/c/"
    Addressable::URI.join(@uri.to_s, "./").to_s.should == "http://a/b/c/"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with '..' should resolve to http://a/b/" do
    (@uri + "..").to_s.should == "http://a/b/"
    Addressable::URI.join(@uri.to_s, "..").to_s.should == "http://a/b/"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with '../' should resolve to http://a/b/" do
    (@uri + "../").to_s.should == "http://a/b/"
    Addressable::URI.join(@uri.to_s, "../").to_s.should == "http://a/b/"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with '../g' should resolve to http://a/b/g" do
    (@uri + "../g").to_s.should == "http://a/b/g"
    Addressable::URI.join(@uri.to_s, "../g").to_s.should == "http://a/b/g"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with '../..' should resolve to http://a/" do
    (@uri + "../..").to_s.should == "http://a/"
    Addressable::URI.join(@uri.to_s, "../..").to_s.should == "http://a/"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with '../../' should resolve to http://a/" do
    (@uri + "../../").to_s.should == "http://a/"
    Addressable::URI.join(@uri.to_s, "../../").to_s.should == "http://a/"
  end

  # Section 5.4.1 of RFC 3986
  it "when joined with '../../g' should resolve to http://a/g" do
    (@uri + "../../g").to_s.should == "http://a/g"
    Addressable::URI.join(@uri.to_s, "../../g").to_s.should == "http://a/g"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with '../../../g' should resolve to http://a/g" do
    (@uri + "../../../g").to_s.should == "http://a/g"
    Addressable::URI.join(@uri.to_s, "../../../g").to_s.should == "http://a/g"
  end

  it "when joined with '../.././../g' should resolve to http://a/g" do
    (@uri + "../.././../g").to_s.should == "http://a/g"
    Addressable::URI.join(@uri.to_s, "../.././../g").to_s.should ==
      "http://a/g"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with '../../../../g' should resolve to http://a/g" do
    (@uri + "../../../../g").to_s.should == "http://a/g"
    Addressable::URI.join(
      @uri.to_s, "../../../../g").to_s.should == "http://a/g"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with '/./g' should resolve to http://a/g" do
    (@uri + "/./g").to_s.should == "http://a/g"
    Addressable::URI.join(@uri.to_s, "/./g").to_s.should == "http://a/g"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with '/../g' should resolve to http://a/g" do
    (@uri + "/../g").to_s.should == "http://a/g"
    Addressable::URI.join(@uri.to_s, "/../g").to_s.should == "http://a/g"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with 'g.' should resolve to http://a/b/c/g." do
    (@uri + "g.").to_s.should == "http://a/b/c/g."
    Addressable::URI.join(@uri.to_s, "g.").to_s.should == "http://a/b/c/g."
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with '.g' should resolve to http://a/b/c/.g" do
    (@uri + ".g").to_s.should == "http://a/b/c/.g"
    Addressable::URI.join(@uri.to_s, ".g").to_s.should == "http://a/b/c/.g"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with 'g..' should resolve to http://a/b/c/g.." do
    (@uri + "g..").to_s.should == "http://a/b/c/g.."
    Addressable::URI.join(@uri.to_s, "g..").to_s.should == "http://a/b/c/g.."
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with '..g' should resolve to http://a/b/c/..g" do
    (@uri + "..g").to_s.should == "http://a/b/c/..g"
    Addressable::URI.join(@uri.to_s, "..g").to_s.should == "http://a/b/c/..g"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with './../g' should resolve to http://a/b/g" do
    (@uri + "./../g").to_s.should == "http://a/b/g"
    Addressable::URI.join(@uri.to_s, "./../g").to_s.should == "http://a/b/g"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with './g/.' should resolve to http://a/b/c/g/" do
    (@uri + "./g/.").to_s.should == "http://a/b/c/g/"
    Addressable::URI.join(@uri.to_s, "./g/.").to_s.should == "http://a/b/c/g/"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with 'g/./h' should resolve to http://a/b/c/g/h" do
    (@uri + "g/./h").to_s.should == "http://a/b/c/g/h"
    Addressable::URI.join(@uri.to_s, "g/./h").to_s.should == "http://a/b/c/g/h"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with 'g/../h' should resolve to http://a/b/c/h" do
    (@uri + "g/../h").to_s.should == "http://a/b/c/h"
    Addressable::URI.join(@uri.to_s, "g/../h").to_s.should == "http://a/b/c/h"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with 'g;x=1/./y' " +
      "should resolve to http://a/b/c/g;x=1/y" do
    (@uri + "g;x=1/./y").to_s.should == "http://a/b/c/g;x=1/y"
    Addressable::URI.join(
      @uri.to_s, "g;x=1/./y").to_s.should == "http://a/b/c/g;x=1/y"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with 'g;x=1/../y' should resolve to http://a/b/c/y" do
    (@uri + "g;x=1/../y").to_s.should == "http://a/b/c/y"
    Addressable::URI.join(
      @uri.to_s, "g;x=1/../y").to_s.should == "http://a/b/c/y"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with 'g?y/./x' " +
      "should resolve to http://a/b/c/g?y/./x" do
    (@uri + "g?y/./x").to_s.should == "http://a/b/c/g?y/./x"
    Addressable::URI.join(
      @uri.to_s, "g?y/./x").to_s.should == "http://a/b/c/g?y/./x"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with 'g?y/../x' " +
      "should resolve to http://a/b/c/g?y/../x" do
    (@uri + "g?y/../x").to_s.should == "http://a/b/c/g?y/../x"
    Addressable::URI.join(
      @uri.to_s, "g?y/../x").to_s.should == "http://a/b/c/g?y/../x"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with 'g#s/./x' " +
      "should resolve to http://a/b/c/g#s/./x" do
    (@uri + "g#s/./x").to_s.should == "http://a/b/c/g#s/./x"
    Addressable::URI.join(
      @uri.to_s, "g#s/./x").to_s.should == "http://a/b/c/g#s/./x"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with 'g#s/../x' " +
      "should resolve to http://a/b/c/g#s/../x" do
    (@uri + "g#s/../x").to_s.should == "http://a/b/c/g#s/../x"
    Addressable::URI.join(
      @uri.to_s, "g#s/../x").to_s.should == "http://a/b/c/g#s/../x"
  end

  # Section 5.4.2 of RFC 3986
  it "when joined with 'http:g' should resolve to http:g" do
    (@uri + "http:g").to_s.should == "http:g"
    Addressable::URI.join(@uri.to_s, "http:g").to_s.should == "http:g"
  end

  # Edge case to be sure
  it "when joined with '//example.com/' should " +
      "resolve to http://example.com/" do
    (@uri + "//example.com/").to_s.should == "http://example.com/"
    Addressable::URI.join(
      @uri.to_s, "//example.com/").to_s.should == "http://example.com/"
  end

  it "when joined with a bogus object a TypeError should be raised" do
    (lambda do
      Addressable::URI.join(@uri, 42)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when converting the path " +
    "'relative/path/to/something'" do
  before do
    @path = 'relative/path/to/something'
  end

  it "should convert to " +
      "\'relative/path/to/something\'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.to_str.should == "relative/path/to/something"
  end

  it "should join with an absolute file path correctly" do
    @base = Addressable::URI.convert_path("/absolute/path/")
    @uri = Addressable::URI.convert_path(@path)
    (@base + @uri).to_str.should ==
      "file:///absolute/path/relative/path/to/something"
  end
end

describe Addressable::URI, "when converting a bogus path" do
  it "should raise a TypeError" do
    (lambda do
      Addressable::URI.convert_path(42)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when given a UNIX root directory" do
  before do
    @path = "/"
  end

  it "should convert to \'file:///\'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.to_str.should == "file:///"
  end

  it "should have an origin of 'file://'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.origin.should == 'file://'
  end
end

describe Addressable::URI, "when given a Windows root directory" do
  before do
    @path = "C:\\"
  end

  it "should convert to \'file:///c:/\'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.to_str.should == "file:///c:/"
  end

  it "should have an origin of 'file://'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.origin.should == 'file://'
  end
end

describe Addressable::URI, "when given the path '/home/user/'" do
  before do
    @path = '/home/user/'
  end

  it "should convert to " +
      "\'file:///home/user/\'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.to_str.should == "file:///home/user/"
  end

  it "should have an origin of 'file://'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.origin.should == 'file://'
  end
end

describe Addressable::URI, "when given the path " +
    "'c:\\windows\\My Documents 100%20\\foo.txt'" do
  before do
    @path = "c:\\windows\\My Documents 100%20\\foo.txt"
  end

  it "should convert to " +
      "\'file:///c:/windows/My%20Documents%20100%20/foo.txt\'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.to_str.should == "file:///c:/windows/My%20Documents%20100%20/foo.txt"
  end

  it "should have an origin of 'file://'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.origin.should == 'file://'
  end
end

describe Addressable::URI, "when given the path " +
    "'file://c:\\windows\\My Documents 100%20\\foo.txt'" do
  before do
    @path = "file://c:\\windows\\My Documents 100%20\\foo.txt"
  end

  it "should convert to " +
      "\'file:///c:/windows/My%20Documents%20100%20/foo.txt\'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.to_str.should == "file:///c:/windows/My%20Documents%20100%20/foo.txt"
  end

  it "should have an origin of 'file://'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.origin.should == 'file://'
  end
end

describe Addressable::URI, "when given the path " +
    "'file:c:\\windows\\My Documents 100%20\\foo.txt'" do
  before do
    @path = "file:c:\\windows\\My Documents 100%20\\foo.txt"
  end

  it "should convert to " +
      "\'file:///c:/windows/My%20Documents%20100%20/foo.txt\'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.to_str.should == "file:///c:/windows/My%20Documents%20100%20/foo.txt"
  end

  it "should have an origin of 'file://'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.origin.should == 'file://'
  end
end

describe Addressable::URI, "when given the path " +
    "'file:/c:\\windows\\My Documents 100%20\\foo.txt'" do
  before do
    @path = "file:/c:\\windows\\My Documents 100%20\\foo.txt"
  end

  it "should convert to " +
      "\'file:///c:/windows/My%20Documents%20100%20/foo.txt\'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.to_str.should == "file:///c:/windows/My%20Documents%20100%20/foo.txt"
  end

  it "should have an origin of 'file://'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.origin.should == 'file://'
  end
end

describe Addressable::URI, "when given the path " +
    "'file:///c|/windows/My%20Documents%20100%20/foo.txt'" do
  before do
    @path = "file:///c|/windows/My%20Documents%20100%20/foo.txt"
  end

  it "should convert to " +
      "\'file:///c:/windows/My%20Documents%20100%20/foo.txt\'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.to_str.should == "file:///c:/windows/My%20Documents%20100%20/foo.txt"
  end

  it "should have an origin of 'file://'" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.origin.should == 'file://'
  end
end

describe Addressable::URI, "when given an http protocol URI" do
  before do
    @path = "http://example.com/"
  end

  it "should not do any conversion at all" do
    @uri = Addressable::URI.convert_path(@path)
    @uri.to_str.should == "http://example.com/"
  end
end

class SuperString
  def initialize(string)
    @string = string.to_s
  end

  def to_str
    return @string
  end
end

describe Addressable::URI, "when parsing a non-String object" do
  it "should correctly parse anything with a 'to_str' method" do
    Addressable::URI.parse(SuperString.new(42))
  end

  it "should raise a TypeError for objects than cannot be converted" do
    (lambda do
      Addressable::URI.parse(42)
    end).should raise_error(TypeError, "Can't convert Fixnum into String.")
  end

  it "should correctly parse heuristically anything with a 'to_str' method" do
    Addressable::URI.heuristic_parse(SuperString.new(42))
  end

  it "should raise a TypeError for objects than cannot be converted" do
    (lambda do
      Addressable::URI.heuristic_parse(42)
    end).should raise_error(TypeError, "Can't convert Fixnum into String.")
  end
end

describe Addressable::URI, "when form encoding a hash" do
  it "should result in correct percent encoded sequence" do
    Addressable::URI.form_encode(
      {"&one" => "/1", "=two" => "?2", ":three" => "#3"}
    ).should == "%26one=%2F1&%3Dtwo=%3F2&%3Athree=%233"
  end

  it "should result in correct percent encoded sequence" do
    Addressable::URI.form_encode(
      {"q" => "one two three"}
    ).should == "q=one+two+three"
  end

  it "should result in correct percent encoded sequence" do
    Addressable::URI.form_encode(
      {"key" => nil}
    ).should == "key="
  end

  it "should result in correctly encoded newlines" do
    Addressable::URI.form_encode(
      {"text" => "one\ntwo\rthree\r\nfour\n\r"}
    ).should == "text=one%0D%0Atwo%0D%0Athree%0D%0Afour%0D%0A%0D%0A"
  end

  it "should result in a sorted percent encoded sequence" do
    Addressable::URI.form_encode(
      [["a", "1"], ["dup", "3"], ["dup", "2"]], true
    ).should == "a=1&dup=2&dup=3"
  end
end

describe Addressable::URI, "when form encoding a non-Array object" do
  it "should raise a TypeError for objects than cannot be converted" do
    (lambda do
      Addressable::URI.form_encode(42)
    end).should raise_error(TypeError, "Can't convert Fixnum into Array.")
  end
end

describe Addressable::URI, "when form unencoding a string" do
  it "should result in correct values" do
    Addressable::URI.form_unencode(
      "%26one=%2F1&%3Dtwo=%3F2&%3Athree=%233"
    ).should == [["&one", "/1"], ["=two", "?2"], [":three", "#3"]]
  end

  it "should result in correct values" do
    Addressable::URI.form_unencode(
      "q=one+two+three"
    ).should == [["q", "one two three"]]
  end

  it "should result in correct values" do
    Addressable::URI.form_unencode(
      "text=one%0D%0Atwo%0D%0Athree%0D%0Afour%0D%0A%0D%0A"
    ).should == [["text", "one\ntwo\nthree\nfour\n\n"]]
  end

  it "should result in correct values" do
    Addressable::URI.form_unencode(
      "a=1&dup=2&dup=3"
    ).should == [["a", "1"], ["dup", "2"], ["dup", "3"]]
  end

  it "should result in correct values" do
    Addressable::URI.form_unencode(
      "key"
    ).should == [["key", nil]]
  end

  it "should result in correct values" do
    Addressable::URI.form_unencode("GivenName=Ren%C3%A9").should ==
      [["GivenName", "René"]]
  end
end

describe Addressable::URI, "when form unencoding a non-String object" do
  it "should correctly parse anything with a 'to_str' method" do
    Addressable::URI.form_unencode(SuperString.new(42))
  end

  it "should raise a TypeError for objects than cannot be converted" do
    (lambda do
      Addressable::URI.form_unencode(42)
    end).should raise_error(TypeError, "Can't convert Fixnum into String.")
  end
end

describe Addressable::URI, "when normalizing a non-String object" do
  it "should correctly parse anything with a 'to_str' method" do
    Addressable::URI.normalize_component(SuperString.new(42))
  end

  it "should raise a TypeError for objects than cannot be converted" do
    (lambda do
      Addressable::URI.normalize_component(42)
    end).should raise_error(TypeError, "Can't convert Fixnum into String.")
  end

  it "should raise a TypeError for objects than cannot be converted" do
    (lambda do
      Addressable::URI.normalize_component("component", 42)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when normalizing a path with an encoded slash" do
  it "should result in correct percent encoded sequence" do
    Addressable::URI.parse("/path%2Fsegment/").normalize.path.should ==
      "/path%2Fsegment/"
  end
end

describe Addressable::URI, "when normalizing a partially encoded string" do
  it "should result in correct percent encoded sequence" do
    Addressable::URI.normalize_component(
      "partially % encoded%21"
    ).should == "partially%20%25%20encoded!"
  end

  it "should result in correct percent encoded sequence" do
    Addressable::URI.normalize_component(
      "partially %25 encoded!"
    ).should == "partially%20%25%20encoded!"
  end
end

describe Addressable::URI, "when normalizing a unicode sequence" do
  it "should result in correct percent encoded sequence" do
    Addressable::URI.normalize_component(
      "/C%CC%A7"
    ).should == "/%C3%87"
  end

  it "should result in correct percent encoded sequence" do
    Addressable::URI.normalize_component(
      "/%C3%87"
    ).should == "/%C3%87"
  end
end

describe Addressable::URI, "when normalizing a multibyte string" do
  it "should result in correct percent encoded sequence" do
    Addressable::URI.normalize_component("günther").should ==
      "g%C3%BCnther"
  end

  it "should result in correct percent encoded sequence" do
    Addressable::URI.normalize_component("g%C3%BCnther").should ==
      "g%C3%BCnther"
  end
end

describe Addressable::URI, "when encoding a multibyte string" do
  it "should result in correct percent encoded sequence" do
    Addressable::URI.encode_component("günther").should == "g%C3%BCnther"
  end

  it "should result in correct percent encoded sequence" do
    Addressable::URI.encode_component(
      "günther", /[^a-zA-Z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\-\.\_\~]/
    ).should == "g%C3%BCnther"
  end
end

describe Addressable::URI, "when form encoding a multibyte string" do
  it "should result in correct percent encoded sequence" do
    Addressable::URI.form_encode({"GivenName" => "René"}).should ==
      "GivenName=Ren%C3%A9"
  end
end

describe Addressable::URI, "when encoding a string with ASCII chars 0-15" do
  it "should result in correct percent encoded sequence" do
    Addressable::URI.encode_component("one\ntwo").should == "one%0Atwo"
  end

  it "should result in correct percent encoded sequence" do
    Addressable::URI.encode_component(
      "one\ntwo", /[^a-zA-Z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\-\.\_\~]/
    ).should == "one%0Atwo"
  end
end

describe Addressable::URI, "when unencoding a multibyte string" do
  it "should result in correct percent encoded sequence" do
    Addressable::URI.unencode_component("g%C3%BCnther").should == "günther"
  end

  it "should result in correct percent encoded sequence as a URI" do
    Addressable::URI.unencode(
      "/path?g%C3%BCnther", ::Addressable::URI
    ).should == Addressable::URI.new(
      :path => "/path", :query => "günther"
    )
  end
end

describe Addressable::URI, "when unencoding a bogus object" do
  it "should raise a TypeError" do
    (lambda do
      Addressable::URI.unencode_component(42)
    end).should raise_error(TypeError)
  end

  it "should raise a TypeError" do
    (lambda do
      Addressable::URI.unencode("/path?g%C3%BCnther", Integer)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when encoding a bogus object" do
  it "should raise a TypeError" do
    (lambda do
      Addressable::URI.encode(42)
    end).should raise_error(TypeError)
  end

  it "should raise a TypeError" do
    (lambda do
      Addressable::URI.normalized_encode(42)
    end).should raise_error(TypeError)
  end

  it "should raise a TypeError" do
    (lambda do
      Addressable::URI.encode_component("günther", 42)
    end).should raise_error(TypeError)
  end

  it "should raise a TypeError" do
    (lambda do
      Addressable::URI.encode_component(42)
    end).should raise_error(TypeError)
  end
end

describe Addressable::URI, "when given the input " +
    "'http://example.com/'" do
  before do
    @input = "http://example.com/"
  end

  it "should heuristically parse to 'http://example.com/'" do
    @uri = Addressable::URI.heuristic_parse(@input)
    @uri.to_s.should == "http://example.com/"
  end
end


describe Addressable::URI, "when given the input " +
    "'http:example.com/'" do
  before do
    @input = "http:example.com/"
  end

  it "should heuristically parse to 'http://example.com/'" do
    @uri = Addressable::URI.heuristic_parse(@input)
    @uri.to_s.should == "http://example.com/"
  end

  it "should heuristically parse to 'http://example.com/' " +
      "even with a scheme hint of 'ftp'" do
    @uri = Addressable::URI.heuristic_parse(@input, {:scheme => 'ftp'})
    @uri.to_s.should == "http://example.com/"
  end
end

describe Addressable::URI, "when given the input " +
    "'http://example.com/example.com/'" do
  before do
    @input = "http://example.com/example.com/"
  end

  it "should heuristically parse to 'http://example.com/example.com/'" do
    @uri = Addressable::URI.heuristic_parse(@input)
    @uri.to_s.should == "http://example.com/example.com/"
  end
end

describe Addressable::URI, "when given the input " +
    "'/path/to/resource'" do
  before do
    @input = "/path/to/resource"
  end

  it "should heuristically parse to '/path/to/resource'" do
    @uri = Addressable::URI.heuristic_parse(@input)
    @uri.to_s.should == "/path/to/resource"
  end
end

describe Addressable::URI, "when given the input " +
    "'relative/path/to/resource'" do
  before do
    @input = "relative/path/to/resource"
  end

  it "should heuristically parse to 'relative/path/to/resource'" do
    @uri = Addressable::URI.heuristic_parse(@input)
    @uri.to_s.should == "relative/path/to/resource"
  end
end

describe Addressable::URI, "when given the input " +
    "'example.com'" do
  before do
    @input = "example.com"
  end

  it "should heuristically parse to 'http://example.com'" do
    @uri = Addressable::URI.heuristic_parse(@input)
    @uri.to_s.should == "http://example.com"
  end
end

describe Addressable::URI, "when given the input " +
    "'example.com' and a scheme hint of 'ftp'" do
  before do
    @input = "example.com"
    @hints = {:scheme => 'ftp'}
  end

  it "should heuristically parse to 'http://example.com'" do
    @uri = Addressable::URI.heuristic_parse(@input, @hints)
    @uri.to_s.should == "ftp://example.com"
  end
end

describe Addressable::URI, "when given the input " +
    "'example.com:21' and a scheme hint of 'ftp'" do
  before do
    @input = "example.com:21"
    @hints = {:scheme => 'ftp'}
  end

  it "should heuristically parse to 'http://example.com:21'" do
    @uri = Addressable::URI.heuristic_parse(@input, @hints)
    @uri.to_s.should == "ftp://example.com:21"
  end
end

describe Addressable::URI, "when given the input " +
    "'example.com/path/to/resource'" do
  before do
    @input = "example.com/path/to/resource"
  end

  it "should heuristically parse to 'http://example.com/path/to/resource'" do
    @uri = Addressable::URI.heuristic_parse(@input)
    @uri.to_s.should == "http://example.com/path/to/resource"
  end
end

describe Addressable::URI, "when given the input " +
    "'http:///example.com'" do
  before do
    @input = "http:///example.com"
  end

  it "should heuristically parse to 'http://example.com'" do
    @uri = Addressable::URI.heuristic_parse(@input)
    @uri.to_s.should == "http://example.com"
  end
end

describe Addressable::URI, "when given the input " +
    "'feed:///example.com'" do
  before do
    @input = "feed:///example.com"
  end

  it "should heuristically parse to 'feed://example.com'" do
    @uri = Addressable::URI.heuristic_parse(@input)
    @uri.to_s.should == "feed://example.com"
  end
end

describe Addressable::URI, "when given the input " +
    "'file://path/to/resource/'" do
  before do
    @input = "file://path/to/resource/"
  end

  it "should heuristically parse to 'file:///path/to/resource/'" do
    @uri = Addressable::URI.heuristic_parse(@input)
    @uri.to_s.should == "file:///path/to/resource/"
  end
end

describe Addressable::URI, "when given the input " +
    "'feed://http://example.com'" do
  before do
    @input = "feed://http://example.com"
  end

  it "should heuristically parse to 'feed:http://example.com'" do
    @uri = Addressable::URI.heuristic_parse(@input)
    @uri.to_s.should == "feed:http://example.com"
  end
end

describe Addressable::URI, "when assigning query values" do
  before do
    @uri = Addressable::URI.new
  end

  it "should correctly assign {:a => 'a', :b => ['c', 'd', 'e']}" do
    @uri.query_values = {:a => "a", :b => ["c", "d", "e"]}
    @uri.query.should == "a=a&b[0]=c&b[1]=d&b[2]=e"
  end

  it "should correctly assign " +
      "{:a => 'a', :b => [{:c => 'c', :d => 'd'}, {:e => 'e', :f => 'f'}]}" do
    @uri.query_values = {
      :a => "a", :b => [{:c => "c", :d => "d"}, {:e => "e", :f => "f"}]
    }
    @uri.query.should == "a=a&b[0][c]=c&b[0][d]=d&b[1][e]=e&b[1][f]=f"
  end

  it "should correctly assign " +
      "{:a => 'a', :b => [{:c => true, :d => 'd'}, {:e => 'e', :f => 'f'}]}" do
    @uri.query_values = {
      :a => 'a', :b => [{:c => true, :d => 'd'}, {:e => 'e', :f => 'f'}]
    }
    @uri.query.should == "a=a&b[0][c]&b[0][d]=d&b[1][e]=e&b[1][f]=f"
  end

  it "should correctly assign " +
      "{:a => 'a', :b => {:c => true, :d => 'd'}}" do
    @uri.query_values = {
      :a => 'a', :b => {:c => true, :d => 'd'}
    }
    @uri.query.should == "a=a&b[c]&b[d]=d"
  end

  it "should correctly assign " +
      "{:a => 'a', :b => {:c => true, :d => 'd'}, :e => []}" do
    @uri.query_values = {
      :a => 'a', :b => {:c => true, :d => 'd'}
    }
    @uri.query.should == "a=a&b[c]&b[d]=d"
  end

  it "should correctly assign {}" do
    @uri.query_values = {}
    @uri.query.should == ''
  end

  it "should correctly assign nil" do
    @uri.query_values = nil
    @uri.query.should == nil
  end

  it "should correctly sort {'ab' => 'c', :ab => 'a', :a => 'x'}" do
    @uri.query_values = {'ab' => 'c', :ab => 'a', :a => 'x'}
    @uri.query.should == "a=x&ab=a&ab=c"
  end

  it "should correctly assign " +
      "[['b', 'c'], ['b', 'a'], ['a', 'a']]" do
    # Order can be guaranteed in this format, so preserve it.
    @uri.query_values = [['b', 'c'], ['b', 'a'], ['a', 'a']]
    @uri.query.should == "b=c&b=a&a=a"
  end

  it "should preserve query string order" do
    query_string = (('a'..'z').to_a.shuffle.map { |e| "#{e}=#{e}" }).join("&")
    @uri.query = query_string
    original_uri = @uri.to_s
    @uri.query_values = @uri.query_values(:notation => :flat_array)
    @uri.to_s.should == original_uri
  end
end

describe Addressable::URI, "when assigning path values" do
  before do
    @uri = Addressable::URI.new
  end

  it "should correctly assign paths containing colons" do
    @uri.path = "acct:bob@sporkmonger.com"
    Addressable::URI.parse(@uri.normalize.to_str).path.should == @uri.path
    @uri.normalize.to_str.should == "acct%2Fbob@sporkmonger.com"
  end

  it "should correctly assign paths containing colons" do
    @uri.path = "/acct:bob@sporkmonger.com"
    @uri.authority = "example.com"
    @uri.normalize.to_str.should == "//example.com/acct:bob@sporkmonger.com"
  end

  it "should correctly assign paths containing colons" do
    @uri.path = "acct:bob@sporkmonger.com"
    @uri.scheme = "something"
    @uri.normalize.to_str.should == "something:acct:bob@sporkmonger.com"
  end

  it "should not allow relative paths to be assigned on absolute URIs" do
    (lambda do
      @uri.scheme = "http"
      @uri.host = "example.com"
      @uri.path = "acct:bob@sporkmonger.com"
    end).should raise_error(Addressable::URI::InvalidURIError)
  end

  it "should not allow relative paths to be assigned on absolute URIs" do
    (lambda do
      @uri.path = "acct:bob@sporkmonger.com"
      @uri.scheme = "http"
      @uri.host = "example.com"
    end).should raise_error(Addressable::URI::InvalidURIError)
  end

  it "should not allow relative paths to be assigned on absolute URIs" do
    (lambda do
      @uri.path = "uuid:0b3ecf60-3f93-11df-a9c3-001f5bfffe12"
      @uri.scheme = "urn"
    end).should_not raise_error(Addressable::URI::InvalidURIError)
  end
end
#
#  tkextlib/iwidgets/scrolledhtml.rb
#                               by Hidetoshi NAGAI (nagai@ai.kyutech.ac.jp)
#

require 'tk'
require 'tkextlib/iwidgets.rb'

module Tk
  module Iwidgets
    class Scrolledhtml < Tk::Iwidgets::Scrolledtext
    end
  end
end

class Tk::Iwidgets::Scrolledhtml
  TkCommandNames = ['::iwidgets::scrolledhtml'.freeze].freeze
  WidgetClassName = 'Scrolledhtml'.freeze
  WidgetClassNames[WidgetClassName] ||= self

  def __boolval_optkeys
    super() << 'update'
  end
  private :__boolval_optkeys

  def __strval_optkeys
    super() << 'fontname' << 'link' << 'alink' << 'textbackground'
  end
  private :__strval_optkeys

  def __font_optkeys
    super() << 'fixedfont'
  end
  private :__font_optkeys

  def import(href)
    tk_call(@path, 'import', href)
    self
  end

  def import_link(href)
    tk_call(@path, 'import', '-link', href)
    self
  end

  def pwd
    tk_call(@path, 'pwd')
  end

  def render(htmltext, workdir=None)
    tk_call(@path, 'render', htmltext, workdir)
    self
  end

  def title
    tk_call(@path, 'title')
  end
end
module TZInfo
  module Definitions
    module America
      module Santa_Isabel
        include TimezoneDefinition
        
        timezone 'America/Santa_Isabel' do |tz|
          tz.offset :o0, -27568, 0, :LMT
          tz.offset :o1, -25200, 0, :MST
          tz.offset :o2, -28800, 0, :PST
          tz.offset :o3, -28800, 3600, :PDT
          tz.offset :o4, -28800, 3600, :PWT
          tz.offset :o5, -28800, 3600, :PPT
          
          tz.transition 1922, 1, :o1, 14538335, 6
          tz.transition 1924, 1, :o2, 58170859, 24
          tz.transition 1927, 6, :o1, 58201027, 24
          tz.transition 1930, 11, :o2, 58231099, 24
          tz.transition 1931, 4, :o3, 14558597, 6
          tz.transition 1931, 9, :o2, 58238755, 24
          tz.transition 1942, 4, :o4, 14582843, 6
          tz.transition 1945, 8, :o5, 58360379, 24
          tz.transition 1945, 11, :o2, 58362523, 24
          tz.transition 1948, 4, :o3, 14595881, 6
          tz.transition 1949, 1, :o2, 58390339, 24
          tz.transition 1954, 4, :o3, 29218295, 12
          tz.transition 1954, 9, :o2, 19480095, 8
          tz.transition 1955, 4, :o3, 29222663, 12
          tz.transition 1955, 9, :o2, 19483007, 8
          tz.transition 1956, 4, :o3, 29227115, 12
          tz.transition 1956, 9, :o2, 19485975, 8
          tz.transition 1957, 4, :o3, 29231483, 12
          tz.transition 1957, 9, :o2, 19488887, 8
          tz.transition 1958, 4, :o3, 29235851, 12
          tz.transition 1958, 9, :o2, 19491799, 8
          tz.transition 1959, 4, :o3, 29240219, 12
          tz.transition 1959, 9, :o2, 19494711, 8
          tz.transition 1960, 4, :o3, 29244587, 12
          tz.transition 1960, 9, :o2, 19497623, 8
          tz.transition 1976, 4, :o3, 199274400
          tz.transition 1976, 10, :o2, 215600400
          tz.transition 1977, 4, :o3, 230724000
          tz.transition 1977, 10, :o2, 247050000
          tz.transition 1978, 4, :o3, 262778400
          tz.transition 1978, 10, :o2, 278499600
          tz.transition 1979, 4, :o3, 294228000
          tz.transition 1979, 10, :o2, 309949200
          tz.transition 1980, 4, :o3, 325677600
          tz.transition 1980, 10, :o2, 341398800
          tz.transition 1981, 4, :o3, 357127200
          tz.transition 1981, 10, :o2, 372848400
          tz.transition 1982, 4, :o3, 388576800
          tz.transition 1982, 10, :o2, 404902800
          tz.transition 1983, 4, :o3, 420026400
          tz.transition 1983, 10, :o2, 436352400
          tz.transition 1984, 4, :o3, 452080800
          tz.transition 1984, 10, :o2, 467802000
          tz.transition 1985, 4, :o3, 483530400
          tz.transition 1985, 10, :o2, 499251600
          tz.transition 1986, 4, :o3, 514980000
          tz.transition 1986, 10, :o2, 530701200
          tz.transition 1987, 4, :o3, 544615200
          tz.transition 1987, 10, :o2, 562150800
          tz.transition 1988, 4, :o3, 576064800
          tz.transition 1988, 10, :o2, 594205200
          tz.transition 1989, 4, :o3, 607514400
          tz.transition 1989, 10, :o2, 625654800
          tz.transition 1990, 4, :o3, 638964000
          tz.transition 1990, 10, :o2, 657104400
          tz.transition 1991, 4, :o3, 671018400
          tz.transition 1991, 10, :o2, 688554000
          tz.transition 1992, 4, :o3, 702468000
          tz.transition 1992, 10, :o2, 720003600
          tz.transition 1993, 4, :o3, 733917600
          tz.transition 1993, 10, :o2, 752058000
          tz.transition 1994, 4, :o3, 765367200
          tz.transition 1994, 10, :o2, 783507600
          tz.transition 1995, 4, :o3, 796816800
          tz.transition 1995, 10, :o2, 814957200
          tz.transition 1996, 4, :o3, 828871200
          tz.transition 1996, 10, :o2, 846406800
          tz.transition 1997, 4, :o3, 860320800
          tz.transition 1997, 10, :o2, 877856400
          tz.transition 1998, 4, :o3, 891770400
          tz.transition 1998, 10, :o2, 909306000
          tz.transition 1999, 4, :o3, 923220000
          tz.transition 1999, 10, :o2, 941360400
          tz.transition 2000, 4, :o3, 954669600
          tz.transition 2000, 10, :o2, 972810000
          tz.transition 2001, 4, :o3, 986119200
          tz.transition 2001, 10, :o2, 1004259600
          tz.transition 2002, 4, :o3, 1018173600
          tz.transition 2002, 10, :o2, 1035709200
          tz.transition 2003, 4, :o3, 1049623200
          tz.transition 2003, 10, :o2, 1067158800
          tz.transition 2004, 4, :o3, 1081072800
          tz.transition 2004, 10, :o2, 1099213200
          tz.transition 2005, 4, :o3, 1112522400
          tz.transition 2005, 10, :o2, 1130662800
          tz.transition 2006, 4, :o3, 1143972000
          tz.transition 2006, 10, :o2, 1162112400
          tz.transition 2007, 4, :o3, 1175421600
          tz.transition 2007, 10, :o2, 1193562000
          tz.transition 2008, 4, :o3, 1207476000
          tz.transition 2008, 10, :o2, 1225011600
          tz.transition 2009, 4, :o3, 1238925600
          tz.transition 2009, 10, :o2, 1256461200
          tz.transition 2010, 4, :o3, 1270375200
          tz.transition 2010, 10, :o2, 1288515600
          tz.transition 2011, 4, :o3, 1301824800
          tz.transition 2011, 10, :o2, 1319965200
          tz.transition 2012, 4, :o3, 1333274400
          tz.transition 2012, 10, :o2, 1351414800
          tz.transition 2013, 4, :o3, 1365328800
          tz.transition 2013, 10, :o2, 1382864400
          tz.transition 2014, 4, :o3, 1396778400
          tz.transition 2014, 10, :o2, 1414314000
          tz.transition 2015, 4, :o3, 1428228000
          tz.transition 2015, 10, :o2, 1445763600
          tz.transition 2016, 4, :o3, 1459677600
          tz.transition 2016, 10, :o2, 1477818000
          tz.transition 2017, 4, :o3, 1491127200
          tz.transition 2017, 10, :o2, 1509267600
          tz.transition 2018, 4, :o3, 1522576800
          tz.transition 2018, 10, :o2, 1540717200
          tz.transition 2019, 4, :o3, 1554631200
          tz.transition 2019, 10, :o2, 1572166800
          tz.transition 2020, 4, :o3, 1586080800
          tz.transition 2020, 10, :o2, 1603616400
          tz.transition 2021, 4, :o3, 1617530400
          tz.transition 2021, 10, :o2, 1635670800
          tz.transition 2022, 4, :o3, 1648980000
          tz.transition 2022, 10, :o2, 1667120400
          tz.transition 2023, 4, :o3, 1680429600
          tz.transition 2023, 10, :o2, 1698570000
          tz.transition 2024, 4, :o3, 1712484000
          tz.transition 2024, 10, :o2, 1730019600
          tz.transition 2025, 4, :o3, 1743933600
          tz.transition 2025, 10, :o2, 1761469200
          tz.transition 2026, 4, :o3, 1775383200
          tz.transition 2026, 10, :o2, 1792918800
          tz.transition 2027, 4, :o3, 1806832800
          tz.transition 2027, 10, :o2, 1824973200
          tz.transition 2028, 4, :o3, 1838282400
          tz.transition 2028, 10, :o2, 1856422800
          tz.transition 2029, 4, :o3, 1869732000
          tz.transition 2029, 10, :o2, 1887872400
          tz.transition 2030, 4, :o3, 1901786400
          tz.transition 2030, 10, :o2, 1919322000
          tz.transition 2031, 4, :o3, 1933236000
          tz.transition 2031, 10, :o2, 1950771600
          tz.transition 2032, 4, :o3, 1964685600
          tz.transition 2032, 10, :o2, 1982826000
          tz.transition 2033, 4, :o3, 1996135200
          tz.transition 2033, 10, :o2, 2014275600
          tz.transition 2034, 4, :o3, 2027584800
          tz.transition 2034, 10, :o2, 2045725200
          tz.transition 2035, 4, :o3, 2059034400
          tz.transition 2035, 10, :o2, 2077174800
          tz.transition 2036, 4, :o3, 2091088800
          tz.transition 2036, 10, :o2, 2108624400
          tz.transition 2037, 4, :o3, 2122538400
          tz.transition 2037, 10, :o2, 2140074000
          tz.transition 2038, 4, :o3, 29586215, 12
          tz.transition 2038, 10, :o2, 19725823, 8
          tz.transition 2039, 4, :o3, 29590583, 12
          tz.transition 2039, 10, :o2, 19728735, 8
          tz.transition 2040, 4, :o3, 29594951, 12
          tz.transition 2040, 10, :o2, 19731647, 8
          tz.transition 2041, 4, :o3, 29599403, 12
          tz.transition 2041, 10, :o2, 19734559, 8
          tz.transition 2042, 4, :o3, 29603771, 12
          tz.transition 2042, 10, :o2, 19737471, 8
          tz.transition 2043, 4, :o3, 29608139, 12
          tz.transition 2043, 10, :o2, 19740383, 8
          tz.transition 2044, 4, :o3, 29612507, 12
          tz.transition 2044, 10, :o2, 19743351, 8
          tz.transition 2045, 4, :o3, 29616875, 12
          tz.transition 2045, 10, :o2, 19746263, 8
          tz.transition 2046, 4, :o3, 29621243, 12
          tz.transition 2046, 10, :o2, 19749175, 8
          tz.transition 2047, 4, :o3, 29625695, 12
          tz.transition 2047, 10, :o2, 19752087, 8
          tz.transition 2048, 4, :o3, 29630063, 12
          tz.transition 2048, 10, :o2, 19754999, 8
          tz.transition 2049, 4, :o3, 29634431, 12
          tz.transition 2049, 10, :o2, 19757967, 8
          tz.transition 2050, 4, :o3, 29638799, 12
          tz.transition 2050, 10, :o2, 19760879, 8
        end
      end
    end
  end
end
##
# Wrapper for the Pygments command line tool, pygmentize.
#
# Pygments: http://pygments.org/
#
# Assumes pygmentize is in the path.  If not, set its location
# with Albino.bin = '/path/to/pygmentize'
#
# Use like so:
#
#   @syntaxer = Albino.new('/some/file.rb', :ruby)
#   puts @syntaxer.colorize
#
# This'll print out an HTMLized, Ruby-highlighted version
# of '/some/file.rb'.
#
# To use another formatter, pass it as the third argument:
#
#   @syntaxer = Albino.new('/some/file.rb', :ruby, :bbcode)
#   puts @syntaxer.colorize
#
# You can also use the #colorize class method:
#
#   puts Albino.colorize('/some/file.rb', :ruby)
#
# Another also: you get a #to_s, for somewhat nicer use in Rails views.
#
#   ... helper file ...
#   def highlight(text)
#     Albino.new(text, :ruby)
#   end
#
#   ... view file ...
#   <%= highlight text %>
#
# The default lexer is 'text'.  You need to specify a lexer yourself;
# because we are using STDIN there is no auto-detect.
#
# To see all lexers and formatters available, run `pygmentize -L`.
#
# Chris Wanstrath // chris@ozmm.org
#         GitHub // http://github.com
#

class Albino
  @@bin = Rails.development? ? 'pygmentize' : '/usr/bin/pygmentize' rescue 'pygmentize'

  def self.bin=(path)
    @@bin = path
  end

  def self.colorize(*args)
    new(*args).colorize
  end

  def initialize(target, lexer = :text, format = :html)
    @target  = target
    @options = { :l => lexer, :f => format, :O => 'encoding=utf-8' }
  end

  def execute(command)
    output = ''
    IO.popen(command, mode='r+') do |p|
      p.write @target
      p.close_write
      output = p.read.strip
    end
    output
  end

  def colorize(options = {})
    html = execute(@@bin + convert_options(options))
    # Work around an RDiscount bug: http://gist.github.com/97682
    html.to_s.sub(%r{</pre></div>\Z}, "</pre>\n</div>")
  end
  alias_method :to_s, :colorize

  def convert_options(options = {})
    @options.merge(options).inject('') do |string, (flag, value)|
      string + " -#{flag} #{value}"
    end
  end
end

if $0 == __FILE__
  require 'rubygems'
  require 'test/spec'
  require 'mocha'
  begin require 'redgreen'; rescue LoadError; end

  context "Albino" do
    setup do
      @syntaxer = Albino.new(__FILE__, :ruby)
    end

    specify "defaults to text" do
      syntaxer = Albino.new(__FILE__)
      syntaxer.expects(:execute).with('pygmentize -f html -l text').returns(true)
      syntaxer.colorize
    end

    specify "accepts options" do
      @syntaxer.expects(:execute).with('pygmentize -f html -l ruby').returns(true)
      @syntaxer.colorize
    end

    specify "works with strings" do
      syntaxer = Albino.new('class New; end', :ruby)
      assert_match %r(highlight), syntaxer.colorize
    end

    specify "aliases to_s" do
      assert_equal @syntaxer.colorize, @syntaxer.to_s
    end

    specify "class method colorize" do
      assert_equal @syntaxer.colorize, Albino.colorize(__FILE__, :ruby)
    end
  end
end
module Mail
  autoload :UnstructuredField, 'mail/fields/unstructured_field'
  autoload :StructuredField, 'mail/fields/structured_field'
  autoload :OptionalField, 'mail/fields/optional_field'

  autoload :BccField, 'mail/fields/bcc_field'
  autoload :CcField, 'mail/fields/cc_field'
  autoload :CommentsField, 'mail/fields/comments_field'
  autoload :ContentDescriptionField, 'mail/fields/content_description_field'
  autoload :ContentDispositionField, 'mail/fields/content_disposition_field'
  autoload :ContentIdField, 'mail/fields/content_id_field'
  autoload :ContentLocationField, 'mail/fields/content_location_field'
  autoload :ContentTransferEncodingField, 'mail/fields/content_transfer_encoding_field'
  autoload :ContentTypeField, 'mail/fields/content_type_field'
  autoload :DateField, 'mail/fields/date_field'
  autoload :FromField, 'mail/fields/from_field'
  autoload :InReplyToField, 'mail/fields/in_reply_to_field'
  autoload :KeywordsField, 'mail/fields/keywords_field'
  autoload :MessageIdField, 'mail/fields/message_id_field'
  autoload :MimeVersionField, 'mail/fields/mime_version_field'
  autoload :ReceivedField, 'mail/fields/received_field'
  autoload :ReferencesField, 'mail/fields/references_field'
  autoload :ReplyToField, 'mail/fields/reply_to_field'
  autoload :ResentBccField, 'mail/fields/resent_bcc_field'
  autoload :ResentCcField, 'mail/fields/resent_cc_field'
  autoload :ResentDateField, 'mail/fields/resent_date_field'
  autoload :ResentFromField, 'mail/fields/resent_from_field'
  autoload :ResentMessageIdField, 'mail/fields/resent_message_id_field'
  autoload :ResentSenderField, 'mail/fields/resent_sender_field'
  autoload :ResentToField, 'mail/fields/resent_to_field'
  autoload :ReturnPathField, 'mail/fields/return_path_field'
  autoload :SenderField, 'mail/fields/sender_field'
  autoload :SubjectField, 'mail/fields/subject_field'
  autoload :ToField, 'mail/fields/to_field'
end
#!/usr/bin/env ruby
require File.dirname(__FILE__) + '/../test_helper'
require 'sass/plugin'
require File.dirname(__FILE__) + '/mocks/article'

require 'action_pack/version'

module Haml::Filters::Test
  include Haml::Filters::Base

  def render(text)
    "TESTING HAHAHAHA!"
  end
end

module Haml::Helpers
  def test_partial(name, locals = {})
    Haml::Engine.new(File.read(File.join(TemplateTest::TEMPLATE_PATH, "_#{name}.haml"))).render(self, locals)
  end
end

class Egocentic
  def method_missing(*args)
    self
  end
end

class DummyController
  attr_accessor :logger
  def initialize
    @logger = Egocentic.new
  end
    
  def self.controller_path
    ''
  end

  def controller_path
    ''
  end
end

class TemplateTest < Test::Unit::TestCase
  TEMPLATE_PATH = File.join(File.dirname(__FILE__), "templates")
  TEMPLATES = %w{         very_basic        standard    helpers
    whitespace_handling   original_engine   list        helpful
    silent_script         tag_parsing       just_stuff  partials
    filters               nuke_outer_whitespace         nuke_inner_whitespace
    render_layout }
  # partial layouts were introduced in 2.0.0
  TEMPLATES << 'partial_layout' unless ActionPack::VERSION::MAJOR < 2

  def setup
    @base = create_base

    # filters template uses :sass
    Sass::Plugin.options.update(:line_comments => true, :style => :compact)
  end

  def create_base
    vars = { 'article' => Article.new, 'foo' => 'value one' }
    
    unless Haml::Util.has?(:instance_method, ActionView::Base, :finder)
      base = ActionView::Base.new(TEMPLATE_PATH, vars)
    else
      # Rails 2.1.0
      base = ActionView::Base.new([], vars)
      base.finder.append_view_path(TEMPLATE_PATH)
    end
    
    if Haml::Util.has?(:private_method, base, :evaluate_assigns)
      # Rails < 3.0
      base.send(:evaluate_assigns)
    elsif Haml::Util.has?(:private_method, base, :_evaluate_assigns_and_ivars)
      # Rails 2.2
      base.send(:_evaluate_assigns_and_ivars)
    end

    # This is needed by RJS in (at least) Rails 3
    base.instance_variable_set('@template', base)

    # This is used by form_for.
    # It's usually provided by ActionController::Base.
    def base.protect_against_forgery?; false; end

    # In Rails <= 2.1, a fake controller object was needed
    # to provide the controller path.
    if ActionPack::VERSION::MAJOR < 2 ||
        (ActionPack::VERSION::MAJOR == 2 && ActionPack::VERSION::MINOR < 2)
      base.controller = DummyController.new
    end

    base
  end

  def render(text, opts = {})
    return @base.render(:inline => text, :type => :haml) if opts == :action_view
    Haml::Engine.new(text, opts).to_html(@base)
  end

  def load_result(name)
    @result = ''
    File.new(File.dirname(__FILE__) + "/results/#{name}.xhtml").each_line { |l| @result += l }
    @result
  end

  def assert_renders_correctly(name, &render_method)
    old_options = Haml::Template.options.dup
    Haml::Template.options[:escape_html] = false
    if ActionPack::VERSION::MAJOR < 2 ||
        (ActionPack::VERSION::MAJOR == 2 && ActionPack::VERSION::MINOR < 2)
      render_method ||= proc { |name| @base.render(name) }
    else
      render_method ||= proc { |name| @base.render(:file => name) }
    end

    load_result(name).split("\n").zip(render_method[name].split("\n")).each_with_index do |pair, line|
      message = "template: #{name}\nline:     #{line}"
      assert_equal(pair.first, pair.last, message)
    end
  rescue Haml::Util.av_template_class(:Error) => e
    if e.message =~ /Can't run [\w:]+ filter; required (one of|file) ((?:'\w+'(?: or )?)+)(, but none were found| not found)/
      puts "\nCouldn't require #{$2}; skipping a test."
    else
      raise e
    end
  ensure
    Haml::Template.options = old_options
  end

  def test_empty_render_should_remain_empty
    assert_equal('', render(''))
  end

  TEMPLATES.each do |template|
    define_method "test_template_should_render_correctly [template: #{template}] " do
      assert_renders_correctly template
    end
  end

  def test_templates_should_render_correctly_with_render_proc
    assert_renders_correctly("standard") do |name|
      engine = Haml::Engine.new(File.read(File.dirname(__FILE__) + "/templates/#{name}.haml"))
      engine.render_proc(@base).call
    end
  end
  
  def test_templates_should_render_correctly_with_def_method
    assert_renders_correctly("standard") do |name|
      engine = Haml::Engine.new(File.read(File.dirname(__FILE__) + "/templates/#{name}.haml"))
      engine.def_method(@base, "render_standard")
      @base.render_standard
    end
  end

  if ActionPack::VERSION::MAJOR < 3
    # Rails 3.0.0 deprecates the use of yield with a layout
    # for calls to render :file
    def test_action_view_templates_render_correctly
      proc = lambda do
        @base.content_for(:layout) {'Lorem ipsum dolor sit amet'}
        assert_renders_correctly 'content_for_layout'
      end

      if @base.respond_to?(:with_output_buffer)
        @base.with_output_buffer("", &proc)
      else
        proc.call
      end
    end
  end

  def test_instance_variables_should_work_inside_templates
    @base.instance_variable_set("@content_for_layout", 'something')
    assert_equal("<p>something</p>", render("%p= @content_for_layout").chomp)

    @base.instance_eval("@author = 'Hampton Catlin'")
    assert_equal("<div class='author'>Hampton Catlin</div>", render(".author= @author").chomp)

    @base.instance_eval("@author = 'Hampton'")
    assert_equal("Hampton", render("= @author").chomp)

    @base.instance_eval("@author = 'Catlin'")
    assert_equal("Catlin", render("= @author").chomp)
  end

  def test_instance_variables_should_work_inside_attributes
    @base.instance_eval("@author = 'hcatlin'")
    assert_equal("<p class='hcatlin'>foo</p>", render("%p{:class => @author} foo").chomp)
  end

  def test_template_renders_should_eval
    assert_equal("2\n", render("= 1+1"))
  end

  unless Haml::Util.ap_geq_3?
    def test_form_for_error_return
      assert_raise(Haml::Error) { render(<<HAML) }
= form_for :article, @article, :url => '' do |f|
  Title:
  = f.text_field :title
  Body:
  = f.text_field :body
HAML
    end

    def test_form_tag_error_return
      assert_raise(Haml::Error) { render(<<HAML) }
= form_tag '' do
  Title:
  Body:
HAML
    end
  end

  def test_haml_options
    old_options = Haml::Template.options.dup
    Haml::Template.options[:suppress_eval] = true
    old_base, @base = @base, create_base
    assert_renders_correctly("eval_suppressed")
  ensure
    @base = old_base
    Haml::Template.options = old_options
  end

  def test_with_output_buffer_with_ugly
    return unless Haml::Util.has?(:instance_method, ActionView::Base, :with_output_buffer)
    assert_equal(<<HTML, render(<<HAML, :ugly => true))
<p>
foo
baz
</p>
HTML
%p
  foo
  -# Parenthesis required due to Rails 3.0 deprecation of block helpers
  -# that return strings.
  - (with_output_buffer do
    bar
    = "foo".gsub(/./) do |s|
      - "flup"
  - end; nil)
  baz
HAML
  end

  def test_exceptions_should_work_correctly
    begin
      render("- raise 'oops!'")
    rescue Exception => e
      assert_equal("oops!", e.message)
      assert_match(/^\(haml\):1/, e.backtrace[0])
    else
      assert false
    end

    template = <<END
%p
  %h1 Hello!
  = "lots of lines"
  = "even more!"
  - raise 'oh no!'
  %p
    this is after the exception
    %strong yes it is!
ho ho ho.
END

    begin
      render(template.chomp)
    rescue Exception => e
      assert_match(/^\(haml\):5/, e.backtrace[0])
    else
      assert false
    end
  end

  if defined?(ActionView::OutputBuffer) &&
      Haml::Util.has?(:instance_method, ActionView::OutputBuffer, :append_if_string=)
    def test_av_block_deprecation_warning
      assert_warning(/^DEPRECATION WARNING: - style block helpers are deprecated\. Please use =\./) do
        assert_equal <<HTML, render(<<HAML, :action_view)
<form #{rails_form_attr}action="" method="post">#{rails_form_opener}
  Title:
  <input id="article_title" name="article[title]" size="30" type="text" value="Hello" />
  Body:
  <input id="article_body" name="article[body]" size="30" type="text" value="World" />
</form>
HTML
- form_for #{form_for_calling_convention(:article)}, :url => '' do |f|
  Title:
  = f.text_field :title
  Body:
  = f.text_field :body
HAML
      end
    end
  end

  ## XSS Protection Tests

  # In order to enable these, either test against Rails 3.0
  # or test against Rails 2.2.5+ with the rails_xss plugin
  # (http://github.com/NZKoz/rails_xss) in test/plugins.
  if Haml::Util.rails_xss_safe?
    def test_escape_html_option_set
      assert Haml::Template.options[:escape_html]
    end

    def test_xss_protection
      assert_equal("Foo &amp; Bar\n", render('= "Foo & Bar"', :action_view))
    end

    def test_xss_protection_with_safe_strings
      assert_equal("Foo & Bar\n", render('= Haml::Util.html_safe("Foo & Bar")', :action_view))
    end

    def test_xss_protection_with_bang
      assert_equal("Foo & Bar\n", render('!= "Foo & Bar"', :action_view))
    end

    def test_xss_protection_in_interpolation
      assert_equal("Foo &amp; Bar\n", render('Foo #{"&"} Bar', :action_view))
    end

    def test_xss_protection_with_bang_in_interpolation
      assert_equal("Foo & Bar\n", render('! Foo #{"&"} Bar', :action_view))
    end

    def test_xss_protection_with_safe_strings_in_interpolation
      assert_equal("Foo & Bar\n", render('Foo #{Haml::Util.html_safe("&")} Bar', :action_view))
    end

    def test_xss_protection_with_mixed_strings_in_interpolation
      assert_equal("Foo & Bar &amp; Baz\n", render('Foo #{Haml::Util.html_safe("&")} Bar #{"&"} Baz', :action_view))
    end

    def test_rendered_string_is_html_safe
      assert(render("Foo").html_safe?)
    end

    def test_rendered_string_is_html_safe_with_action_view
      assert(render("Foo", :action_view).html_safe?)
    end

    def test_xss_html_escaping_with_non_strings
      assert_equal("4\n", render("= html_escape(4)"))
    end

    def test_xss_protection_with_concat
      assert_equal("Foo &amp; Bar", render('- concat "Foo & Bar"', :action_view))
    end

    def test_xss_protection_with_concat_with_safe_string
      assert_equal("Foo & Bar", render('- concat(Haml::Util.html_safe("Foo & Bar"))', :action_view))
    end

    if Haml::Util.has?(:instance_method, ActionView::Helpers::TextHelper, :safe_concat)
      def test_xss_protection_with_safe_concat
        assert_equal("Foo & Bar", render('- safe_concat "Foo & Bar"', :action_view))
      end
    end

    ## Regression

    def test_xss_protection_with_nested_haml_tag
      assert_equal(<<HTML, render(<<HAML, :action_view))
<div>
  <ul>
    <li>Content!</li>
  </ul>
</div>
HTML
- haml_tag :div do
  - haml_tag :ul do
    - haml_tag :li, "Content!"
HAML
    end

    def test_xss_protection_with_form_for
      assert_equal(<<HTML, render(<<HAML, :action_view))
<form #{rails_form_attr}action="" method="post">#{rails_form_opener}
  Title:
  <input id="article_title" name="article[title]" size="30" type="text" value="Hello" />
  Body:
  <input id="article_body" name="article[body]" size="30" type="text" value="World" />
</form>
HTML
#{rails_block_helper_char} form_for #{form_for_calling_convention(:article)}, :url => '' do |f|
  Title:
  = f.text_field :title
  Body:
  = f.text_field :body
HAML
    end

    def test_rjs
      assert_equal(<<HTML, render(<<HAML, :action_view))
window.location.reload();
HTML
= update_page do |p|
  - p.reload
HAML
    end

    def test_cache
      @base.controller = ActionController::Base.new
      @base.controller.perform_caching = false
      assert_equal(<<HTML, render(<<HAML, :action_view))
Test
HTML
- cache do
  Test
HAML
    end
  end
end
require File.expand_path('../../../../spec_helper', __FILE__)

describe "Process::Status#to_s" do
  it "needs to be reviewed for spec completeness"
end
XREF_DATA = <<-XREF_DATA
class C1

  attr :attr
  attr_reader :attr_reader
  attr_writer :attr_writer
  attr_accessor :attr_accessor

  CONST = :const

  def self.m
  end

  def m foo
  end
end

class C2
  class C3
    def m
    end

    class H1
      def m?
      end
    end
  end
end

class C3
  class H1
  end

  class H2 < H1
  end
end

class C4
  class C4
  end
end

class C5
  class C1
  end
end

module M1
end

module M1::M2
end
XREF_DATA

require 'tmpdir'
require 'fileutils'
require 'test/unit'
require 'rake/packagetask'

class Rake::TestPackageTask < Test::Unit::TestCase
  include Rake

  def test_create
    pwd = Dir.pwd
    tmpdir = Dir.mktmpdir("rake")
    Dir.chdir(tmpdir)
    Dir.mkdir("bin")
    open("bin/rake", "wb") {}
    pkg = Rake::PackageTask.new("pkgr", "1.2.3") { |p|
      p.package_files << "install.rb"
      p.package_files.include(
        '[A-Z]*',
        'bin/**/*',
        'lib/**/*.rb',
        'test/**/*.rb',
        'doc/**/*',
        'build/rubyapp.rb',
        '*.blurb')
      p.package_files.exclude(/\bCVS\b/)
      p.package_files.exclude(/~$/)
      p.package_dir = 'pkg'
      p.need_tar = true
      p.need_tar_gz = true
      p.need_tar_bz2 = true
      p.need_zip = true
    }
    assert_equal "pkg", pkg.package_dir
    assert pkg.package_files.include?("bin/rake")
    assert "pkgr", pkg.name
    assert "1.2.3", pkg.version
    assert Task[:package]
    assert Task['pkg/pkgr-1.2.3.tgz']
    assert Task['pkg/pkgr-1.2.3.tar.gz']
    assert Task['pkg/pkgr-1.2.3.tar.bz2']
    assert Task['pkg/pkgr-1.2.3.zip']
    assert Task["pkg/pkgr-1.2.3"]
    assert Task[:clobber_package]
    assert Task[:repackage]
  ensure
    Dir.chdir(pwd)
    FileUtils.rm_rf(tmpdir)
  end

  def test_missing_version
    assert_raise(RuntimeError) {
      pkg = Rake::PackageTask.new("pkgr") { |p| }
    }
  end

  def test_no_version
    pkg = Rake::PackageTask.new("pkgr", :noversion) { |p| }
    assert "pkgr", pkg.send(:package_name)
  end

  def test_clone
    pkg = Rake::PackageTask.new("x", :noversion)
    p2 = pkg.clone
    pkg.package_files << "y"
    p2.package_files << "x"
    assert_equal ["y"], pkg.package_files
    assert_equal ["x"], p2.package_files
  end
end


require 'rake/gempackagetask'

class Rake::TestGemPackageTask < Test::Unit::TestCase
  def test_gem_package
    gem = Gem::Specification.new do |g|
      g.name = "pkgr"
      g.version = "1.2.3"
      g.files = FileList["x"].resolve
    end
    pkg = Rake::GemPackageTask.new(gem)  do |p|
      p.package_files << "y"
    end
    assert_equal ["x", "y"], pkg.package_files
    assert_equal "pkgr-1.2.3.gem", pkg.gem_file
  end

  def test_gem_package_with_current_platform
    gem = Gem::Specification.new do |g|
      g.name = "pkgr"
      g.version = "1.2.3"
      g.files = FileList["x"].resolve
      g.platform = Gem::Platform::CURRENT
    end
    pkg = Rake::GemPackageTask.new(gem)  do |p|
      p.package_files << "y"
    end
    assert_equal ["x", "y"], pkg.package_files
    assert_match(/^pkgr-1\.2\.3-(\S+)\.gem$/, pkg.gem_file)
  end

  def test_gem_package_with_ruby_platform
    gem = Gem::Specification.new do |g|
      g.name = "pkgr"
      g.version = "1.2.3"
      g.files = FileList["x"].resolve
      g.platform = Gem::Platform::RUBY
    end
    pkg = Rake::GemPackageTask.new(gem)  do |p|
      p.package_files << "y"
    end
    assert_equal ["x", "y"], pkg.package_files
    assert_equal "pkgr-1.2.3.gem", pkg.gem_file
  end
end

require 'test/unit'
require 'uri'
require 'testutil'

require 'openid/yadis/discovery'
require 'openid/fetchers'
require 'openid/util'
require 'discoverdata'

module OpenID

  module YadisDiscovery
    include FetcherMixin
    include DiscoverData

    STATUS_HEADER_RE = /Status: (\d+) .*?$/m

    four04_pat = "\nContent-Type: text/plain\n\nNo such file %s"

    def self.mkResponse(data)
      status_mo = data.scan(STATUS_HEADER_RE)
      headers_str, body = data.split("\n\n", 2)
      headers = {}
      headers_str.split("\n", -1).each { |line|
        k, v = line.split(':', 2)
        k = k.strip().downcase
        v = v.strip()
        headers[k] = v
      }
      status = status_mo[0][0].to_i
      return HTTPResponse._from_raw_data(status, body,
                                         headers)
    end

    class TestFetcher
      include DiscoverData

      def initialize(base_url)
        @base_url = base_url
      end

      def fetch(url, headers, body, redirect_limit=nil)
        current_url = url
        while true
          parsed = URI::parse(current_url)
          # parsed[2][1:]
          path = parsed.path[1..-1]
          begin
            data = generateSample(path, @base_url)
          rescue ArgumentError
            return HTTPResponse._from_raw_data(404, '', {},
                                               current_url)
          end

          response = YadisDiscovery.mkResponse(data)
          if ["301", "302", "303", "307"].member?(response.code)
            current_url = response['location']
          else
            response.final_url = current_url
            return response
          end
        end
      end
    end

    class MockFetcher
      def initialize
        @count = 0
      end

      def fetch(uri, headers=nil, body=nil, redirect_limit=nil)
        @count += 1
        if @count == 1
          headers = {
            'X-XRDS-Location'.downcase => 'http://unittest/404',
          }
          return HTTPResponse._from_raw_data(200, '', headers, uri)
        else
          return HTTPResponse._from_raw_data(404, '', {}, uri)
        end
      end
    end

    class TestSecondGet < Test::Unit::TestCase
      include FetcherMixin

      def test_404
        uri = "http://something.unittest/"
        assert_raise(DiscoveryFailure) {
          with_fetcher(MockFetcher.new) { Yadis.discover(uri) }
        }
      end
    end

    class DiscoveryTestCase
      include DiscoverData
      include FetcherMixin

      def initialize(testcase, input_name, id_name, result_name, success)
        @base_url = 'http://invalid.unittest/'
        @testcase = testcase
        @input_name = input_name
        @id_name = id_name
        @result_name = result_name
        @success = success
      end

      def setup
        @input_url, @expected = generateResult(@base_url,
                                               @input_name,
                                               @id_name,
                                               @result_name,
                                               @success)
      end

      def do_discovery
        with_fetcher(TestFetcher.new(@base_url)) do
          Yadis.discover(@input_url)
        end
      end

      def runCustomTest
        setup

        if @expected.respond_to?("ancestors") and @expected.ancestors.member?(DiscoveryFailure)
          @testcase.assert_raise(DiscoveryFailure) {
            do_discovery
          }
        else
          result = do_discovery
          @testcase.assert_equal(@input_url, result.request_uri)

          msg = sprintf("Identity URL mismatch: actual = %s, expected = %s",
                        result.normalized_uri, @expected.normalized_uri)
          @testcase.assert_equal(@expected.normalized_uri, result.normalized_uri, msg)

          msg = sprintf("Content mismatch: actual = %s, expected = %s",
                        result.response_text, @expected.response_text)
          @testcase.assert_equal(@expected.response_text, result.response_text, msg)

          expected_keys = @expected.instance_variables
          expected_keys.sort!

          actual_keys = result.instance_variables
          actual_keys.sort!

          @testcase.assert_equal(actual_keys, expected_keys)

          @expected.instance_variables.each { |k|
            exp_v = @expected.instance_variable_get(k)
            act_v = result.instance_variable_get(k)
            @testcase.assert_equal(act_v, exp_v, [k, exp_v, act_v])
          }
        end
      end
    end

    class NoContentTypeFetcher
      def fetch(url, body=nil, headers=nil, redirect_limit=nil)
        return OpenID::HTTPResponse._from_raw_data(200, "", {}, nil)
      end
    end

    class BlankContentTypeFetcher
      def fetch(url, body=nil, headers=nil, redirect_limit=nil)
        return OpenID::HTTPResponse._from_raw_data(200, "", {"Content-Type" => ""}, nil)
      end
    end

    class TestYadisDiscovery < Test::Unit::TestCase
      include FetcherMixin

      def test_yadis_discovery
        DiscoverData::TESTLIST.each { |success, input_name, id_name, result_name|
          test = DiscoveryTestCase.new(self, input_name, id_name, result_name, success)
          test.runCustomTest
        }
      end

      def test_is_xrds_yadis_location
        result = Yadis::DiscoveryResult.new('http://request.uri/')
        result.normalized_uri = "http://normalized/"
        result.xrds_uri = "http://normalized/xrds"

        assert(result.is_xrds)
      end

      def test_is_xrds_content_type
        result = Yadis::DiscoveryResult.new('http://request.uri/')
        result.normalized_uri = result.xrds_uri = "http://normalized/"
        result.content_type = Yadis::YADIS_CONTENT_TYPE

        assert(result.is_xrds)
      end

      def test_is_xrds_neither
        result = Yadis::DiscoveryResult.new('http://request.uri/')
        result.normalized_uri = result.xrds_uri = "http://normalized/"
        result.content_type = "another/content-type"

        assert(!result.is_xrds)
      end

      def test_no_content_type
        with_fetcher(NoContentTypeFetcher.new) do
          result = Yadis.discover("http://bogus")
          assert_equal(nil, result.content_type)
        end
      end

      def test_blank_content_type
        with_fetcher(BlankContentTypeFetcher.new) do
          result = Yadis.discover("http://bogus")
          assert_equal("", result.content_type)
        end
      end
    end
  end
end
=begin
 distributed Ruby --- dRuby Sample Server --- chasen server
 	Copyright (c) 1999-2001 Masatoshi SEKI 
=end

=begin
 How to play.

 Terminal 1
 | % ruby dhasen.rb 
 | druby://yourhost:7640

 Terminal 2
 | % ruby dhasenc.rb druby://yourhost:7640

=end

require 'drb/drb'
require 'chasen'
require 'thread'

class Dhasen
  include DRbUndumped

  def initialize
    @mutex = Mutex.new
  end

  def sparse(str, *arg)
    @mutex.synchronize do
      Chasen.getopt(*arg)
      Chasen.sparse(str)
    end
  end
end

if __FILE__ == $0
  DRb.start_service(nil, Dhasen.new)
  puts DRb.uri
  DRb.thread.join
end

module Debugger
  # Mix-in module to assist in command parsing.
  module SteppingFunctions # :nodoc:
    def parse_stepping_args(command_name, match)
      if match[1].nil? 
          force = Command.settings[:force_stepping]
      elsif match[1] == '+' 
        force = true
      elsif match[1] == '-' 
        force = false
      end
      steps = get_int(match[2], command_name, 1)
      return [steps, force]
    end
  end
  # Implements debugger "next" command.
  class NextCommand < Command
    self.allow_in_post_mortem  = false
    self.need_context          = true
    
    def regexp
      /^\s* n(?:ext)? 
        ([+-])?(?:\s+(\S+))? 
        \s*$/x
    end

    def execute
      steps, force = parse_stepping_args("Next", @match)
      return unless steps
      @state.context.step_over steps, @state.frame_pos, force
      @state.proceed
    end

    class << self
      def help_command
        'next'
      end

      def help(cmd)
        %{
          n[ext][+-]?[ nnn]\tstep over once or nnn times, 
          \t\t'+' forces to move to another line.
          \t\t'-' is the opposite of '+' and disables the force_stepping setting.
        }
      end
    end
  end

  # Implements debugger "step" command.
  class StepCommand < Command
    self.allow_in_post_mortem = false
    self.need_context         = true
    
    def regexp
      /^\s* s(?:tep)?
        ([+-])?(?:\s+(\S+))?
        \s*$/x
    end

    def execute
      steps, force = parse_stepping_args("Step", @match)
      return unless steps
      @state.context.step(steps, force)
      @state.proceed
    end

    class << self
      def help_command
        'step'
      end

      def help(cmd)
        %{
          s[tep][+-]?[ nnn]\tstep (into methods) once or nnn times
          \t\t'+' forces to move to another line.
          \t\t'-' is the opposite of '+' and disables the force_stepping setting.
        }
      end
    end
  end
end
require 'test/unit'

class TestString < Test::Unit::TestCase
  def check_sum(str, bits=16)
    sum = 0
    str.each_byte {|c| sum += c}
    sum = sum & ((1 << bits) - 1) if bits != 0
    assert_equal(sum, str.sum(bits))
  end
  def test_sum
    assert_equal(0, "".sum)
    assert_equal(294, "abc".sum)
    check_sum("abc")
    check_sum("\x80")
    0.upto(70) {|bits|
      check_sum("xyz", bits)
    }
  end

  def test_inspect
    original_kcode = $KCODE

    $KCODE = 'n'
    assert_equal('"\343\201\202"', "\xe3\x81\x82".inspect)

    $KCODE = 'u'
    assert_equal("\"\343\201\202\"", "\xe3\x81\x82".inspect)
    assert_no_match(/\0/, "\xe3\x81".inspect, '[ruby-dev:39550]')
  ensure
    $KCODE = original_kcode
  end
end
# Autogenerated from a Treetop grammar. Edits may be lost.


module Mail
  module Received
    include Treetop::Runtime

    def root
      @root ||= :primary
    end

    include RFC2822

    module Primary0
      def name_val_list
        elements[0]
      end

      def date_time
        elements[2]
      end
    end

    def _nt_primary
      start_index = index
      if node_cache[:primary].has_key?(index)
        cached = node_cache[:primary][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_name_val_list
      s0 << r1
      if r1
        if has_terminal?(";", false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(";")
          r2 = nil
        end
        s0 << r2
        if r2
          r3 = _nt_date_time
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Primary0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:primary][start_index] = r0

      r0
    end

  end

  class ReceivedParser < Treetop::Runtime::CompiledParser
    include Received
  end

end# WSDL4R - Creating CGI stub code from WSDL.
# Copyright (C) 2002, 2003, 2005  NAKAMURA, Hiroshi <nahi@ruby-lang.org>.

# This program is copyrighted free software by NAKAMURA, Hiroshi.  You can
# redistribute it and/or modify it under the same terms of Ruby's license;
# either the dual license version in 2003, or any later version.


require 'wsdl/info'
require 'wsdl/soap/mappingRegistryCreator'
require 'wsdl/soap/methodDefCreator'
require 'wsdl/soap/classDefCreatorSupport'


module WSDL
module SOAP


class CGIStubCreator
  include ClassDefCreatorSupport

  attr_reader :definitions

  def initialize(definitions)
    @definitions = definitions
  end

  def dump(service_name)
    warn("CGI stub can have only 1 port.  Creating stub for the first port...  Rests are ignored.")
    port = @definitions.service(service_name).ports[0]
    dump_porttype(port.porttype.name)
  end

private

  def dump_porttype(name)
    class_name = create_class_name(name)
    methoddef, types = MethodDefCreator.new(@definitions).dump(name)
    mr_creator = MappingRegistryCreator.new(@definitions)
    c1 = XSD::CodeGen::ClassDef.new(class_name)
    c1.def_require("soap/rpc/cgistub")
    c1.def_require("soap/mapping/registry")
    c1.def_const("MappingRegistry", "::SOAP::Mapping::Registry.new")
    c1.def_code(mr_creator.dump(types))
    c1.def_code <<-EOD
Methods = [
#{methoddef.gsub(/^/, "  ")}
]
    EOD
    c2 = XSD::CodeGen::ClassDef.new(class_name + "App",
      "::SOAP::RPC::CGIStub")
    c2.def_method("initialize", "*arg") do
      <<-EOD
        super(*arg)
        servant = #{class_name}.new
        #{class_name}::Methods.each do |definitions|
          opt = definitions.last
          if opt[:request_style] == :document
            @router.add_document_operation(servant, *definitions)
          else
            @router.add_rpc_operation(servant, *definitions)
          end
        end
        self.mapping_registry = #{class_name}::MappingRegistry
        self.level = Logger::Severity::ERROR
      EOD
    end
    c1.dump + "\n" + c2.dump + format(<<-EOD)
      #{class_name}App.new('app', nil).start
    EOD
  end
end


end
end
module Warden
  module OAuth

    def self.access_token_user_finder(key, &block)
      Strategy.access_token_user_finders[key] = block
    end

    def self.clear_access_token_user_finders
      Strategy.access_token_user_finders.clear
    end

  end
end
$:.unshift File.expand_path(File.dirname(__FILE__) + "/../lib")
require 'eventmachine'
require 'socket'
require 'test/unit'

class TestGetSockOpt < Test::Unit::TestCase

  def setup
    assert(!EM.reactor_running?)
  end

  def teardown
    assert(!EM.reactor_running?)
  end

  #-------------------------------------

  def test_get_sock_opt
    test = self
    EM.run do
      EM.connect 'google.com', 80, Module.new {
        define_method :connection_completed do
          val = get_sock_opt Socket::SOL_SOCKET, Socket::SO_ERROR
          test.assert_equal "\0\0\0\0", val
          EM.stop
        end
      }
    end
  end
end
module ActiveSupport
  # The Inflector transforms words from singular to plural, class names to table names, modularized class names to ones without,
  # and class names to foreign keys. The default inflections for pluralization, singularization, and uncountable words are kept
  # in inflections.rb.
  #
  # The Rails core team has stated patches for the inflections library will not be accepted
  # in order to avoid breaking legacy applications which may be relying on errant inflections.
  # If you discover an incorrect inflection and require it for your application, you'll need
  # to correct it yourself (explained below).
  module Inflector
    extend self

    # By default, +camelize+ converts strings to UpperCamelCase. If the argument to +camelize+
    # is set to <tt>:lower</tt> then +camelize+ produces lowerCamelCase.
    #
    # +camelize+ will also convert '/' to '::' which is useful for converting paths to namespaces.
    #
    # Examples:
    #   "active_record".camelize                # => "ActiveRecord"
    #   "active_record".camelize(:lower)        # => "activeRecord"
    #   "active_record/errors".camelize         # => "ActiveRecord::Errors"
    #   "active_record/errors".camelize(:lower) # => "activeRecord::Errors"
    #
    # As a rule of thumb you can think of +camelize+ as the inverse of +underscore+,
    # though there are cases where that does not hold:
    #
    #   "SSLError".underscore.camelize # => "SslError"
    def camelize(lower_case_and_underscored_word, first_letter_in_uppercase = true)
      if first_letter_in_uppercase
        lower_case_and_underscored_word.to_s.gsub(/\/(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase }
      else
        lower_case_and_underscored_word.to_s[0].chr.downcase + camelize(lower_case_and_underscored_word)[1..-1]
      end
    end

    # Makes an underscored, lowercase form from the expression in the string.
    #
    # Changes '::' to '/' to convert namespaces to paths.
    #
    # Examples:
    #   "ActiveRecord".underscore         # => "active_record"
    #   "ActiveRecord::Errors".underscore # => active_record/errors
    #
    # As a rule of thumb you can think of +underscore+ as the inverse of +camelize+,
    # though there are cases where that does not hold:
    #
    #   "SSLError".underscore.camelize # => "SslError"
    def underscore(camel_cased_word)
      word = camel_cased_word.to_s.dup
      word.gsub!(/::/, '/')
      word.gsub!(/([A-Z]+)([A-Z][a-z])/,'\1_\2')
      word.gsub!(/([a-z\d])([A-Z])/,'\1_\2')
      word.tr!("-", "_")
      word.downcase!
      word
    end

    # Replaces underscores with dashes in the string.
    #
    # Example:
    #   "puni_puni" # => "puni-puni"
    def dasherize(underscored_word)
      underscored_word.gsub(/_/, '-')
    end

    # Removes the module part from the expression in the string.
    #
    # Examples:
    #   "ActiveRecord::CoreExtensions::String::Inflections".demodulize # => "Inflections"
    #   "Inflections".demodulize                                       # => "Inflections"
    def demodulize(class_name_in_module)
      class_name_in_module.to_s.gsub(/^.*::/, '')
    end

    # Creates a foreign key name from a class name.
    # +separate_class_name_and_id_with_underscore+ sets whether
    # the method should put '_' between the name and 'id'.
    #
    # Examples:
    #   "Message".foreign_key        # => "message_id"
    #   "Message".foreign_key(false) # => "messageid"
    #   "Admin::Post".foreign_key    # => "post_id"
    def foreign_key(class_name, separate_class_name_and_id_with_underscore = true)
      underscore(demodulize(class_name)) + (separate_class_name_and_id_with_underscore ? "_id" : "id")
    end

    # Ruby 1.9 introduces an inherit argument for Module#const_get and
    # #const_defined? and changes their default behavior.
    if Module.method(:const_get).arity == 1
      # Tries to find a constant with the name specified in the argument string:
      #
      #   "Module".constantize     # => Module
      #   "Test::Unit".constantize # => Test::Unit
      #
      # The name is assumed to be the one of a top-level constant, no matter whether
      # it starts with "::" or not. No lexical context is taken into account:
      #
      #   C = 'outside'
      #   module M
      #     C = 'inside'
      #     C               # => 'inside'
      #     "C".constantize # => 'outside', same as ::C
      #   end
      #
      # NameError is raised when the name is not in CamelCase or the constant is
      # unknown.
      def constantize(camel_cased_word)
        names = camel_cased_word.split('::')
        names.shift if names.empty? || names.first.empty?

        constant = Object
        names.each do |name|
          constant = constant.const_defined?(name) ? constant.const_get(name) : constant.const_missing(name)
        end
        constant
      end
    else
      def constantize(camel_cased_word) #:nodoc:
        names = camel_cased_word.split('::')
        names.shift if names.empty? || names.first.empty?

        constant = Object
        names.each do |name|
          constant = constant.const_defined?(name, false) ? constant.const_get(name) : constant.const_missing(name)
        end
        constant
      end
    end

    # Turns a number into an ordinal string used to denote the position in an
    # ordered sequence such as 1st, 2nd, 3rd, 4th.
    #
    # Examples:
    #   ordinalize(1)     # => "1st"
    #   ordinalize(2)     # => "2nd"
    #   ordinalize(1002)  # => "1002nd"
    #   ordinalize(1003)  # => "1003rd"
    def ordinalize(number)
      if (11..13).include?(number.to_i % 100)
        "#{number}th"
      else
        case number.to_i % 10
          when 1; "#{number}st"
          when 2; "#{number}nd"
          when 3; "#{number}rd"
          else    "#{number}th"
        end
      end
    end
  end
endrequire File.join( File.dirname(File.expand_path(__FILE__)), 'base')

require 'webmock/rspec'
include WebMock

describe RestClient::Response do
  before do
    @net_http_res = mock('net http response', :to_hash => {"Status" => ["200 OK"]}, :code => 200)
    @request = mock('http request', :user => nil, :password => nil)
    @response = RestClient::Response.create('abc', @net_http_res, {})
  end

  it "behaves like string" do
    @response.should.to_s == 'abc'
    @response.to_str.should == 'abc'
    @response.to_i.should == 200
  end

  it "accepts nil strings and sets it to empty for the case of HEAD" do
    RestClient::Response.create(nil, @net_http_res, {}).should.to_s == ""
  end

  it "test headers and raw headers" do
    @response.raw_headers["Status"][0].should == "200 OK"
    @response.headers[:status].should == "200 OK"
  end

  describe "cookie processing" do
    it "should correctly deal with one Set-Cookie header with one cookie inside" do
      net_http_res = mock('net http response', :to_hash => {"etag" => ["\"e1ac1a2df945942ef4cac8116366baad\""], "set-cookie" => ["main_page=main_page_no_rewrite; path=/; expires=Tue, 20-Jan-2015 15:03:14 GMT"]})
      response = RestClient::Response.create('abc', net_http_res, {})
      response.headers[:set_cookie].should == ["main_page=main_page_no_rewrite; path=/; expires=Tue, 20-Jan-2015 15:03:14 GMT"]
      response.cookies.should == { "main_page" => "main_page_no_rewrite" }
    end

    it "should correctly deal with multiple cookies [multiple Set-Cookie headers]" do
      net_http_res = mock('net http response', :to_hash => {"etag" => ["\"e1ac1a2df945942ef4cac8116366baad\""], "set-cookie" => ["main_page=main_page_no_rewrite; path=/; expires=Tue, 20-Jan-2015 15:03:14 GMT", "remember_me=; path=/; expires=Thu, 01-Jan-1970 00:00:00 GMT", "user=somebody; path=/; expires=Thu, 01-Jan-1970 00:00:00 GMT"]})
      response = RestClient::Response.create('abc', net_http_res, {})
      response.headers[:set_cookie].should == ["main_page=main_page_no_rewrite; path=/; expires=Tue, 20-Jan-2015 15:03:14 GMT", "remember_me=; path=/; expires=Thu, 01-Jan-1970 00:00:00 GMT", "user=somebody; path=/; expires=Thu, 01-Jan-1970 00:00:00 GMT"]
      response.cookies.should == {
              "main_page" => "main_page_no_rewrite",
              "remember_me" => "",
              "user" => "somebody"
      }
    end

    it "should correctly deal with multiple cookies [one Set-Cookie header with multiple cookies]" do
      net_http_res = mock('net http response', :to_hash => {"etag" => ["\"e1ac1a2df945942ef4cac8116366baad\""], "set-cookie" => ["main_page=main_page_no_rewrite; path=/; expires=Tue, 20-Jan-2015 15:03:14 GMT, remember_me=; path=/; expires=Thu, 01-Jan-1970 00:00:00 GMT, user=somebody; path=/; expires=Thu, 01-Jan-1970 00:00:00 GMT"]})
      response = RestClient::Response.create('abc', net_http_res, {})
      response.cookies.should == {
              "main_page" => "main_page_no_rewrite",
              "remember_me" => "",
              "user" => "somebody"
      }
    end
  end

  describe "exceptions processing" do
    it "should return itself for normal codes" do
      (200..206).each do |code|
        net_http_res = mock('net http response', :code => '200')
        response = RestClient::Response.create('abc', net_http_res, {})
        response.return! @request
      end
    end

    it "should throw an exception for other codes" do
      RestClient::Exceptions::EXCEPTIONS_MAP.each_key do |code|
        unless (200..207).include? code
          net_http_res = mock('net http response', :code => code.to_i)
          response = RestClient::Response.create('abc', net_http_res, {})
          lambda { response.return!}.should raise_error
        end
      end
    end

  end

  describe "redirection" do
    
    it "follows a redirection when the request is a get" do
      stub_request(:get, 'http://some/resource').to_return(:body => '', :status => 301, :headers => {'Location' => 'http://new/resource'})
      stub_request(:get, 'http://new/resource').to_return(:body => 'Foo')
      RestClient::Request.execute(:url => 'http://some/resource', :method => :get).body.should == 'Foo'
    end

    it "follows a redirection and keep the parameters" do
      stub_request(:get, 'http://foo:bar@some/resource').with(:headers => {'Accept' => 'application/json'}).to_return(:body => '', :status => 301, :headers => {'Location' => 'http://new/resource'})
      stub_request(:get, 'http://foo:bar@new/resource').with(:headers => {'Accept' => 'application/json'}).to_return(:body => 'Foo')
      RestClient::Request.execute(:url => 'http://some/resource', :method => :get, :user => 'foo', :password => 'bar', :headers => {:accept => :json}).body.should == 'Foo'
    end

    it "follows a redirection and keep the cookies" do
      stub_request(:get, 'http://some/resource').to_return(:body => '', :status => 301, :headers => {'Set-Cookie' => CGI::Cookie.new('Foo', 'Bar'), 'Location' => 'http://new/resource', })
      stub_request(:get, 'http://new/resource').with(:headers => {'Cookie' => 'Foo=Bar'}).to_return(:body => 'Qux')
      RestClient::Request.execute(:url => 'http://some/resource', :method => :get).body.should == 'Qux'
    end

    it "doesn't follow a 301 when the request is a post" do
      net_http_res = mock('net http response', :code => 301)
      response = RestClient::Response.create('abc', net_http_res, {:method => :post})
      lambda { response.return!(@request)}.should raise_error(RestClient::MovedPermanently)
    end

    it "doesn't follow a 302 when the request is a post" do
      net_http_res = mock('net http response', :code => 302)
      response = RestClient::Response.create('abc', net_http_res, {:method => :post})
      lambda { response.return!(@request)}.should raise_error(RestClient::Found)
    end

    it "doesn't follow a 307 when the request is a post" do
      net_http_res = mock('net http response', :code => 307)
      response = RestClient::Response.create('abc', net_http_res, {:method => :post})
      lambda { response.return!(@request)}.should raise_error(RestClient::TemporaryRedirect)
    end

    it "doesn't follow a redirection when the request is a put" do
      net_http_res = mock('net http response', :code => 301)
      response = RestClient::Response.create('abc', net_http_res, {:method => :put})
      lambda { response.return!(@request)}.should raise_error(RestClient::MovedPermanently)
    end

    it "follows a redirection when the request is a post and result is a 303" do
      stub_request(:put, 'http://some/resource').to_return(:body => '', :status => 303, :headers => {'Location' => 'http://new/resource'})
      stub_request(:get, 'http://new/resource').to_return(:body => 'Foo')
      RestClient::Request.execute(:url => 'http://some/resource', :method => :put).body.should == 'Foo'
    end

    it "follows a redirection when the request is a head" do
      stub_request(:head, 'http://some/resource').to_return(:body => '', :status => 301, :headers => {'Location' => 'http://new/resource'})
      stub_request(:head, 'http://new/resource').to_return(:body => 'Foo')
      RestClient::Request.execute(:url => 'http://some/resource', :method => :head).body.should == 'Foo'
    end

    it "handles redirects with relative paths" do
      stub_request(:get, 'http://some/resource').to_return(:body => '', :status => 301, :headers => {'Location' => 'index'})
      stub_request(:get, 'http://some/index').to_return(:body => 'Foo')
      RestClient::Request.execute(:url => 'http://some/resource', :method => :get).body.should == 'Foo'
    end

    it "handles redirects with relative path and query string" do
      stub_request(:get, 'http://some/resource').to_return(:body => '', :status => 301, :headers => {'Location' => 'index?q=1'})
      stub_request(:get, 'http://some/index?q=1').to_return(:body => 'Foo')
      RestClient::Request.execute(:url => 'http://some/resource', :method => :get).body.should == 'Foo'
    end

    it "follow a redirection when the request is a get and the response is in the 30x range" do
      stub_request(:get, 'http://some/resource').to_return(:body => '', :status => 301, :headers => {'Location' => 'http://new/resource'})
      stub_request(:get, 'http://new/resource').to_return(:body => 'Foo')
      RestClient::Request.execute(:url => 'http://some/resource', :method => :get).body.should == 'Foo'
    end

    
  end


end
# LDAP Entry (search-result) support classes
#
#----------------------------------------------------------------------------
#
# Copyright (C) 2006 by Francis Cianfrocca. All Rights Reserved.
#
# Gmail: garbagecat10
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
#---------------------------------------------------------------------------
#

module Net
class LDAP


  # Objects of this class represent individual entries in an LDAP directory.
  # User code generally does not instantiate this class. Net::LDAP#search
  # provides objects of this class to user code, either as block parameters or
  # as return values.
  #
  # In LDAP-land, an "entry" is a collection of attributes that are uniquely
  # and globally identified by a DN ("Distinguished Name"). Attributes are
  # identified by short, descriptive words or phrases. Although a directory is
  # free to implement any attribute name, most of them follow rigorous
  # standards so that the range of commonly-encountered attribute names is not
  # large.
  #
  # An attribute name is case-insensitive. Most directories also restrict the
  # range of characters allowed in attribute names. To simplify handling
  # attribute names, Net::LDAP::Entry internally converts them to a standard
  # format. Therefore, the methods which take attribute names can take Strings
  # or Symbols, and work correctly regardless of case or capitalization.
  #
  # An attribute consists of zero or more data items called <i>values.</i> An
  # entry is the combination of a unique DN, a set of attribute names, and a
  # (possibly-empty) array of values for each attribute.
  #
  # Class Net::LDAP::Entry provides convenience methods for dealing with LDAP
  # entries. In addition to the methods documented below, you may access
  # individual attributes of an entry simply by giving the attribute name as
  # the name of a method call. For example:
  #
  #   ldap.search( ... ) do |entry|
  #     puts "Common name: #{entry.cn}"
  #     puts "Email addresses:"
  #     entry.mail.each {|ma| puts ma}
  #   end
  #
  # If you use this technique to access an attribute that is not present in a
  # particular Entry object, a NoMethodError exception will be raised.
  #
  #--
  # Ugly problem to fix someday: We key off the internal hash with a canonical
  # form of the attribute name: convert to a string, downcase, then take the
  # symbol. Unfortunately we do this in at least three places. Should do it in
  # ONE place.
  #
  class Entry
    # This constructor is not generally called by user code.
    #
    def initialize dn = nil # :nodoc:
      @myhash = {}
      @myhash[:dn] = [dn]
    end

    def _dump depth
      to_ldif
    end

    class << self
      def _load entry
        from_single_ldif_string entry
      end
    end

    #--
    # Discovered bug, 26Aug06: I noticed that we're not converting the
    # incoming value to an array if it isn't already one.
    def []=(name, value) # :nodoc:
      sym = attribute_name(name)
      value = [value] unless value.is_a?(Array)
      @myhash[sym] = value
    end

    #--
    # We have to deal with this one as we do with []= because this one and not
    # the other one gets called in formulations like entry["CN"] << cn.
    #
    def [](name) # :nodoc:
      name = attribute_name(name) unless name.is_a?(Symbol)
      @myhash[name] || []
    end

    # Returns the dn of the Entry as a String.
    def dn
      self[:dn][0].to_s
    end

    # Returns an array of the attribute names present in the Entry.
    def attribute_names
      @myhash.keys
    end

    # Accesses each of the attributes present in the Entry.
    # Calls a user-supplied block with each attribute in turn,
    # passing two arguments to the block: a Symbol giving
    # the name of the attribute, and a (possibly empty)
    # Array of data values.
    #
    def each
      if block_given?
        attribute_names.each {|a|
          attr_name,values = a,self[a]
          yield attr_name, values
        }
      end
    end

    alias_method :each_attribute, :each

    # Converts the Entry to a String, representing the
    # Entry's attributes in LDIF format.
    #--
    def to_ldif
      ary = []
      ary << "dn: #{dn}\n"
      v2 = "" # temp value, save on GC
      each_attribute do |k,v|
        unless k == :dn
          v.each {|v1|
            v2 = if (k == :userpassword) || is_attribute_value_binary?(v1)
              ": #{Base64.encode64(v1).chomp.gsub(/\n/m,"\n ")}"
            else
              " #{v1}"
            end
            ary << "#{k}:#{v2}\n"
          }
        end
      end
      ary << "\n"
      ary.join
    end

    #--
    # TODO, doesn't support broken lines.
    # It generates a SINGLE Entry object from an incoming LDIF stream which is
    # of course useless for big LDIF streams that encode many objects.
    #
    # DO NOT DOCUMENT THIS METHOD UNTIL THESE RESTRICTIONS ARE LIFTED.
    #
    # As it is, it's useful for unmarshalling objects that we create, but not
    # for reading arbitrary LDIF files. Eventually, we should have a class
    # method that parses large LDIF streams into individual LDIF blocks
    # (delimited by blank lines) and passes them here.
    #
    class << self
      def from_single_ldif_string ldif
        entry = Entry.new
        entry[:dn] = []
        ldif.split(/\r?\n/m).each {|line|
          break if line.length == 0
          if line =~ /\A([\w]+):(:?)[\s]*/
            entry[$1] <<= if $2 == ':'
              Base64.decode64($')
            else
              $'
            end
          end
        }
        entry.dn ? entry : nil
      end
    end
    
    #--
    # Part of the support for getter and setter style access to attributes. 
    #
    def respond_to?(sym)
      name = attribute_name(sym)
      return true if valid_attribute?(name)
      return super
    end

    #--
    # Supports getter and setter style access for all the attributes that this
    # entry holds.
    #
    def method_missing sym, *args, &block # :nodoc:
      name = attribute_name(sym)
      
      if valid_attribute? name 
        if setter?(sym) && args.size == 1
          value = args.first
          value = [value] unless value.instance_of?(Array)
          self[name]= value

          return value
        elsif args.empty?
          return self[name]
        end
      end
      
      super
    end

    def write
    end

  private

    #--
    # Internal convenience method. It seems like the standard
    # approach in most LDAP tools to base64 encode an attribute
    # value if its first or last byte is nonprintable, or if
    # it's a password. But that turns out to be not nearly good
    # enough. There are plenty of A/D attributes that are binary
    # in the middle. This is probably a nasty performance killer.
    def is_attribute_value_binary? value
      v = value.to_s
      v.each_byte {|byt|
        return true if (byt < 32) || (byt > 126)
      }
      if v[0..0] == ':' or v[0..0] == '<'
        return true
      end
      false
    end
  
    # Returns the symbol that can be used to access the attribute that
    # sym_or_str designates.
    #
    def attribute_name(sym_or_str)
      str = sym_or_str.to_s.downcase
      
      # Does str match 'something='? Still only returns :something
      return str[0...-1].to_sym if str.size>1 && str[-1] == ?=
      return str.to_sym
    end
    
    # Given a valid attribute symbol, returns true. 
    #
    def valid_attribute?(attr_name)
      attribute_names.include?(attr_name)
    end
    
    def setter?(sym)
      sym.to_s[-1] == ?=
    end
  end # class Entry


end # class LDAP
end # module Net
require "spec_helper"

describe Mongoid::Matchers::Gte do

  describe "#matches?" do

    context "when the value is larger" do

      let(:matcher) { Mongoid::Matchers::Gte.new(5) }

      it "returns true" do
        matcher.matches?("$gte" => 3).should be_true
      end

    end

    context "when the value is smaller" do

      let(:matcher) { Mongoid::Matchers::Gte.new(5) }

      it "returns false" do
        matcher.matches?("$gte" => 10).should be_false
      end

    end

    context "when the value is equal" do

      let(:matcher) { Mongoid::Matchers::Gte.new(5) }

      it "returns true" do
        matcher.matches?("$gte" => 5).should be_true
      end

    end

    context "when the value is nil" do

      let(:matcher) { Mongoid::Matchers::Gte.new(nil) }

      it "returns false" do
        matcher.matches?("$gte" => 5).should be_false
      end

    end

  end

end
describe :argf_each_char, :shared => true do
  before :each do
    @file1_name = fixture __FILE__, "file1.txt"
    @file2_name = fixture __FILE__, "file2.txt"

    @chars = []
    File.read(@file1_name).each_char { |c| @chars << c }
    File.read(@file2_name).each_char { |c| @chars << c }
  end

  after :each do
    ARGF.close unless ARGF.closed?
  end

  it "yields each char of all streams to the passed block" do
    argv [@file1_name, @file2_name] do
      chars = []
      ARGF.send(@method) { |c| chars << c }
      chars.should == @chars
    end
  end

  it "returns self when passed a block" do
    argv [@file1_name, @file2_name] do
      ARGF.send(@method) {}.should equal(ARGF)
    end
  end

  it "returns an Enumerator when passed no block" do
    argv [@file1_name, @file2_name] do
      enum = ARGF.send(@method)
      enum.should be_an_instance_of(enumerator_class)

      chars = []
      enum.each { |c| chars << c }
      chars.should == @chars
    end
  end
end
#
#  tkextlib/tktable/tktable.rb
#                               by Hidetoshi NAGAI (nagai@ai.kyutech.ac.jp)
#

require 'tk'
require 'tk/validation'

# call setup script for general 'tkextlib' libraries
require 'tkextlib/setup.rb'

# call setup script
require 'tkextlib/tktable/setup.rb'

# TkPackage.require('Tktable', '2.8')
TkPackage.require('Tktable')

module Tk
  class TkTable < TkWindow
    PACKAGE_NAME = 'Tktable'.freeze
    def self.package_name
      PACKAGE_NAME
    end

    def self.package_version
      begin
        TkPackage.require('Tktable')
      rescue
        ''
      end
    end

    class CellTag < TkObject
    end

    module ConfigMethod
    end
  end
end

module Tk::TkTable::ConfigMethod
  include TkItemConfigMethod

  def __item_cget_cmd(id)  # id := [ type, tagOrId ]
    [self.path, id[0], 'cget', id[1]]
  end
  private :__item_cget_cmd

  def __item_config_cmd(id)  # id := [ type, tagOrId ]
    [self.path, id[0], 'configure', id[1]]
  end
  private :__item_config_cmd

  def __item_pathname(id)
    if id.kind_of?(Array)
      id = tagid(id[1])
    end
    [self.path, id].join(';')
  end
  private :__item_pathname

  def __item_boolval_optkeys(id)
    super(id) << 'multiline' << 'showtext' << 'wrap'
  end
  private :__item_boolval_optkeys

  def __item_strval_optkeys(id)
    super(id) << 'ellipsis'
  end
  private :__item_strval_optkeys

  def __item_val2ruby_optkeys(id)  # { key=>method, ... }
    super(id).update('window'=>proc{|v| window(v)})
  end
  private :__item_val2ruby_optkeys

  def tag_cget_tkstring(tagOrId, option)
    itemcget_tkstring(['tag', tagid(tagOrId)], option)
  end
  def tag_cget(tagOrId, option)
    itemcget(['tag', tagid(tagOrId)], option)
  end
  def tag_cget_strict(tagOrId, option)
    itemcget_strict(['tag', tagid(tagOrId)], option)
  end
  def tag_configure(tagOrId, slot, value=None)
    itemconfigure(['tag', tagid(tagOrId)], slot, value)
  end
  def tag_configinfo(tagOrId, slot=nil)
    itemconfiginfo(['tag', tagid(tagOrId)], slot)
  end
  def current_tag_configinfo(tagOrId, slot=nil)
    current_itemconfiginfo(['tag', tagid(tagOrId)], slot)
  end

  def window_cget_tkstring(tagOrId, option)
    itemcget_tkstring(['window', tagid(tagOrId)], option)
  end
  def window_cget(tagOrId, option)
    itemcget(['window', tagid(tagOrId)], option)
  end
  def window_cget_strict(tagOrId, option)
    itemcget_strict(['window', tagid(tagOrId)], option)
  end
  def window_configure(tagOrId, slot, value=None)
    if slot == :window || slot == 'window'
      value = _epath(value)
    elsif slot.kind_of?(Hash)
      if slot.key?(:window) || slot.key?('window')
        slot = _symbolkey2str(slot)
        slot['window'] = _epath(slot['window'])
      end
    end
    itemconfigure(['window', tagid(tagOrId)], slot, value)
  end
  def window_configinfo(tagOrId, slot=nil)
    itemconfiginfo(['window', tagid(tagOrId)], slot)
  end
  def current_window_configinfo(tagOrId, slot=nil)
    current_itemconfiginfo(['window', tagid(tagOrId)], slot)
  end

  private :itemcget_tkstring, :itemcget, :itemcget_strict
  private :itemconfigure, :itemconfiginfo, :current_itemconfiginfo
end

#####################################################

class Tk::TkTable::CellTag
  include TkTreatTagFont

  CellTagID_TBL = TkCore::INTERP.create_table

  (CellTag_ID = ['tktbl:celltag'.freeze, TkUtil.untrust('00000')]).instance_eval{
    @mutex = Mutex.new
    def mutex; @mutex; end
    freeze
  }

  TkCore::INTERP.init_ip_env{
    CellTagID_TBL.mutex.synchronize{ CellTagID_TBL.clear }
  }

  def self.id2obj(table, id)
    tpath = table.path
    CellTagID_TBL.mutex.synchronize{
      if CellTagID_TBL[tpath]
        CellTagID_TBL[tpath][id]? CellTagID_TBL[tpath][id] : id
      else
        id
      end
    }
  end

  def initialize(parent, keys=nil)
    @parent = @t = parent
    @tpath - parent.path
    CellTag_ID.mutex.synchronize{
      @path = @id = CellTag_ID.join(TkCore::INTERP._ip_id_)
      CellTag_ID[1].succ!
    }
    CellTagID_TBL.mutex.synchronize{
      CellTagID_TBL[@tpath] = {} unless CellTagID_TBL[@tpath]
      CellTagID_TBL[@tpath][@id] = self
    }
    configure(keys) if keys
  end

  def id
    @id
  end

  def destroy
    tk_call(@tpath, 'tag', 'delete', @id)
    CellTagID_TBL.mutex.synchronize{
      CellTagID_TBL[@tpath].delete(@id) if CellTagID_TBL[@tpath]
    }
    self
  end
  alias delete destroy

  def exist?
    @t.tag_exist?(@id)
  end
  def include?(idx)
    @t.tag_include?(@id, idx)
  end

  def add_cell(*args)
    @t.tag_cell(@id, *args)
  end
  def add_col(*args)
    @t.tag_col(@id, *args)
  end
  def add_row(*args)
    @t.tag_row(@id, *args)
  end

  def raise(target=None)
    @t.tag_raise(@id, target)
  end
  def lower(target=None)
    @t.tag_lower(@id, target)
  end

  def cget_tkstring(key)
    @t.tag_cget_tkstring(@id, key)
  end
  def cget(key)
    @t.tag_cget(@id, key)
  end
  def cget_strict(key)
    @t.tag_cget_strict(@id, key)
  end
  def configure(key, val=None)
    @t.tag_configure(@id, key, val)
  end
  def configinfo(key=nil)
    @t.tag_configinfo(@id, key)
  end
  def current_configinfo(key=nil)
    @t.current_tag_configinfo(@id, key)
  end
end

class Tk::TkTable::NamedCellTag < Tk::TkTable::CellTag
  def self.new(parent, name, keys=nil)
    obj = nil
    CellTagID_TBL.mutex.synchronize{
      if CellTagID_TBL[parent.path] && CellTagID_TBL[parent.path][name]
        obj = CellTagID_TBL[parent.path][name]
      else
        #super(parent, name, keys)
        (obj = self.allocate).instance_eval{
          @parent = @t = parent
          @tpath = parent.path
          @path = @id = name
          CellTagID_TBL[@tpath] = {} unless CellTagID_TBL[@tpath]
          CellTagID_TBL[@tpath][@id] = self
        }
      end
    }
    obj.configure(keys) if keys && ! keys.empty?
    obj
  end

  def initialize(parent, name, keys=nil)
    # dummy:: not called by 'new' method
    @parent = @t = parent
    @tpath = parent.path
    @path = @id = name
    CellTagID_TBL.mutex.synchronize{
      CellTagID_TBL[@tpath] = {} unless CellTagID_TBL[@tpath]
      CellTagID_TBL[@tpath][@id] = self
    }
    configure(keys) if keys && ! keys.empty?
  end
end

#####################################################

class Tk::TkTable
  TkCommandNames = ['table'.freeze].freeze
  WidgetClassName = 'Table'.freeze
  WidgetClassNames[WidgetClassName] ||= self

  include Scrollable
  include Tk::TkTable::ConfigMethod
  include Tk::ValidateConfigure

  def __destroy_hook__
    Tk::TkTable::CelTag::CellTagID_TBL.mutex.synchronize{
      Tk::TkTable::CelTag::CellTagID_TBL.delete(@path)
    }
  end

  def __boolval_optkeys
    super() << 'autoclear' << 'flashmode' << 'invertselected' <<
      'multiline' << 'selecttitle' << 'wrap'
  end
  private :__boolval_optkeys

  def __strval_optkeys
    super() << 'colseparator' << 'ellipsis' << 'rowseparator' << 'sparsearray'
  end
  private :__strval_optkeys


  #################################

  class BrowseCommand < TkValidateCommand
    class ValidateArgs < TkUtil::CallbackSubst
      KEY_TBL = [
        [ ?c, ?n, :column ],
        [ ?C, ?s, :index ],
        [ ?i, ?x, :cursor ],
        [ ?r, ?n, :row ],
        [ ?s, ?s, :last_index ],
        [ ?S, ?s, :new_index ],
        [ ?W, ?w, :widget ],
        nil
      ]

      PROC_TBL = [
        [ ?n, TkComm.method(:number) ],
        [ ?x, TkComm.method(:num_or_str) ],
        [ ?s, TkComm.method(:string) ],
        [ ?w, TkComm.method(:window) ],
        nil
      ]

=begin
      # for Ruby m17n :: ?x --> String --> char-code ( getbyte(0) )
      KEY_TBL.map!{|inf|
        if inf.kind_of?(Array)
          inf[0] = inf[0].getbyte(0) if inf[0].kind_of?(String)
          inf[1] = inf[1].getbyte(0) if inf[1].kind_of?(String)
        end
        inf
      }

      PROC_TBL.map!{|inf|
        if inf.kind_of?(Array)
          inf[0] = inf[0].getbyte(0) if inf[0].kind_of?(String)
        end
        inf
      }
=end

      _setup_subst_table(KEY_TBL, PROC_TBL);

      def self.ret_val(val)
        val
      end
    end

    def self._config_keys
      ['browsecommand', 'browsecmd']
    end
  end
  #--------------------------------
  class CellCommand < TkValidateCommand
    class ValidateArgs < TkUtil::CallbackSubst
      KEY_TBL = [
        [ ?c, ?n, :column ],
        [ ?C, ?s, :index ],
        [ ?i, ?m, :rw_mode ],
        [ ?r, ?n, :row ],
        [ ?s, ?v, :value ],
        [ ?W, ?w, :widget ],
        nil
      ]

      PROC_TBL = [
        [ ?n, TkComm.method(:number) ],
        [ ?s, TkComm.method(:string) ],
        [ ?w, TkComm.method(:window) ],
        [ ?m, proc{|val| (val == '0')? (:r) : (:w)} ],
        [ ?v, proc{|val| TkComm.tk_tcl2ruby(val, true, false)} ],
        nil
      ]

=begin
      # for Ruby m17n :: ?x --> String --> char-code ( getbyte(0) )
      KEY_TBL.map!{|inf|
        if inf.kind_of?(Array)
          inf[0] = inf[0].getbyte(0) if inf[0].kind_of?(String)
          inf[1] = inf[1].getbyte(0) if inf[1].kind_of?(String)
        end
        inf
      }

      PROC_TBL.map!{|inf|
        if inf.kind_of?(Array)
          inf[0] = inf[0].getbyte(0) if inf[0].kind_of?(String)
        end
        inf
      }
=end

      _setup_subst_table(KEY_TBL, PROC_TBL);

      def self.ret_val(val)
        TkComm._get_eval_string(val)
      end
    end

    def self._config_keys
      ['command']
    end
  end
  #--------------------------------
  class SelectionCommand < TkValidateCommand
    class ValidateArgs < TkUtil::CallbackSubst
      KEY_TBL = [
        [ ?c, ?n, :sel_columns ],
        [ ?C, ?s, :sel_area ],
        [ ?i, ?n, :total ],
        [ ?r, ?n, :sel_rows ],
        [ ?s, ?s, :value ],
        [ ?W, ?w, :widget ],
        nil
      ]

      PROC_TBL = [
        [ ?n, TkComm.method(:number) ],
        [ ?s, TkComm.method(:string) ],
        [ ?w, TkComm.method(:window) ],
        nil
      ]

=begin
      # for Ruby m17n :: ?x --> String --> char-code ( getbyte(0) )
      KEY_TBL.map!{|inf|
        if inf.kind_of?(Array)
          inf[0] = inf[0].getbyte(0) if inf[0].kind_of?(String)
          inf[1] = inf[1].getbyte(0) if inf[1].kind_of?(String)
        end
        inf
      }

      PROC_TBL.map!{|inf|
        if inf.kind_of?(Array)
          inf[0] = inf[0].getbyte(0) if inf[0].kind_of?(String)
        end
        inf
      }
=end

      _setup_subst_table(KEY_TBL, PROC_TBL);

      def self.ret_val(val)
        val.to_s
      end
    end

    def self._config_keys
      ['selectioncommand', 'selcmd']
    end
  end
  #--------------------------------
  class ValidateCommand < TkValidateCommand
    class ValidateArgs < TkUtil::CallbackSubst
      KEY_TBL = [
        [ ?c, ?n, :column ],
        [ ?C, ?s, :index ],
        [ ?i, ?x, :cursor ],
        [ ?r, ?n, :row ],
        [ ?s, ?v, :current_value ],
        [ ?S, ?v, :new_value ],
        [ ?W, ?w, :widget ],
        nil
      ]

      PROC_TBL = [
        [ ?n, TkComm.method(:number) ],
        [ ?x, TkComm.method(:num_or_str) ],
        [ ?s, TkComm.method(:string) ],
        [ ?w, TkComm.method(:window) ],
        [ ?v, proc{|val| TkComm.tk_tcl2ruby(val, true, false)} ],
        nil
      ]

=begin
      # for Ruby m17n :: ?x --> String --> char-code ( getbyte(0) )
      KEY_TBL.map!{|inf|
        if inf.kind_of?(Array)
          inf[0] = inf[0].getbyte(0) if inf[0].kind_of?(String)
          inf[1] = inf[1].getbyte(0) if inf[1].kind_of?(String)
        end
        inf
      }

      PROC_TBL.map!{|inf|
        if inf.kind_of?(Array)
          inf[0] = inf[0].getbyte(0) if inf[0].kind_of?(String)
        end
        inf
      }
=end

      _setup_subst_table(KEY_TBL, PROC_TBL);
    end

    def self._config_keys
      ['vcmd', 'validatecommand']
    end
  end

  #################################

  def __validation_class_list
    super() <<
      BrowseCommand << CellCommand << SelectionCommand << ValidateCommand
  end

  Tk::ValidateConfigure.__def_validcmd(binding, BrowseCommand)
  Tk::ValidateConfigure.__def_validcmd(binding, CellCommand)
  Tk::ValidateConfigure.__def_validcmd(binding, SelectionCommand)
  Tk::ValidateConfigure.__def_validcmd(binding, ValidateCommand)

  #################################

  def activate(idx)
    tk_send('activate', tagid(idx))
  end

  def bbox(idx)
    list(tk_send('bbox', tagid(idx)))
  end

  def border_mark(x, y)
    simplelist(tk_send('border', 'mark', x, y))
  end
  def border_mark_row(x, y)
    tk_send('border', 'mark', x, y, 'row')
  end
  def border_mark_col(x, y)
    tk_send('border', 'mark', x, y, 'col')
  end
  def border_dragto(x, y)
    tk_send('border', 'dragto', x, y)
  end

  def clear_cache(first=None, last=None)
    tk_send('clear', 'cache', tagid(first), tagid(last))
    self
  end
  def clear_sizes(first=None, last=None)
    tk_send('clear', 'sizes', tagid(first), tagid(last))
    self
  end
  def clear_tags(first=None, last=None)
    tk_send('clear', 'tags', tagid(first), tagid(last))
    self
  end
  def clear_all(first=None, last=None)
    tk_send('clear', 'all', tagid(first), tagid(last))
    self
  end

  def curselection
    simplelist(tk_send('curselection'))
  end
  def curselection=(val)
    tk_send('curselection', val)
    val
  end

  def curvalue
    tk_tcl2ruby(tk_send('curvalue'), true, false)
  end
  def curvalue=(val)
    tk_send('curvalue', val)
    val
  end

  def delete_active(idx1, idx2=None)
    tk_send('delete', 'active', tagid(idx1), tagid(idx2))
    self
  end
  def delete_cols(*args) # ?switches_array?, index, ?count?
    params = []
    if args[0].kind_of?(Array)
      switches = args.shift
      switches.each{|k| params << "-#{k}"}
    end
    params << '--'
    params << tagid(args.shift)
    params.concat(args)
    tk_send('delete', 'cols', *params)
    self
  end
  def delete_rows(*args) # ?switches_array?, index, ?count?
    params = []
    if args[0].kind_of?(Array)
      switches = args.shift
      switches.each{|k| params << "-#{k}"}
    end
    params << '--'
    params << tagid(args.shift)
    params.concat(args)
    tk_send('delete', 'rows', *params)
    self
  end

  def get(idx)
    tk_tcl2ruby(tk_send('get', tagid(idx)), true, false)
  end
  def get_area(idx1, idx2)
    simplelist(tk_send('get', tagid(idx1), tagid(idx2))).collect{|v|
      tk_tcl2ruby(v, true, false)
    }
  end

  def height_list
    list(tk_send('height'))
  end
  def height(row)
    number(tk_send('height', row))
  end
  def set_height(*pairs)
    tk_send('height', *(pairs.flatten))
    self
  end

  def hidden_list
    simplelist(tk_send('hidden'))
  end
  def hidden?(idx, *args)
    if args.empty?
      if (ret = tk_send('hidden', tagid(idx))) == ''
        false
      else
        ret
      end
    else
      bool(tk_send('hidden', tagid(idx), *(args.collect{|i| tagid(i)})))
    end
  end

  def icursor
    number(tk_send('icursor'))
  end
  def icursor_set(idx)
    number(tk_send('icursor', tagid(idx)))
  end

  def index(idx)
    tk_send('index', tagid(idx))
  end
  def row_index(idx)
    number(tk_send('index', tagid(idx), 'row'))
  end
  def col_index(idx)
    number(tk_send('index', tagid(idx), 'col'))
  end

  def insert_active(idx, val)
    tk_send('insert', 'active', tagid(idx), val)
    self
  end
  def insert_cols(*args) # ?switches_array?, index, ?count?
    params = []
    if args[0].kind_of?(Array)
      switches = args.shift
      switches.each{|k| params << "-#{k}"}
    end
    params << '--'
    params.concat(args)
    params << tagid(args.shift)
    tk_send('insert', 'cols', *params)
    self
  end
  def insert_rows(*args) # ?switches_array?, index, ?count?
    params = []
    if args[0].kind_of?(Array)
      switches = args.shift
      switches.each{|k| params << "-#{k}"}
    end
    params << '--'
    params << tagid(args.shift)
    params.concat(args)
    tk_send('insert', 'rows', *params)
    self
  end

  # def postscript(*args)
  #   tk_send('postscript', *args)
  # end

  def reread
    tk_send('reread')
    self
  end

  def scan_mark(x, y)
    tk_send('scan', 'mark', x, y)
    self
  end
  def scan_dragto(x, y)
    tk_send('scan', 'dragto', x, y)
    self
  end

  def see(idx)
    tk_send('see', tagid(idx))
    self
  end

  def selection_anchor(idx)
    tk_send('selection', 'anchor', tagid(idx))
    self
  end
  def selection_clear(first, last=None)
    tk_send('selection', 'clear', tagid(first), tagid(last))
    self
  end
  def selection_clear_all
    selection_clear('all')
  end
  def selection_include?(idx)
    bool(tk_send('selection', 'includes', tagid(idx)))
  end
  def selection_present
    bool(tk_send('selection', 'present'))
  end
  def selection_set(first, last=None)
    tk_send('selection', 'set', tagid(first), tagid(last))
    self
  end

  def set(*pairs) # idx, val, idx, val, ...
    args = []
    0.step(pairs.size-1, 2){|i|
      args << tagid(pairs[i])
      args << pairs[i+1]
    }
    tk_send('set', *args)
    self
  end
  def set_row(*pairs) # idx, val, idx, val, ...
    args = []
    0.step(pairs.size-1, 2){|i|
      args << tagid(pairs[i])
      args << pairs[i+1]
    }
    tk_send('set', 'row', *args)
    self
  end
  def set_col(*pairs) # idx, val, idx, val, ...
    args = []
    0.step(pairs.size-1, 2){|i|
      args << tagid(pairs[i])
      args << pairs[i+1]
    }
    tk_send('set', 'col', *args)
    self
  end
=begin
  def set(*pairs) # idx, val, idx, val, ...  OR [idx, val], [idx, val], ...
    if pairs[0].kind_of?(Array)
      # [idx, val], [idx, val], ...
      args = []
      pairs.each{|idx, val| args << tagid(idx) << val }
      tk_send('set', *args)
    else
      # idx, val, idx, val, ...
      args = []
      0.step(pairs.size-1, 2){|i|
        args << tagid(pairs[i])
        args << pairs[i+1]
      }
      tk_send('set', *args)
    end
    self
  end
  def set_row(*pairs)
    if pairs[0].kind_of?(Array)
      # [idx, val], [idx, val], ...
      args = []
      pairs.each{|idx, val| args << tagid(idx) << val }
      tk_send('set', 'row', *args)
    else
      # idx, val, idx, val, ...
      args = []
      0.step(pairs.size-1, 2){|i|
        args << tagid(pairs[i])
        args << pairs[i+1]
      }
      tk_send('set', 'row', *args)
    end
    self
  end
  def set_col(*pairs)
    if pairs[0].kind_of?(Array)
      # [idx, val], [idx, val], ...
      args = []
      pairs.each{|idx, val| args << idx << val }
      tk_send('set', 'col', *args)
    else
      # idx, val, idx, val, ...
      args = []
      0.step(pairs.size-1, 2){|i|
        args << tagid(pairs[i])
        args << pairs[i+1]
      }
      tk_send('set', 'col', *args)
    end
    self
  end
=end

  def spans
    simplelist(tk_send('spans')).collect{|inf|
      lst = simplelist(inf)
      idx = lst[0]
      rows, cols = lst[1].split(',').map!{|n| Integer(n)}
      [idx [rows, cols]]
    }
  end
  alias span_list spans
  def span(idx)
    lst = simplelist(tk_send('spans', tagid(idx)))
    idx = lst[0]
    rows, cols = lst[1].split(',').map!{|n| Integer(n)}
    [idx [rows, cols]]
  end
  def set_spans(*pairs)
    # idx, val, idx, val, ...
    args = []
    0.step(pairs.size-1, 2){|i|
      args << tagid(pairs[i])
      val = pairs[i+1]
      if val.kind_of?(Array)
        args << val.join(',')
      else
        args << val
      end
    }
    tk_send('spans', *args)
    self
  end
=begin
  def set_spans(*pairs)
    if pairs[0].kind_of?(Array)
      # [idx, val], [idx, val], ...
      args = []
      pairs.each{|idx, val|
        args << tagid(idx)
        if val.kind_of?(Array)
          args << val.join(',')
        else
          args << val
        end
      }
      tk_send('spans', *args)
    else
      # idx, val, idx, val, ...
      args = []
      0.step(pairs.size-1, 2){|i|
        args << tagid(pairs[i])
        val = pairs[i+1]
        if val.kind_of?(Array)
          args << val.join(',')
        else
          args << val
        end
      }
      tk_send('spans', *args)
    end
    self
  end
=end

  def tagid(tag)
    if tag.kind_of?(Tk::TkTable::CellTag)
      tag.id
    elsif tag.kind_of?(Array)
      if tag[0].kind_of?(Integer) && tag[1].kind_of?(Integer)
        # [row, col]
        tag.join(',')
      else
        tag
      end
    else
      tag
    end
  end

  def tagid2obj(tagid)
    Tk::TkTable::CellTag::CellTagID_TBL.mutex.synchronize{
      if Tk::TkTable::CellTag::CellTagID_TBL.key?(@path)
        if Tk::TkTable::CellTag::CellTagID_TBL[@path].key?(tagid)
          Tk::TkTable::CellTag::CellTagID_TBL[@path][tagid]
        else
          tagid
        end
      else
        tagid
      end
    }
  end

  def tag_cell(tag, *cells)
    tk_send('tag', 'cell', tagid(tag), *(cells.collect{|idx| tagid(idx)}))
    self
  end
  def tag_reset(*cells)
    tk_send('tag', 'cell', '', *(cells.collect{|idx| tagid(idx)}))
    self
  end
  def tag_col(tag, *cols)
    tk_send('tag', 'col', tagid(tag), *cols)
    self
  end
  def tag_col_reset(*cols)
    tk_send('tag', 'col', '', *cols)
    self
  end
  def tag_delete(tag)
    tk_send('tag', 'delete', tagid(tag))
    Tk::TkTable::CellTag::CellTagID_TBL.mutex.synchronize{
      if Tk::TkTable::CellTag::CellTagID_TBL[@path]
        if tag.kind_of? Tk::TkTable::CellTag
          Tk::TkTable::CellTag::CellTagID_TBL[@path].delete(tag.id)
        else
          Tk::TkTable::CellTag::CellTagID_TBL[@path].delete(tag)
        end
      end
    }
    self
  end
  def tag_exist?(tag)
    bool(tk_send('tag', 'exists', tagid(tag)))
  end
  def tag_include?(tag, idx)
    bool(tk_send('tag', 'includes', tagid(tag), tagid(idx)))
  end
  def tag_lower(tag, target=None)
    tk_send('tag', 'lower', tagid(tag), tagid(target))
    self
  end
  def tag_names(pat=None)
    simplelist(tk_send('tag', 'names', pat)).collect{|tag| tagid2obj(tag)}
  end
  def tag_raise(tag, target=None)
    tk_send('tag', 'raise', tagid(tag), tagid(target))
    self
  end
  def tag_row(tag, *rows)
    tk_send('tag', 'row', tagid(tag), *rows)
    self
  end
  def tag_row_reset(*rows)
    tk_send('tag', 'row', '', *rows)
    self
  end

  def validate(idx)
    bool(tk_send('validate', tagid(idx)))
  end

  def width_list
    list(tk_send('width'))
  end
  def width(row)
    number(tk_send('width', row))
  end
  def set_width(*pairs)
    tk_send('width', *(pairs.flatten))
    self
  end

  def window_delete(*args)
    tk_send('window', 'delete', *(args.collect{|idx| tagid(idx)}))
    self
  end
  def window_move(from_idx, to_idx)
    tk_send('window', 'move', tagid(from_idx), tagid(to_idx))
    self
  end
  def window_names(pat=None)
    simplelist(tk_send('window', 'names', pat))
  end
end
