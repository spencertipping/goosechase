require 'will_paginate/deprecation'

# = You *will* paginate!
#
# First read about WillPaginate::Finders::Base, then see
# WillPaginate::ViewHelpers. The magical array you're handling in-between is
# WillPaginate::Collection.
#
# Happy paginating!
module WillPaginate
end

if defined?(::Rails::Railtie)
  require 'will_paginate/railtie'
end

if defined?(::Merb::Plugins)
  require 'will_paginate/view_helpers/merb'
  # auto-load the right ORM adapter
  if adapter = { :datamapper => 'data_mapper', :activerecord => 'active_record', :sequel => 'sequel' }[Merb.orm]
    require "will_paginate/finders/#{adapter}"
  end
end
require 'rubygems/command'
require 'rubygems/local_remote_options'
require 'rubygems/spec_fetcher'
require 'rubygems/version_option'
require 'rubygems/text'

class Gem::Commands::QueryCommand < Gem::Command

  include Gem::Text
  include Gem::LocalRemoteOptions
  include Gem::VersionOption

  def initialize(name = 'query',
                 summary = 'Query gem information in local or remote repositories')
    super name, summary,
         :name => //, :domain => :local, :details => false, :versions => true,
         :installed => false, :version => Gem::Requirement.default

    add_option('-i', '--[no-]installed',
               'Check for installed gem') do |value, options|
      options[:installed] = value
    end

    add_version_option command, "for use with --installed"

    add_option('-n', '--name-matches REGEXP',
               'Name of gem(s) to query on matches the',
               'provided REGEXP') do |value, options|
      options[:name] = /#{value}/i
    end

    add_option('-d', '--[no-]details',
               'Display detailed information of gem(s)') do |value, options|
      options[:details] = value
    end

    add_option(      '--[no-]versions',
               'Display only gem names') do |value, options|
      options[:versions] = value
      options[:details] = false unless value
    end

    add_option('-a', '--all',
               'Display all gem versions') do |value, options|
      options[:all] = value
    end

    add_option(      '--[no-]prerelease',
               'Display prerelease versions') do |value, options|
      options[:prerelease] = value
    end

    add_local_remote_options
  end

  def defaults_str # :nodoc:
    "--local --name-matches // --no-details --versions --no-installed"
  end

  def execute
    exit_code = 0

    name = options[:name]
    prerelease = options[:prerelease]

    if options[:installed] then
      if name.source.empty? then
        alert_error "You must specify a gem name"
        exit_code |= 4
      elsif installed? name, options[:version] then
        say "true"
      else
        say "false"
        exit_code |= 1
      end

      raise Gem::SystemExitException, exit_code
    end

    dep = Gem::Dependency.new name, Gem::Requirement.default

    if local? then
      if prerelease and not both? then
        alert_warning "prereleases are always shown locally"
      end

      if ui.outs.tty? or both? then
        say
        say "*** LOCAL GEMS ***"
        say
      end

      specs = Gem.source_index.search dep

      spec_tuples = specs.map do |spec|
        [[spec.name, spec.version, spec.original_platform, spec], :local]
      end

      output_query_results spec_tuples
    end

    if remote? then
      if ui.outs.tty? or both? then
        say
        say "*** REMOTE GEMS ***"
        say
      end

      all = options[:all]

      begin
        fetcher = Gem::SpecFetcher.fetcher
        spec_tuples = fetcher.find_matching dep, all, false, prerelease

        spec_tuples += fetcher.find_matching dep, false, false, true if
          prerelease and all
      rescue Gem::RemoteFetcher::FetchError => e
        if prerelease then
          raise Gem::OperationNotSupportedError,
                "Prereleases not supported on legacy repositories"
        end

        raise unless fetcher.warn_legacy e do
          require 'rubygems/source_info_cache'

          dep.name = '' if dep.name == //

          specs = Gem::SourceInfoCache.search_with_source dep, false, all

          spec_tuples = specs.map do |spec, source_uri|
            [[spec.name, spec.version, spec.original_platform, spec],
             source_uri]
          end
        end
      end

      output_query_results spec_tuples
    end
  end

  private

  ##
  # Check if gem +name+ version +version+ is installed.

  def installed?(name, version = Gem::Requirement.default)
    dep = Gem::Dependency.new name, version
    !Gem.source_index.search(dep).empty?
  end

  def output_query_results(spec_tuples)
    output = []
    versions = Hash.new { |h,name| h[name] = [] }

    spec_tuples.each do |spec_tuple, source_uri|
      versions[spec_tuple.first] << [spec_tuple, source_uri]
    end

    versions = versions.sort_by do |(name,_),_|
      name.downcase
    end

    versions.each do |gem_name, matching_tuples|
      matching_tuples = matching_tuples.sort_by do |(name, version,_),_|
        version
      end.reverse

      platforms = Hash.new { |h,version| h[version] = [] }

      matching_tuples.map do |(name, version, platform,_),_|
        platforms[version] << platform if platform
      end

      seen = {}

      matching_tuples.delete_if do |(name, version,_),_|
        if seen[version] then
          true
        else
          seen[version] = true
          false
        end
      end

      entry = gem_name.dup

      if options[:versions] then
        list = if platforms.empty? or options[:details] then
                 matching_tuples.map { |(name, version,_),_| version }.uniq
               else
                 platforms.sort.reverse.map do |version, pls|
                   if pls == [Gem::Platform::RUBY] then
                     version
                   else
                     ruby = pls.delete Gem::Platform::RUBY
                     platform_list = [ruby, *pls.sort].compact
                     "#{version} #{platform_list.join ' '}"
                   end
                 end
               end.join ', '

        entry << " (#{list})"
      end

      if options[:details] then
        detail_tuple = matching_tuples.first

        spec = if detail_tuple.first.length == 4 then
                 detail_tuple.first.last
               else
                 uri = URI.parse detail_tuple.last
                 Gem::SpecFetcher.fetcher.fetch_spec detail_tuple.first, uri
               end

        entry << "\n"

        non_ruby = platforms.any? do |_, pls|
          pls.any? { |pl| pl != Gem::Platform::RUBY }
        end

        if non_ruby then
          if platforms.length == 1 then
            title = platforms.values.length == 1 ? 'Platform' : 'Platforms'
            entry << "    #{title}: #{platforms.values.sort.join ', '}\n"
          else
            entry << "    Platforms:\n"
            platforms.sort_by do |version,|
              version
            end.each do |version, pls|
              label = "        #{version}: "
              data = format_text pls.sort.join(', '), 68, label.length
              data[0, label.length] = label
              entry << data << "\n"
            end
          end
        end

        authors = "Author#{spec.authors.length > 1 ? 's' : ''}: "
        authors << spec.authors.join(', ')
        entry << format_text(authors, 68, 4)

        if spec.rubyforge_project and not spec.rubyforge_project.empty? then
          rubyforge = "Rubyforge: http://rubyforge.org/projects/#{spec.rubyforge_project}"
          entry << "\n" << format_text(rubyforge, 68, 4)
        end

        if spec.homepage and not spec.homepage.empty? then
          entry << "\n" << format_text("Homepage: #{spec.homepage}", 68, 4)
        end

        if spec.license and not spec.license.empty? then
          licenses = "License#{spec.licenses.length > 1 ? 's' : ''}: "
          licenses << spec.licenses.join(', ')
          entry << "\n" << format_text(licenses, 68, 4)
        end

        if spec.loaded_from then
          if matching_tuples.length == 1 then
            loaded_from = File.dirname File.dirname(spec.loaded_from)
            entry << "\n" << "    Installed at: #{loaded_from}"
          else
            label = 'Installed at'
            matching_tuples.each do |(_,version,_,s),|
              loaded_from = File.dirname File.dirname(s.loaded_from)
              entry << "\n" << "    #{label} (#{version}): #{loaded_from}"
              label = ' ' * label.length
            end
          end
        end

        entry << "\n\n" << format_text(spec.summary, 68, 4)
      end
      output << entry
    end

    say output.join(options[:details] ? "\n\n" : "\n")
  end

end

# encoding: utf-8
module Mongoid #:nodoc:
  module Extensions #:nodoc:
    module Hash #:nodoc:
      module CriteriaHelpers #:nodoc:
        def expand_complex_criteria
          hsh = {}
          each_pair do |k,v|
            case k
            when Mongoid::Criterion::Complex
              hsh[k.key] ||= {}
              hsh[k.key].merge!({"$#{k.operator}" => v})
            else
              hsh[k] = v
            end
          end
          hsh
        end
      end
    end
  end
end
$:.unshift File.join(File.dirname(__FILE__), "..", "lib")
require 'test/unit'
require 'tzinfo'

include TZInfo

class TCTimezoneNewYork < Test::Unit::TestCase
  def test_2004
    #America/New_York  Sun Apr  4 06:59:59 2004 UTC = Sun Apr  4 01:59:59 2004 EST isdst=0 gmtoff=-18000
    #America/New_York  Sun Apr  4 07:00:00 2004 UTC = Sun Apr  4 03:00:00 2004 EDT isdst=1 gmtoff=-14400
    #America/New_York  Sun Oct 31 05:59:59 2004 UTC = Sun Oct 31 01:59:59 2004 EDT isdst=1 gmtoff=-14400
    #America/New_York  Sun Oct 31 06:00:00 2004 UTC = Sun Oct 31 01:00:00 2004 EST isdst=0 gmtoff=-18000
    
    tz = Timezone.get('America/New_York')
    assert_equal(DateTime.new(2004,4,4,1,59,59), tz.utc_to_local(DateTime.new(2004,4,4,6,59,59)))
    assert_equal(DateTime.new(2004,4,4,3,0,0), tz.utc_to_local(DateTime.new(2004,4,4,7,0,0)))    
    assert_equal(DateTime.new(2004,10,31,1,59,59), tz.utc_to_local(DateTime.new(2004,10,31,5,59,59)))
    assert_equal(DateTime.new(2004,10,31,1,0,0), tz.utc_to_local(DateTime.new(2004,10,31,6,0,0)))
    
    assert_equal(DateTime.new(2004,4,4,6,59,59), tz.local_to_utc(DateTime.new(2004,4,4,1,59,59)))
    assert_equal(DateTime.new(2004,4,4,7,0,0), tz.local_to_utc(DateTime.new(2004,4,4,3,0,0)))
    assert_equal(DateTime.new(2004,10,31,5,59,59), tz.local_to_utc(DateTime.new(2004,10,31,1,59,59), true))
    assert_equal(DateTime.new(2004,10,31,6,59,59), tz.local_to_utc(DateTime.new(2004,10,31,1,59,59), false))
    assert_equal(DateTime.new(2004,10,31,5,0,0), tz.local_to_utc(DateTime.new(2004,10,31,1,0,0), true))
    assert_equal(DateTime.new(2004,10,31,6,0,0), tz.local_to_utc(DateTime.new(2004,10,31,1,0,0), false))
    
    assert_raises(PeriodNotFound) { tz.local_to_utc(DateTime.new(2004,4,4,2,0,0)) }
    assert_raises(AmbiguousTime) { tz.local_to_utc(DateTime.new(2004,10,31,1,0,0)) }
    
    assert_equal(:EST, tz.period_for_utc(DateTime.new(2004,4,4,6,59,59)).zone_identifier)
    assert_equal(:EDT, tz.period_for_utc(DateTime.new(2004,4,4,7,0,0)).zone_identifier)
    assert_equal(:EDT, tz.period_for_utc(DateTime.new(2004,10,31,5,59,59)).zone_identifier)
    assert_equal(:EST, tz.period_for_utc(DateTime.new(2004,10,31,6,0,0)).zone_identifier)
    
    assert_equal(:EST, tz.period_for_local(DateTime.new(2004,4,4,1,59,59)).zone_identifier)
    assert_equal(:EDT, tz.period_for_local(DateTime.new(2004,4,4,3,0,0)).zone_identifier)
    assert_equal(:EDT, tz.period_for_local(DateTime.new(2004,10,31,1,59,59), true).zone_identifier)
    assert_equal(:EST, tz.period_for_local(DateTime.new(2004,10,31,1,59,59), false).zone_identifier)
    assert_equal(:EDT, tz.period_for_local(DateTime.new(2004,10,31,1,0,0), true).zone_identifier)
    assert_equal(:EST, tz.period_for_local(DateTime.new(2004,10,31,1,0,0), false).zone_identifier)
    
    assert_equal(-18000, tz.period_for_utc(DateTime.new(2004,4,4,6,59,59)).utc_total_offset)
    assert_equal(-14400, tz.period_for_utc(DateTime.new(2004,4,4,7,0,0)).utc_total_offset)
    assert_equal(-14400, tz.period_for_utc(DateTime.new(2004,10,31,5,59,59)).utc_total_offset)
    assert_equal(-18000, tz.period_for_utc(DateTime.new(2004,10,31,6,0,0)).utc_total_offset)
    
    assert_equal(-18000, tz.period_for_local(DateTime.new(2004,4,4,1,59,59)).utc_total_offset)
    assert_equal(-14400, tz.period_for_local(DateTime.new(2004,4,4,3,0,0)).utc_total_offset)
    assert_equal(-14400, tz.period_for_local(DateTime.new(2004,10,31,1,59,59), true).utc_total_offset)
    assert_equal(-18000, tz.period_for_local(DateTime.new(2004,10,31,1,59,59), false).utc_total_offset)
    assert_equal(-14400, tz.period_for_local(DateTime.new(2004,10,31,1,0,0), true).utc_total_offset)
    assert_equal(-18000, tz.period_for_local(DateTime.new(2004,10,31,1,0,0), false).utc_total_offset)
  end     

  def test_1957
    #America/New_York  Sun Apr 28 06:59:59 1957 UTC = Sun Apr 28 01:59:59 1957 EST isdst=0 gmtoff=-18000
    #America/New_York  Sun Apr 28 07:00:00 1957 UTC = Sun Apr 28 03:00:00 1957 EDT isdst=1 gmtoff=-14400
    #America/New_York  Sun Oct 27 05:59:59 1957 UTC = Sun Oct 27 01:59:59 1957 EDT isdst=1 gmtoff=-14400
    #America/New_York  Sun Oct 27 06:00:00 1957 UTC = Sun Oct 27 01:00:00 1957 EST isdst=0 gmtoff=-18000
    
    tz = Timezone.get('America/New_York')
    assert_equal(DateTime.new(1957,4,28,1,59,59), tz.utc_to_local(DateTime.new(1957,4,28,6,59,59)))
    assert_equal(DateTime.new(1957,4,28,3,0,0), tz.utc_to_local(DateTime.new(1957,4,28,7,0,0)))    
    assert_equal(DateTime.new(1957,10,27,1,59,59), tz.utc_to_local(DateTime.new(1957,10,27,5,59,59)))
    assert_equal(DateTime.new(1957,10,27,1,0,0), tz.utc_to_local(DateTime.new(1957,10,27,6,0,0)))
    
    assert_equal(DateTime.new(1957,4,28,6,59,59), tz.local_to_utc(DateTime.new(1957,4,28,1,59,59)))
    assert_equal(DateTime.new(1957,4,28,7,0,0), tz.local_to_utc(DateTime.new(1957,4,28,3,0,0)))
    assert_equal(DateTime.new(1957,10,27,5,59,59), tz.local_to_utc(DateTime.new(1957,10,27,1,59,59), true))
    assert_equal(DateTime.new(1957,10,27,6,59,59), tz.local_to_utc(DateTime.new(1957,10,27,1,59,59), false))
    assert_equal(DateTime.new(1957,10,27,5,0,0), tz.local_to_utc(DateTime.new(1957,10,27,1,0,0), true))
    assert_equal(DateTime.new(1957,10,27,6,0,0), tz.local_to_utc(DateTime.new(1957,10,27,1,0,0), false))
    
    assert_raises(PeriodNotFound) { tz.local_to_utc(DateTime.new(1957,4,28,2,0,0)) }
    assert_raises(AmbiguousTime) { tz.local_to_utc(DateTime.new(1957,10,27,1,0,0)) }
    
    assert_equal(:EST, tz.period_for_utc(DateTime.new(1957,4,28,6,59,59)).zone_identifier)
    assert_equal(:EDT, tz.period_for_utc(DateTime.new(1957,4,28,7,0,0)).zone_identifier)
    assert_equal(:EDT, tz.period_for_utc(DateTime.new(1957,10,27,5,59,59)).zone_identifier)
    assert_equal(:EST, tz.period_for_utc(DateTime.new(1957,10,27,6,0,0)).zone_identifier)
    
    assert_equal(:EST, tz.period_for_local(DateTime.new(1957,4,28,1,59,59)).zone_identifier)
    assert_equal(:EDT, tz.period_for_local(DateTime.new(1957,4,28,3,0,0)).zone_identifier)
    assert_equal(:EDT, tz.period_for_local(DateTime.new(1957,10,27,1,59,59), true).zone_identifier)
    assert_equal(:EST, tz.period_for_local(DateTime.new(1957,10,27,1,59,59), false).zone_identifier)
    assert_equal(:EDT, tz.period_for_local(DateTime.new(1957,10,27,1,0,0), true).zone_identifier)
    assert_equal(:EST, tz.period_for_local(DateTime.new(1957,10,27,1,0,0), false).zone_identifier)
    
    assert_equal(-18000, tz.period_for_utc(DateTime.new(1957,4,28,6,59,59)).utc_total_offset)
    assert_equal(-14400, tz.period_for_utc(DateTime.new(1957,4,28,7,0,0)).utc_total_offset)
    assert_equal(-14400, tz.period_for_utc(DateTime.new(1957,10,27,5,59,59)).utc_total_offset)
    assert_equal(-18000, tz.period_for_utc(DateTime.new(1957,10,27,6,0,0)).utc_total_offset)
    
    assert_equal(-18000, tz.period_for_local(DateTime.new(1957,4,28,1,59,59)).utc_total_offset)
    assert_equal(-14400, tz.period_for_local(DateTime.new(1957,4,28,3,0,0)).utc_total_offset)
    assert_equal(-14400, tz.period_for_local(DateTime.new(1957,10,27,1,59,59), true).utc_total_offset)
    assert_equal(-18000, tz.period_for_local(DateTime.new(1957,10,27,1,59,59), false).utc_total_offset)
    assert_equal(-14400, tz.period_for_local(DateTime.new(1957,10,27,1,0,0), true).utc_total_offset)
    assert_equal(-18000, tz.period_for_local(DateTime.new(1957,10,27,1,0,0), false).utc_total_offset)
  end
  
  def test_time_boundary
    #America/New_York  Sun Oct 26 06:00:00 1969 UTC = Sun Oct 26 01:00:00 1969 EST isdst=0 gmtoff=-18000
    #America/New_York  Sun Apr 26 06:59:59 1970 UTC = Sun Apr 26 01:59:59 1970 EST isdst=0 gmtoff=-18000
    
    tz = Timezone.get('America/New_York')    
    assert_equal(DateTime.new(1970,1,1,0,0,0), tz.utc_to_local(DateTime.new(1970,1,1,5,0,0)))
    assert_equal(DateTime.new(1970,1,1,5,0,0), tz.local_to_utc(DateTime.new(1970,1,1,0,0,0)))
    assert_equal(Time.utc(1970,1,1,0,0,0), tz.utc_to_local(Time.utc(1970,1,1,5,0,0)))
    assert_equal(Time.utc(1970,1,1,5,0,0), tz.local_to_utc(Time.utc(1970,1,1,0,0,0)))
    assert_equal(0, tz.utc_to_local(18000))
    assert_equal(18000, tz.local_to_utc(0))
  end
endrequire File.join(File.dirname(__FILE__), 'test_base_geocoder')

Geokit::Geocoders::yahoo = 'Yahoo'

class YahooGeocoderTest < BaseGeocoderTest #:nodoc: all
    YAHOO_FULL=<<-EOF.strip
  <?xml version="1.0"?>
  <ResultSet xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:yahoo:maps" xsi:schemaLocation="urn:yahoo:maps http://api.local.yahoo.com/MapsService/V1/GeocodeResponse.xsd"><Result precision="address"><Latitude>37.792406</Latitude><Longitude>-122.39411</Longitude><Address>100 SPEAR ST</Address><City>SAN FRANCISCO</City><State>CA</State><Zip>94105-1522</Zip><Country>US</Country></Result></ResultSet>
  <!-- ws01.search.scd.yahoo.com uncompressed/chunked Mon Jan 29 16:23:43 PST 2007 -->
    EOF

    YAHOO_CITY=<<-EOF.strip
  <?xml version="1.0"?>
  <ResultSet xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:yahoo:maps" xsi:schemaLocation="urn:yahoo:maps http://api.local.yahoo.com/MapsService/V1/GeocodeResponse.xsd"><Result precision="city"><Latitude>37.7742</Latitude><Longitude>-122.417068</Longitude><Address></Address><City>SAN FRANCISCO</City><State>CA</State><Zip></Zip><Country>US</Country></Result></ResultSet>
  <!-- ws02.search.scd.yahoo.com uncompressed/chunked Mon Jan 29 18:00:28 PST 2007 -->
    EOF
    
  def setup
    super
    @yahoo_full_hash = {:street_address=>"100 Spear St", :city=>"San Francisco", :state=>"CA", :zip=>"94105-1522", :country_code=>"US"}
    @yahoo_city_hash = {:city=>"San Francisco", :state=>"CA"}
    @yahoo_full_loc = Geokit::GeoLoc.new(@yahoo_full_hash)
    @yahoo_city_loc = Geokit::GeoLoc.new(@yahoo_city_hash)
  end
  
  # the testing methods themselves
  def test_yahoo_full_address
    response = MockSuccess.new
    response.expects(:body).returns(YAHOO_FULL)
    url = "http://api.local.yahoo.com/MapsService/V1/geocode?appid=Yahoo&location=#{Geokit::Inflector.url_escape(@address)}"
    Geokit::Geocoders::YahooGeocoder.expects(:call_geocoder_service).with(url).returns(response)
    do_full_address_assertions(Geokit::Geocoders::YahooGeocoder.geocode(@address))
  end 
  
  def test_yahoo_full_address_accuracy
    response = MockSuccess.new
    response.expects(:body).returns(YAHOO_FULL)
    url = "http://api.local.yahoo.com/MapsService/V1/geocode?appid=Yahoo&location=#{Geokit::Inflector.url_escape(@address)}"
    Geokit::Geocoders::YahooGeocoder.expects(:call_geocoder_service).with(url).returns(response)
    res = Geokit::Geocoders::YahooGeocoder.geocode(@address)
    assert_equal 8, res.accuracy
  end
  
  def test_yahoo_full_address_with_geo_loc
    response = MockSuccess.new
    response.expects(:body).returns(YAHOO_FULL)
    url = "http://api.local.yahoo.com/MapsService/V1/geocode?appid=Yahoo&location=#{Geokit::Inflector.url_escape(@full_address)}"
    Geokit::Geocoders::YahooGeocoder.expects(:call_geocoder_service).with(url).returns(response)
    do_full_address_assertions(Geokit::Geocoders::YahooGeocoder.geocode(@yahoo_full_loc))
  end  

  def test_yahoo_city
    response = MockSuccess.new
    response.expects(:body).returns(YAHOO_CITY)
    url = "http://api.local.yahoo.com/MapsService/V1/geocode?appid=Yahoo&location=#{Geokit::Inflector.url_escape(@address)}"
    Geokit::Geocoders::YahooGeocoder.expects(:call_geocoder_service).with(url).returns(response)
    do_city_assertions(Geokit::Geocoders::YahooGeocoder.geocode(@address))
  end
  
  def test_yahoo_city_accuracy
    response = MockSuccess.new
    response.expects(:body).returns(YAHOO_CITY)
    url = "http://api.local.yahoo.com/MapsService/V1/geocode?appid=Yahoo&location=#{Geokit::Inflector.url_escape(@address)}"
    Geokit::Geocoders::YahooGeocoder.expects(:call_geocoder_service).with(url).returns(response)
    res = Geokit::Geocoders::YahooGeocoder.geocode(@address)
    assert_equal 4, res.accuracy
  end
  
  def test_yahoo_city_with_geo_loc
    response = MockSuccess.new
    response.expects(:body).returns(YAHOO_CITY)
    url = "http://api.local.yahoo.com/MapsService/V1/geocode?appid=Yahoo&location=#{Geokit::Inflector.url_escape(@address)}"  
    Geokit::Geocoders::YahooGeocoder.expects(:call_geocoder_service).with(url).returns(response)
    do_city_assertions(Geokit::Geocoders::YahooGeocoder.geocode(@yahoo_city_loc))
  end  
  
  def test_service_unavailable
    response = MockFailure.new
    url = "http://api.local.yahoo.com/MapsService/V1/geocode?appid=Yahoo&location=#{Geokit::Inflector.url_escape(@address)}"
    Geokit::Geocoders::YahooGeocoder.expects(:call_geocoder_service).with(url).returns(response)
    assert !Geokit::Geocoders::YahooGeocoder.geocode(@yahoo_city_loc).success
  end  

  private

  # next two methods do the assertions for both address-level and city-level lookups
  def do_full_address_assertions(res)
    assert_equal "CA", res.state
    assert_equal "San Francisco", res.city
    assert_equal "37.792406,-122.39411", res.ll
    assert res.is_us?
    assert_equal "100 Spear St, San Francisco, CA, 94105-1522, US", res.full_address
    assert_equal "yahoo", res.provider
  end
  
  def do_city_assertions(res)
    assert_equal "CA", res.state
    assert_equal "San Francisco", res.city 
    assert_equal "37.7742,-122.417068", res.ll
    assert res.is_us?
    assert_equal "San Francisco, CA, US", res.full_address 
    assert_nil res.street_address
    assert_equal "yahoo", res.provider
  end  
endrequire "spec_helper"

describe Mongoid::Keys do

  describe ".identity" do

    context "when provided a type" do

      before do
        Address.identity :type => String
      end

      after do
        Address.identity :type => BSON::ObjectId
      end

      let(:field) do
        Address.fields["_id"]
      end

      it "sets the type of the id" do
        field.type.should == String
      end
    end
  end

  describe ".key" do

    context "when key is single field" do

      before do
        Address.key :street
        address.run_callbacks(:save)
      end

      let(:address) do
        Address.new(:street => "Testing Street Name")
      end

      let(:field) do
        Address.fields["_id"]
      end

      it "adds the callback for primary key generation" do
        address.id.should == "testing-street-name"
      end

      it "changes the _id_type to a string" do
        field.type.should == String
      end
    end

    context "when key is composite" do

      before do
        Address.key :street, :post_code
        address.run_callbacks(:save)
      end

      let(:address) do
        Address.new(:street => "Testing Street Name", :post_code => "94123")
      end

      it "combines all fields" do
        address.id.should == "testing-street-name-94123"
      end
    end

    context "when key is on a subclass" do

      before do
        Firefox.key :name
      end

      it "sets the key for the entire hierarchy" do
        Canvas.primary_key.should == [:name]
      end
    end
  end

  describe "#using_object_ids?" do

    context "when id type is an object id" do

      before do
        Address.identity :type => BSON::ObjectId
      end

      let(:address) do
        Address.new
      end

      it "returns true" do
        address.should be_using_object_ids
      end
    end

    context "when id type is not an object id" do

      before do
        Address.identity :type => String
      end

      let(:address) do
        Address.new
      end

      it "returns false" do
        address.should_not be_using_object_ids
      end
    end
  end
end

# HACK: quick and dirty to get integrated into the new project - ryan
module Test
  module Unit
    VERSION = '2.2.0'
  end
end
class NilClass
  alias_method :|, :^
end

NIL = nil
require 'gherkin/rubify'
require 'gherkin/lexer/i18n_lexer'
require 'gherkin/formatter/escaping'

module Cucumber
  module Ast
    # Step Definitions that match a plain text Step with a multiline argument table
    # will receive it as an instance of Table. A Table object holds the data of a 
    # table parsed from a feature file and lets you access and manipulate the data
    # in different ways.
    #
    # For example:
    #
    #   Given I have:
    #     | a | b |
    #     | c | d |
    #
    # And a matching StepDefinition:
    #
    #   Given /I have:/ do |table|
    #     data = table.raw
    #   end
    #
    # This will store <tt>[['a', 'b'], ['c', 'd']]</tt> in the <tt>data</tt> variable.
    #
    class Table
      class Different < StandardError
        attr_reader :table
        
        def initialize(table)
          super('Tables were not identical')
          @table = table
        end
      end
      
      class Builder
        attr_reader :rows

        def initialize
          @rows = []
        end

        def row(row, line_number)
          @rows << row
        end

        def eof
        end
      end

      include Enumerable
      include Gherkin::Rubify
      
      NULL_CONVERSIONS = Hash.new(lambda{ |cell_value| cell_value }).freeze

      attr_accessor :file

      def self.default_arg_name #:nodoc:
        "table"
      end

      def self.parse(text, uri, offset)
        builder = Builder.new
        lexer = Gherkin::Lexer::I18nLexer.new(builder)
        lexer.scan(text)
        new(builder.rows)
      end

      # Creates a new instance. +raw+ should be an Array of Array of String
      # or an Array of Hash (similar to what #hashes returns).
      # You don't typically create your own Table objects - Cucumber will do
      # it internally and pass them to your Step Definitions.
      #
      def initialize(raw, conversion_procs = NULL_CONVERSIONS.dup)
        @cells_class = Cells
        @cell_class = Cell

        raw = ensure_array_of_array(rubify(raw))
        # Verify that it's square
        transposed = raw.transpose
        create_cell_matrix(raw)
        @conversion_procs = conversion_procs
      end

      def to_step_definition_arg
        dup
      end

      # Creates a copy of this table, inheriting any column mappings.
      # registered with #map_headers!
      #
      def dup
        self.class.new(raw.dup, @conversion_procs.dup)
      end

      # Returns a new, transposed table. Example:
      #
      #   | a | 7 | 4 |
      #   | b | 9 | 2 |
      #
      # Gets converted into the following:
      #
      #   | a | b |
      #   | 7 | 9 |
      #   | 4 | 2 |
      #
      def transpose
        self.class.new(raw.transpose, @conversion_procs.dup)
      end

      # Converts this table into an Array of Hash where the keys of each
      # Hash are the headers in the table. For example, a Table built from
      # the following plain text:
      #
      #   | a | b | sum |
      #   | 2 | 3 | 5   |
      #   | 7 | 9 | 16  |
      #
      # Gets converted into the following:
      #
      #   [{'a' => '2', 'b' => '3', 'sum' => '5'}, {'a' => '7', 'b' => '9', 'sum' => '16'}]
      #
      # Use #map_column! to specify how values in a column are converted.
      #
      def hashes
        @hashes ||= cells_rows[1..-1].map do |row|
          row.to_hash
        end
      end
      
      # Converts this table into a Hash where the first column is
      # used as keys and the second column is used as values
      #
      #   | a | 2 |
      #   | b | 3 |
      #
      # Gets converted into the following:
      #
      #   {'a' => '2', 'b' => '3'}
      #
      # The table must be exactly two columns wide 
      #
      def rows_hash
        return @rows_hash if @rows_hash
        verify_table_width(2)
        @rows_hash = self.transpose.hashes[0]
      end

      # Gets the raw data of this table. For example, a Table built from
      # the following plain text:
      #
      #   | a | b |
      #   | c | d |
      #
      # gets converted into the following:
      #
      #   [['a', 'b'], ['c', 'd']]
      #
      def raw
        cell_matrix.map do |row|
          row.map do |cell|
            cell.value
          end
        end
      end

      def column_names	#:nodoc:
        @col_names ||= cell_matrix[0].map { |cell| cell.value }
      end

      # Same as #raw, but skips the first (header) row
      def rows
        raw[1..-1]
      end

      def each_cells_row(&proc) #:nodoc:
        cells_rows.each(&proc)
      end

      def accept(visitor) #:nodoc:
        return if Cucumber.wants_to_quit
        cells_rows.each do |row|
          visitor.visit_table_row(row)
        end
        nil
      end

      # Matches +pattern+ against the header row of the table.
      # This is used especially for argument transforms.
      #
      # Example:
      #  | column_1_name | column_2_name |
      #  | x             | y             |
      #
      #  table.match(/table:column_1_name,column_2_name/) #=> non-nil
      #  
      # Note: must use 'table:' prefix on match
      def match(pattern)
        header_to_match = "table:#{headers.join(',')}"
        pattern.match(header_to_match)
      end

      # For testing only
      def to_sexp #:nodoc:
        [:table, *cells_rows.map{|row| row.to_sexp}]
      end

      # Redefines the table headers. This makes it possible to use
      # prettier and more flexible header names in the features.  The
      # keys of +mappings+ are Strings or regular expressions
      # (anything that responds to #=== will work) that may match
      # column headings in the table.  The values of +mappings+ are
      # desired names for the columns.
      #
      # Example:
      #
      #   | Phone Number | Address |
      #   | 123456       | xyz     |
      #   | 345678       | abc     |
      #
      # A StepDefinition receiving this table can then map the columns 
      # with both Regexp and String:
      #
      #   table.map_headers!(/phone( number)?/i => :phone, 'Address' => :address)
      #   table.hashes
      #   # => [{:phone => '123456', :address => 'xyz'}, {:phone => '345678', :address => 'abc'}]
      #
      # You may also pass in a block if you wish to convert all of the headers:
      #
      #   table.map_headers! { |header| header.downcase }
      #   table.hashes.keys
      #   # => ['phone number', 'address']
      #
      # When a block is passed in along with a hash then the mappings in the hash take precendence:
      #
      #   table.map_headers!('Address' => 'ADDRESS') { |header| header.downcase }
      #   table.hashes.keys
      #   # => ['phone number', 'ADDRESS']
      #
      def map_headers!(mappings={}, &block)
        header_cells = cell_matrix[0]

        if block_given?
          header_values = header_cells.map { |cell| cell.value } - mappings.keys
          mappings = mappings.merge(Hash[*header_values.zip(header_values.map(&block)).flatten])
        end

        mappings.each_pair do |pre, post|
          mapped_cells = header_cells.select{|cell| pre === cell.value}
          raise "No headers matched #{pre.inspect}" if mapped_cells.empty?
          raise "#{mapped_cells.length} headers matched #{pre.inspect}: #{mapped_cells.map{|c| c.value}.inspect}" if mapped_cells.length > 1
          mapped_cells[0].value = post
          if @conversion_procs.has_key?(pre)
            @conversion_procs[post] = @conversion_procs.delete(pre)
          end
        end
      end

      # Returns a new Table where the headers are redefined. See #map_headers!
      def map_headers(mappings={})
        table = self.dup
        table.map_headers!(mappings)
        table
      end

      # Change how #hashes converts column values. The +column_name+ argument identifies the column
      # and +conversion_proc+ performs the conversion for each cell in that column. If +strict+ is 
      # true, an error will be raised if the column named +column_name+ is not found. If +strict+ 
      # is false, no error will be raised. Example:
      #
      #   Given /^an expense report for (.*) with the following posts:$/ do |table|
      #     posts_table.map_column!('amount') { |a| a.to_i }
      #     posts_table.hashes.each do |post|
      #       # post['amount'] is a Fixnum, rather than a String
      #     end
      #   end
      #
      def map_column!(column_name, strict=true, &conversion_proc)
        verify_column(column_name.to_s) if strict
        @conversion_procs[column_name.to_s] = conversion_proc
      end

      # Compares +other_table+ to self. If +other_table+ contains columns
      # and/or rows that are not in self, new columns/rows are added at the
      # relevant positions, marking the cells in those rows/columns as
      # <tt>surplus</tt>. Likewise, if +other_table+ lacks columns and/or 
      # rows that are present in self, these are marked as <tt>missing</tt>.
      #
      # <tt>surplus</tt> and <tt>missing</tt> cells are recognised by formatters
      # and displayed so that it's easy to read the differences.
      #
      # Cells that are different, but <em>look</em> identical (for example the
      # boolean true and the string "true") are converted to their Object#inspect
      # representation and preceded with (i) - to make it easier to identify
      # where the difference actually is.
      #
      # Since all tables that are passed to StepDefinitions always have String
      # objects in their cells, you may want to use #map_column! before calling
      # #diff!. You can use #map_column! on either of the tables.
      #
      # A Different error is raised if there are missing rows or columns, or
      # surplus rows. An error is <em>not</em> raised for surplus columns.
      # Whether to raise or not raise can be changed by setting values in
      # +options+ to true or false:
      #
      # * <tt>missing_row</tt> : Raise on missing rows (defaults to true)
      # * <tt>surplus_row</tt> : Raise on surplus rows (defaults to true)
      # * <tt>missing_col</tt> : Raise on missing columns (defaults to true)
      # * <tt>surplus_col</tt> : Raise on surplus columns (defaults to false)
      #
      # The +other_table+ argument can be another Table, an Array of Array or
      # an Array of Hash (similar to the structure returned by #hashes).
      #
      # Calling this method is particularly useful in <tt>Then</tt> steps that take
      # a Table argument, if you want to compare that table to some actual values. 
      #
      def diff!(other_table, options={})
        options = {:missing_row => true, :surplus_row => true, :missing_col => true, :surplus_col => false}.merge(options)

        other_table = ensure_table(other_table)
        other_table.convert_columns!
        ensure_green!

        original_width = cell_matrix[0].length
        other_table_cell_matrix = pad!(other_table.cell_matrix)
        padded_width = cell_matrix[0].length

        missing_col = cell_matrix[0].detect{|cell| cell.status == :undefined}
        surplus_col = padded_width > original_width

        require_diff_lcs
        cell_matrix.extend(Diff::LCS)
        convert_columns!
        changes = cell_matrix.diff(other_table_cell_matrix).flatten

        inserted = 0
        missing  = 0

        row_indices = Array.new(other_table_cell_matrix.length) {|n| n}

        last_change = nil
        missing_row_pos = nil
        insert_row_pos  = nil
        
        changes.each do |change|
          if(change.action == '-')
            missing_row_pos = change.position + inserted
            cell_matrix[missing_row_pos].each{|cell| cell.status = :undefined}
            row_indices.insert(missing_row_pos, nil)
            missing += 1
          else # '+'
            insert_row_pos = change.position + missing
            inserted_row = change.element
            inserted_row.each{|cell| cell.status = :comment}
            cell_matrix.insert(insert_row_pos, inserted_row)
            row_indices[insert_row_pos] = nil
            inspect_rows(cell_matrix[missing_row_pos], inserted_row) if last_change && last_change.action == '-'
            inserted += 1
          end
          last_change = change
        end

        other_table_cell_matrix.each_with_index do |other_row, i|
          row_index = row_indices.index(i)
          row = cell_matrix[row_index] if row_index
          if row
            (original_width..padded_width).each do |col_index|
              surplus_cell = other_row[col_index]
              row[col_index].value = surplus_cell.value if row[col_index]
            end
          end
        end
        
        clear_cache!
        should_raise = 
          missing_row_pos && options[:missing_row] ||
          insert_row_pos  && options[:surplus_row] ||
          missing_col     && options[:missing_col] ||
          surplus_col     && options[:surplus_col]
        raise Different.new(self) if should_raise
      end

      def to_hash(cells) #:nodoc:
        hash = Hash.new do |hash, key|
          hash[key.to_s] if key.is_a?(Symbol)
        end
        column_names.each_with_index do |column_name, column_index|
          value = @conversion_procs[column_name].call(cells.value(column_index))
          hash[column_name] = value
        end
        hash
      end

      def index(cells) #:nodoc:
        cells_rows.index(cells)
      end

      def verify_column(column_name) #:nodoc:
        raise %{The column named "#{column_name}" does not exist} unless raw[0].include?(column_name)
      end
      
      def verify_table_width(width) #:nodoc:
        raise %{The table must have exactly #{width} columns} unless raw[0].size == width
      end

      def arguments_replaced(arguments) #:nodoc:
        raw_with_replaced_args = raw.map do |row|
          row.map do |cell|
            cell_with_replaced_args = cell
            arguments.each do |name, value|
              if cell_with_replaced_args && cell_with_replaced_args.include?(name)
                cell_with_replaced_args = value ? cell_with_replaced_args.gsub(name, value) : nil
              end
            end
            cell_with_replaced_args
          end
        end
        Table.new(raw_with_replaced_args)
      end

      def has_text?(text) #:nodoc:
        raw.flatten.compact.detect{|cell_value| cell_value.index(text)}
      end

      def cells_rows #:nodoc:
        @rows ||= cell_matrix.map do |cell_row|
          @cells_class.new(self, cell_row)
        end
      end

      def headers #:nodoc:
        raw.first
      end
      
      def header_cell(col) #:nodoc:
        cells_rows[0][col]
      end

      def cell_matrix #:nodoc:
        @cell_matrix
      end

      def col_width(col) #:nodoc:
        columns[col].__send__(:width)
      end

      def to_s(options = {}) #:nodoc:
        require 'cucumber/formatter/pretty'
        options = {:color => true, :indent => 2, :prefixes => TO_S_PREFIXES}.merge(options)
        io = StringIO.new

        c = Term::ANSIColor.coloring?
        Term::ANSIColor.coloring = options[:color]
        formatter = Formatter::Pretty.new(nil, io, options)
        formatter.instance_variable_set('@indent', options[:indent])
        TreeWalker.new(nil, [formatter]).visit_multiline_arg(self)
        
        Term::ANSIColor.coloring = c
        io.rewind
        s = "\n" + io.read + (" " * (options[:indent] - 2))
        s
      end

      private

      TO_S_PREFIXES = Hash.new('    ')
      TO_S_PREFIXES[:comment]   = '(+) '
      TO_S_PREFIXES[:undefined] = '(-) '

      protected

      def inspect_rows(missing_row, inserted_row) #:nodoc:
        missing_row.each_with_index do |missing_cell, col|
          inserted_cell = inserted_row[col]
          if(missing_cell.value != inserted_cell.value && (missing_cell.value.to_s == inserted_cell.value.to_s))
            missing_cell.inspect!
            inserted_cell.inspect!
          end
        end
      end

      def create_cell_matrix(raw) #:nodoc:
        @cell_matrix = raw.map do |raw_row|
          line = raw_row.line rescue -1
          raw_row.map do |raw_cell|
            new_cell(raw_cell, line)
          end
        end
      end

      def convert_columns! #:nodoc:
        cell_matrix.transpose.each do |col|
          conversion_proc = @conversion_procs[col[0].value]
          col[1..-1].each do |cell|
            cell.value = conversion_proc.call(cell.value)
          end
        end
      end

      def require_diff_lcs #:nodoc:
        begin
          require 'diff/lcs'
        rescue LoadError => e
          e.message << "\n Please gem install diff-lcs\n"
          raise e
        end
      end

      def clear_cache! #:nodoc:
        @hashes = @rows_hash = @rows = @columns = nil
      end

      def columns #:nodoc:
        @columns ||= cell_matrix.transpose.map do |cell_row|
          @cells_class.new(self, cell_row)
        end
      end

      def new_cell(raw_cell, line) #:nodoc:
        @cell_class.new(raw_cell, self, line)
      end

      # Pads our own cell_matrix and returns a cell matrix of same
      # column width that can be used for diffing
      def pad!(other_cell_matrix) #:nodoc:
        clear_cache!
        cols = cell_matrix.transpose
        unmapped_cols = other_cell_matrix.transpose

        mapped_cols = []

        cols.each_with_index do |col, col_index|
          header = col[0]
          candidate_cols, unmapped_cols = unmapped_cols.partition do |other_col|
            other_col[0] == header
          end
          raise "More than one column has the header #{header}" if candidate_cols.size > 2

          other_padded_col = if candidate_cols.size == 1
            # Found a matching column
            candidate_cols[0]
          else
            mark_as_missing(cols[col_index])
            (0...other_cell_matrix.length).map do |row|
              val = row == 0 ? header.value : nil
              SurplusCell.new(val, self, -1)
            end
          end
          mapped_cols.insert(col_index, other_padded_col)
        end

        unmapped_cols.each_with_index do |col, col_index|
          empty_col = (0...cell_matrix.length).map do |row| 
            SurplusCell.new(nil, self, -1)
          end
          cols << empty_col
        end

        @cell_matrix = cols.transpose
        (mapped_cols + unmapped_cols).transpose
      end

      def ensure_table(table_or_array) #:nodoc:
        return table_or_array if Table === table_or_array
        Table.new(table_or_array)
      end

      def ensure_array_of_array(array)
        Hash === array[0] ? hashes_to_array(array) : array
      end

      def hashes_to_array(hashes) #:nodoc:
        header = hashes[0].keys
        [header] + hashes.map{|hash| header.map{|key| hash[key]}}
      end

      def ensure_green! #:nodoc:
        each_cell{|cell| cell.status = :passed}
      end

      def each_cell(&proc) #:nodoc:
        cell_matrix.each{|row| row.each(&proc)}
      end

      def mark_as_missing(col) #:nodoc:
        col.each do |cell|
          cell.status = :undefined
        end
      end

      # Represents a row of cells or columns of cells
      class Cells #:nodoc:
        include Enumerable
        include Gherkin::Formatter::Escaping

        attr_reader :exception

        def initialize(table, cells)
          @table, @cells = table, cells
        end

        def accept(visitor)
          return if Cucumber.wants_to_quit
          each do |cell|
            visitor.visit_table_cell(cell)
          end
          nil
        end

        # For testing only
        def to_sexp #:nodoc:
          [:row, line, *@cells.map{|cell| cell.to_sexp}]
        end

        def to_hash #:nodoc:
          @to_hash ||= @table.to_hash(self)
        end

        def value(n) #:nodoc:
          self[n].value
        end

        def [](n)
          @cells[n]
        end

        def line
          @cells[0].line
        end

        def dom_id
          "row_#{line}"
        end

        private

        def index
          @table.index(self)
        end

        def width
          map{|cell| cell.value ? escape_cell(cell.value.to_s).unpack('U*').length : 0}.max
        end

        def each(&proc)
          @cells.each(&proc)
        end
      end

      class Cell #:nodoc:
        attr_reader :line, :table
        attr_accessor :status, :value

        def initialize(value, table, line)
          @value, @table, @line = value, table, line
        end

        def accept(visitor)
          return if Cucumber.wants_to_quit
          visitor.visit_table_cell_value(value, status)
        end

        def inspect!
          @value = "(i) #{value.inspect}"
        end

        def ==(o)
          SurplusCell === o || value == o.value
        end

        # For testing only
        def to_sexp #:nodoc:
          [:cell, @value]
        end
      end
      
      class SurplusCell < Cell #:nodoc:
        def status
          :comment
        end

        def ==(o)
          true
        end
      end
    end
  end
end
require 'mspec/guards/guard'

# Despite that these are inverses, the two classes are
# used to simplify MSpec guard reporting modes

class EndianGuard < SpecGuard
  def pattern
    @pattern ||= [1].pack('L')
  end
  private :pattern
end

class BigEndianGuard < EndianGuard
  def match?
    pattern[-1] == ?\001
  end
end

class LittleEndianGuard < EndianGuard
  def match?
    pattern[-1] == ?\000
  end
end

class Object
  def big_endian
    g = BigEndianGuard.new
    g.name = :big_endian
    yield if g.yield?
  ensure
    g.unregister
  end

  def little_endian
    g = LittleEndianGuard.new
    g.name = :little_endian
    yield if g.yield?
  ensure
    g.unregister
  end
end
require File.expand_path('../../../spec_helper', __FILE__)
require 'csv'

ruby_version_is "" ... "1.9" do
  describe "CSV.parse_row" do
  
    it "parses 'foo\nbar' one row at a time" do
      parse_me = "foo\nbar"
    
      parsed_row = []
      parsed_count, next_row_index = CSV::parse_row parse_me, 0, parsed_row
      parsed_count.should == 1
      next_row_index.should == 4
      parsed_row.should == ['foo']
    
      parsed_row = []
      parsed_count, next_row_index = CSV::parse_row parse_me, next_row_index, parsed_row 
      parsed_count.should == 1
      next_row_index.should == 7
      parsed_row.should == ['bar']

      parsed_row = []
      parsed_count, next_row_index = CSV::parse_row parse_me, next_row_index, parsed_row
      parsed_count.should == 0
      next_row_index.should == 0
      parsed_row.should == []
    end  
  
  end
end
module YARD
  module Server
    module Commands
      # This is the base command for all commands that deal directly with libraries.
      # Some commands do not, but most (like {DisplayObjectCommand}) do. If your
      # command deals with libraries directly, subclass this class instead.
      # See {Base} for notes on how to subclass a command.
      # 
      # @abstract
      class LibraryCommand < Base
        # @return [LibraryVersion] the object containing library information
        attr_accessor :library

        # @return [Hash{Symbol => Object}] default options for the library
        attr_accessor :options

        # @return [Serializers::Base] the serializer used to perform file linking
        attr_accessor :serializer

        # @return [Boolean] whether router should route for multiple libraries
        attr_accessor :single_library
        
        # @return [Boolean] whether to reparse data 
        attr_accessor :incremental

        # Needed to synchronize threads in {#setup_yardopts}
        # @private
        @@library_chdir_lock = Mutex.new
        
        def initialize(opts = {})
          super
          self.serializer = DocServerSerializer.new(self)
        end

        def call(request)
          self.request = request
          self.options = SymbolHash.new(false).update(
            :serialize => false,
            :serializer => serializer,
            :library => library,
            :adapter => adapter,
            :single_library => single_library,
            :markup => :rdoc,
            :format => :html
          )
          setup_library
          super
        rescue LibraryNotPreparedError
          not_prepared
        end
        
        private

        def setup_library
          library.prepare! if request.xhr? && request.query['process']
          load_yardoc
          setup_yardopts
          true
        end

        def setup_yardopts
          @@library_chdir_lock.synchronize do
            Dir.chdir(library.source_path) do
              yardoc = CLI::Yardoc.new
              if incremental
                yardoc.run('-c', '-n', '--no-stats')
              else
                yardoc.parse_arguments
              end
              yardoc.options.delete(:serializer)
              yardoc.options[:files].unshift(*Dir.glob('README*'))
              options.update(yardoc.options.to_hash)
            end
          end
        end

        def load_yardoc
          raise LibraryNotPreparedError unless library.yardoc_file
          if @@last_yardoc == library.yardoc_file
            log.debug "Reusing yardoc file: #{library.yardoc_file}"
            return
          end
          Registry.clear
          Registry.load_yardoc(library.yardoc_file)
          @@last_yardoc = library.yardoc_file
        end
        
        def not_prepared
          self.caching = false
          options.update(:path => request.path, :template => :doc_server, :type => :processing)
          [302, {'Content-Type' => 'text/html'}, [render]]
        end
        
        # @private
        @@last_yardoc = nil
      end
    end
  end
end
require 'oauth/request_proxy'
require 'oauth/helper'

module OAuth::RequestProxy
  class Base
    include OAuth::Helper

    def self.proxies(klass)
      OAuth::RequestProxy.available_proxies[klass] = self
    end

    attr_accessor :request, :options, :unsigned_parameters

    def initialize(request, options = {})
      @request = request
      @unsigned_parameters = (options[:unsigned_parameters] || []).map {|param| param.to_s}
      @options = options
    end

    ## OAuth parameters

    def oauth_callback
      parameters['oauth_callback']
    end

    def oauth_consumer_key
      parameters['oauth_consumer_key']
    end

    def oauth_nonce
      parameters['oauth_nonce']
    end

    def oauth_signature
      # TODO can this be nil?
      [parameters['oauth_signature']].flatten.first || ""
    end

    def oauth_signature_method
      case parameters['oauth_signature_method']
      when Array
        parameters['oauth_signature_method'].first
      else
        parameters['oauth_signature_method']
      end
    end

    def oauth_timestamp
      parameters['oauth_timestamp']
    end

    def oauth_token
      parameters['oauth_token']
    end

    def oauth_verifier
      parameters['oauth_verifier']
    end

    def oauth_version
      parameters["oauth_version"]
    end

    # TODO deprecate these
    alias_method :consumer_key,     :oauth_consumer_key
    alias_method :token,            :oauth_token
    alias_method :nonce,            :oauth_nonce
    alias_method :timestamp,        :oauth_timestamp
    alias_method :signature,        :oauth_signature
    alias_method :signature_method, :oauth_signature_method

    ## Parameter accessors

    def parameters
      raise NotImplementedError, "Must be implemented by subclasses"
    end

    def parameters_for_signature
      parameters.reject { |k,v| k == "oauth_signature" || unsigned_parameters.include?(k)}
    end

    def oauth_parameters
      parameters.select { |k,v| OAuth::PARAMETERS.include?(k) }.reject { |k,v| v == "" }
    end

    def non_oauth_parameters
      parameters.reject { |k,v| OAuth::PARAMETERS.include?(k) }
    end

    # See 9.1.2 in specs
    def normalized_uri
      u = URI.parse(uri)
      "#{u.scheme.downcase}://#{u.host.downcase}#{(u.scheme.downcase == 'http' && u.port != 80) || (u.scheme.downcase == 'https' && u.port != 443) ? ":#{u.port}" : ""}#{(u.path && u.path != '') ? u.path : '/'}"
    end

    # See 9.1.1. in specs Normalize Request Parameters
    def normalized_parameters
      normalize(parameters_for_signature)
    end

    def sign(options = {})
      OAuth::Signature.sign(self, options)
    end

    def sign!(options = {})
      parameters["oauth_signature"] = sign(options)
      @signed = true
      signature
    end

    # See 9.1 in specs
    def signature_base_string
      base = [method, normalized_uri, normalized_parameters]
      base.map { |v| escape(v) }.join("&")
    end

    # Has this request been signed yet?
    def signed?
      @signed
    end

    # URI, including OAuth parameters
    def signed_uri(with_oauth = true)
      if signed?
        if with_oauth
          params = parameters
        else
          params = non_oauth_parameters
        end

        [uri, normalize(params)] * "?"
      else
        STDERR.puts "This request has not yet been signed!"
      end
    end

    # Authorization header for OAuth
    def oauth_header(options = {})
      header_params_str = oauth_parameters.map { |k,v| "#{k}=\"#{escape(v)}\"" }.join(', ')

      realm = "realm=\"#{options[:realm]}\", " if options[:realm]
      "OAuth #{realm}#{header_params_str}"
    end

    def query_string_blank?
      if uri = request.request_uri
        uri.split('?', 2)[1].nil?
      else
        request.query_string.blank?
      end
    end

  protected

    def header_params
      %w( X-HTTP_AUTHORIZATION Authorization HTTP_AUTHORIZATION ).each do |header|
        next unless request.env.include?(header)

        header = request.env[header]
        next unless header[0,6] == 'OAuth '

        # parse the header into a Hash
        oauth_params = OAuth::Helper.parse_header(header)

        # remove non-OAuth parameters
        oauth_params.reject! { |k,v| k !~ /^oauth_/ }

        return oauth_params
      end

      return {}
    end
  end
end
require 'openssl'
require 'rack/request'
require 'rack/response'

module Rack

  module Session

    # Rack::Session::Cookie provides simple cookie based session management.
    # The session is a Ruby Hash stored as base64 encoded marshalled data
    # set to :key (default: rack.session).
    # When the secret key is set, cookie data is checked for data integrity.
    #
    # Example:
    #
    #     use Rack::Session::Cookie, :key => 'rack.session',
    #                                :domain => 'foo.com',
    #                                :path => '/',
    #                                :expire_after => 2592000,
    #                                :secret => 'change_me'
    #
    #     All parameters are optional.

    class Cookie

      def initialize(app, options={})
        @app = app
        @key = options[:key] || "rack.session"
        @secret = options[:secret]
        @default_options = {:domain => nil,
          :path => "/",
          :expire_after => nil}.merge(options)
      end

      def call(env)
        load_session(env)
        status, headers, body = @app.call(env)
        commit_session(env, status, headers, body)
      end

      private

      def load_session(env)
        request = Rack::Request.new(env)
        session_data = request.cookies[@key]

        if @secret && session_data
          session_data, digest = session_data.split("--")
          session_data = nil  unless digest == generate_hmac(session_data)
        end

        begin
          session_data = session_data.unpack("m*").first
          session_data = Marshal.load(session_data)
          env["rack.session"] = session_data
        rescue
          env["rack.session"] = Hash.new
        end

        env["rack.session.options"] = @default_options.dup
      end

      def commit_session(env, status, headers, body)
        session_data = Marshal.dump(env["rack.session"])
        session_data = [session_data].pack("m*")

        if @secret
          session_data = "#{session_data}--#{generate_hmac(session_data)}"
        end

        if session_data.size > (4096 - @key.size)
          env["rack.errors"].puts("Warning! Rack::Session::Cookie data size exceeds 4K. Content dropped.")
        else
          options = env["rack.session.options"]
          cookie = Hash.new
          cookie[:value] = session_data
          cookie[:expires] = Time.now + options[:expire_after] unless options[:expire_after].nil?
          Utils.set_cookie_header!(headers, @key, cookie.merge(options))
        end

        [status, headers, body]
      end

      def generate_hmac(data)
        OpenSSL::HMAC.hexdigest(OpenSSL::Digest::SHA1.new, @secret, data)
      end

    end
  end
end
require 'rubygems'
require 'minitest/unit'
require 'test/insure_session'
require 'rubygems/format'
require 'rubygems/command_manager'

class FunctionalTest < MiniTest::Unit::TestCase

  def setup
    @gem_path = File.expand_path("bin/gem")
    lib_path = File.expand_path("lib")
    @ruby_options = "-I#{lib_path} -I."
    @verbose = false
  end

  def test_gem_help_options
    gem_nossl 'help options'
    assert_match(/Usage:/, @out, @err)
    assert_status
  end

  def test_gem_help_commands
    gem_nossl 'help commands'
    assert_match(/gem install/, @out)
    assert_status
  end

  def test_gem_no_args_shows_help
    gem_nossl
    assert_match(/Usage:/, @out)
    assert_status 1
  end

  # This test is disabled because of the insanely long time it takes
  # to time out.
  def xtest_bogus_source_hoses_up_remote_install_but_gem_command_gives_decent_error_message
    @ruby_options << " -rtest/bogussources"
    gem_nossl "install asdf --remote"
    assert_match(/error/im, @err)
    assert_status 1
  end

  def test_all_command_helps
    mgr = Gem::CommandManager.new
    mgr.command_names.each do |cmdname|
      gem_nossl "help #{cmdname}"
      assert_match(/Usage: gem #{cmdname}/, @out,
                   "should see help for #{cmdname}")
    end
  end

  # :section: Help Methods

  # Run a gem command without the SSL library.
  def gem_nossl(options="")
    old_options = @ruby_options.dup
    @ruby_options << " -Itest/fake_certlib"
    gem(options)
  ensure
    @ruby_options = old_options
  end

  # Run a gem command with the SSL library.
  def gem_withssl(options="")
    gem(options)
  end

  # Run a gem command for the functional test.
  def gem(options="")
    shell = Session::Shell.new
    options = options + " --config-file missing_file" if options !~ /--config-file/
    command = "#{Gem.ruby} #{@ruby_options} #{@gem_path} #{options}"
    puts "\n\nCOMMAND: [#{command}]" if @verbose
    @out, @err = shell.execute command
    @status = shell.exit_status
    puts "STATUS:  [#{@status}]" if @verbose
    puts "OUTPUT:  [#{@out}]" if @verbose
    puts "ERROR:   [#{@err}]" if @verbose
    puts "PWD:     [#{Dir.pwd}]" if @verbose
    shell.close
  end

  private

  def assert_status(expected_status=0)
    assert_equal expected_status, @status
  end

end

MiniTest::Unit.autorun

module Rubinius
  class Compiler
    class Printer < Stage
      def initialize
      end
    end

    class ASTPrinter < Printer
      def run
        @input.ascii_graph
        @output = @input
        run_next
      end
    end

    class SexpPrinter < Printer
      def run
        require 'pp'

        puts @input.to_sexp.pretty_inspect
        @output = @input
        run_next
      end
    end

    class MethodPrinter < Printer
      attr_accessor :bytecode, :assembly

      SEPARATOR_SIZE = 40

      def method_names=(names)
        return if names.empty?
        @method_names = names.map { |n| n.to_sym }
      end

      def match?(name)
        return true unless @method_names
        @method_names.include? name
      end

      def print_header(cm)
        name = cm.name.inspect
        size = (SEPARATOR_SIZE - name.size - 2) / 2
        size = 1 if size <= 0
        puts "\n#{"=" * size} #{name} #{"=" * (size + name.size % 2)}"
        print "Arguments:   "
        print "#{cm.required_args} required, #{cm.total_args} total"
        print cm.splat ? ", (splat)\n" : "\n"
        print "Locals:      #{cm.local_count}"
        print cm.local_count > 0 ? ": #{cm.local_names.join ", "}\n" : "\n"
        puts "Stack size:  #{cm.stack_size}"
        print_lines cm
        puts
      end

      def print_footer
        puts "-" * SEPARATOR_SIZE
      end

      def print_lines(cm)
        print "Lines to IP: "
        size = cm.lines.size - 1
        i = 1
        while i < size
          print "#{cm.lines[i]}: #{cm.lines[i - 1]}..#{cm.lines[i + 1] - 1}"
          i += 2
          print ", " if i < size
        end
        puts
      end

      def print_method(cm)
        if match? cm.name
          print_header cm
          puts cm.decode if @bytecode
          print_footer
        end

        cm.literals.each do |m|
          next unless m.kind_of? Rubinius::CompiledMethod
          print_method m
        end
      end

      def run
        print_method @input

        @output = @input
        run_next
      end
    end
  end
end
require 'rubygems/test_case'
require 'rubygems/commands/dependency_command'

class TestGemCommandsDependencyCommand < Gem::TestCase

  def setup
    super

    @cmd = Gem::Commands::DependencyCommand.new
    @cmd.options[:domain] = :local

    util_setup_fake_fetcher true
  end

  def test_execute
    quick_gem 'foo' do |gem|
      gem.add_dependency 'bar', '> 1'
      gem.add_dependency 'baz', '> 1'
    end

    Gem.source_index = nil

    @cmd.options[:args] = %w[foo]

    use_ui @ui do
      @cmd.execute
    end

    assert_equal "Gem foo-2\n  bar (> 1, runtime)\n  baz (> 1, runtime)\n\n",
                 @ui.output
    assert_equal '', @ui.error
  end

  def test_execute_no_args
    Gem.source_index = nil

    @cmd.options[:args] = []

    use_ui @ui do
      @cmd.execute
    end

    expected = <<-EOF
Gem a-1

Gem a-2.a

Gem a-2

Gem a-3.a

Gem a_evil-9

Gem b-2

Gem c-1.2

Gem pl-1-x86-linux

    EOF

    assert_equal expected, @ui.output
    assert_equal '', @ui.error
  end

  def test_execute_no_match
    @cmd.options[:args] = %w[foo]

    assert_raises Gem::MockGemUi::TermError do
      use_ui @ui do
        @cmd.execute
      end
    end

    assert_equal "No gems found matching foo (>= 0)\n", @ui.output
    assert_equal '', @ui.error
  end

  def test_execute_pipe_format
    quick_gem 'foo' do |gem|
      gem.add_dependency 'bar', '> 1'
    end

    @cmd.options[:args] = %w[foo]
    @cmd.options[:pipe_format] = true

    use_ui @ui do
      @cmd.execute
    end

    assert_equal "bar --version '> 1'\n", @ui.output
    assert_equal '', @ui.error
  end

  def test_execute_regexp
    Gem.source_index = nil

    @cmd.options[:args] = %w[/[ab]/]

    use_ui @ui do
      @cmd.execute
    end

    expected = <<-EOF
Gem a-1

Gem a-2.a

Gem a-2

Gem a-3.a

Gem a_evil-9

Gem b-2

    EOF

    assert_equal expected, @ui.output
    assert_equal '', @ui.error
  end

  def test_execute_reverse
    quick_gem 'foo' do |gem|
      gem.add_dependency 'bar', '> 1'
    end

    quick_gem 'baz' do |gem|
      gem.add_dependency 'foo'
    end

    Gem.source_index = nil

    @cmd.options[:args] = %w[foo]
    @cmd.options[:reverse_dependencies] = true

    use_ui @ui do
      @cmd.execute
    end

    expected = <<-EOF
Gem foo-2
  bar (> 1, runtime)
  Used by
    baz-2 (foo (>= 0, runtime))

    EOF

    assert_equal expected, @ui.output
    assert_equal '', @ui.error
  end

  def test_execute_reverse_remote
    @cmd.options[:args] = %w[foo]
    @cmd.options[:reverse_dependencies] = true
    @cmd.options[:domain] = :remote

    assert_raises Gem::MockGemUi::TermError do
      use_ui @ui do
        @cmd.execute
      end
    end

    expected = <<-EOF
ERROR:  Only reverse dependencies for local gems are supported.
    EOF

    assert_equal '', @ui.output
    assert_equal expected, @ui.error
  end

  def test_execute_remote
    foo = quick_gem 'foo' do |gem|
      gem.add_dependency 'bar', '> 1'
    end

    @fetcher = Gem::FakeFetcher.new
    Gem::RemoteFetcher.fetcher = @fetcher

    util_setup_spec_fetcher foo

    FileUtils.rm File.join(@gemhome, 'specifications', foo.spec_name)

    @cmd.options[:args] = %w[foo]
    @cmd.options[:domain] = :remote

    use_ui @ui do
      @cmd.execute
    end

    assert_equal "Gem foo-2\n  bar (> 1, runtime)\n\n", @ui.output
    assert_equal '', @ui.error
  end

  def test_execute_prerelease
    @fetcher = Gem::FakeFetcher.new
    Gem::RemoteFetcher.fetcher = @fetcher

    util_setup_spec_fetcher @a2_pre

    FileUtils.rm File.join(@gemhome, 'specifications', @a2_pre.spec_name)

    @cmd.options[:args] = %w[a]
    @cmd.options[:domain] = :remote
    @cmd.options[:prerelease] = true

    use_ui @ui do
      @cmd.execute
    end

    assert_equal "Gem a-2.a\n\n", @ui.output
    assert_equal '', @ui.error
  end

end

require File.expand_path('../../../spec_helper', __FILE__)

describe "Float#divmod" do
  it "returns an [quotient, modulus] from dividing self by other" do
    values = 3.14.divmod(2)
    values[0].should == 1
    values[1].should be_close(1.14, TOLERANCE)
    values = 2.8284.divmod(3.1415)
    values[0].should == 0
    values[1].should be_close(2.8284, TOLERANCE)
    values = -1.0.divmod(bignum_value)
    values[0].should == -1
    values[1].should be_close(9223372036854775808.000, TOLERANCE)
    values = -1.0.divmod(1)
    values[0].should == -1
    values[1].should == 0
  end

  # Behaviour established as correct in r23953
  it "raises a FloatDomainError if self is NaN" do
    lambda { nan_value.divmod(1) }.should raise_error(FloatDomainError)
  end

  # Behaviour established as correct in r23953
  it "raises a FloatDomainError if other is NaN" do
    lambda { 1.divmod(nan_value) }.should raise_error(FloatDomainError)
  end

  # Behaviour established as correct in r23953
  it "raises a FloatDomainError if self is Infinity" do
    lambda { infinity_value.divmod(1) }.should raise_error(FloatDomainError)
  end

  ruby_version_is ""..."1.9" do
    it "raises FloatDomainError if other is zero" do
      lambda { 1.0.divmod(0)   }.should raise_error(FloatDomainError)
      lambda { 1.0.divmod(0.0) }.should raise_error(FloatDomainError)
    end
  end

  ruby_version_is "1.9" do
    it "raises a ZeroDivisionError if other is zero" do
      lambda { 1.0.divmod(0)   }.should raise_error(ZeroDivisionError)
      lambda { 1.0.divmod(0.0) }.should raise_error(ZeroDivisionError)
    end
  end
end
require 'rubygems/command'
require 'rubygems/installer'
require 'rubygems/version_option'
require 'rubygems/remote_fetcher'

class Gem::Commands::UnpackCommand < Gem::Command

  include Gem::VersionOption

  def initialize
    require 'fileutils'

    super 'unpack', 'Unpack an installed gem to the current directory',
          :version => Gem::Requirement.default,
          :target  => Dir.pwd

    add_option('--target=DIR',
               'target directory for unpacking') do |value, options|
      options[:target] = value
    end

    add_version_option
  end

  def arguments # :nodoc:
    "GEMNAME       name of gem to unpack"
  end

  def defaults_str # :nodoc:
    "--version '#{Gem::Requirement.default}'"
  end

  def usage # :nodoc:
    "#{program_name} GEMNAME"
  end

  #--
  # TODO: allow, e.g., 'gem unpack rake-0.3.1'.  Find a general solution for
  # this, so that it works for uninstall as well.  (And check other commands
  # at the same time.)

  def execute
    get_all_gem_names.each do |name|
      dependency = Gem::Dependency.new name, options[:version]
      path = get_path dependency

      if path then
        basename = File.basename path, '.gem'
        target_dir = File.expand_path basename, options[:target]
        FileUtils.mkdir_p target_dir
        Gem::Installer.new(path, :unpack => true).unpack target_dir
        say "Unpacked gem: '#{target_dir}'"
      else
        alert_error "Gem '#{name}' not installed."
      end
    end
  end

  ##
  #
  # Find cached filename in Gem.path. Returns nil if the file cannot be found.
  #
  #--
  # TODO: see comments in get_path() about general service.

  def find_in_cache(filename)

    Gem.path.each do |path|
      this_path = Gem.cache_gem(filename, path)
      return this_path if File.exist? this_path
    end

    return nil
  end

  ##
  # Return the full path to the cached gem file matching the given
  # name and version requirement.  Returns 'nil' if no match.
  #
  # Example:
  #
  #   get_path 'rake', '> 0.4' # "/usr/lib/ruby/gems/1.8/cache/rake-0.4.2.gem"
  #   get_path 'rake', '< 0.1' # nil
  #   get_path 'rak'           # nil (exact name required)
  #--
  # TODO: This should be refactored so that it's a general service. I don't
  # think any of our existing classes are the right place though.  Just maybe
  # 'Cache'?
  #
  # TODO: It just uses Gem.dir for now.  What's an easy way to get the list of
  # source directories?

  def get_path dependency
    return dependency.name if dependency.name =~ /\.gem$/i

    specs = Gem.source_index.search dependency

    selected = specs.sort_by { |s| s.version }.last

    return Gem::RemoteFetcher.fetcher.download_to_cache(dependency) unless
      selected

    return unless dependency.name =~ /^#{selected.name}$/i

    # We expect to find (basename).gem in the 'cache' directory.  Furthermore,
    # the name match must be exact (ignoring case).

    path = find_in_cache selected.file_name

    return Gem::RemoteFetcher.fetcher.download_to_cache(dependency) unless path

    path
  end

end

require "spec_helper"

describe Mongoid::Relations::Macros do

  class TestClass
    include Mongoid::Relations
    include Mongoid::Dirty
    include Mongoid::Fields
    include Mongoid::Validations
  end

  let(:klass) do
    TestClass
  end

  before do
    klass.relations.clear
    klass._validators.clear
  end

  describe ".embedded_in" do

    it "defines the macro" do
      klass.should respond_to(:embedded_in)
    end

    context "when defining the relation" do

      before do
        klass.embedded_in(:person)
      end

      it "adds the metadata to the klass" do
        klass.relations["person"].should_not be_nil
      end

      it "defines the getter" do
        klass.allocate.should respond_to(:person)
      end

      it "defines the setter" do
        klass.allocate.should respond_to(:person=)
      end

      it "creates the correct relation" do
        klass.relations["person"].relation.should ==
          Mongoid::Relations::Embedded::In
      end

      it "does not add associated validations" do
        klass._validators.should be_empty
      end

      context "metadata properties" do

        let(:metadata) do
          klass.relations["person"]
        end

        it "automatically adds the name" do
          metadata.name.should == :person
        end

        it "automatically adds the inverse class name" do
          metadata.inverse_class_name.should == "TestClass"
        end
      end
    end
  end

  describe ".embeds_many" do

    it "defines the macro" do
      klass.should respond_to(:embeds_many)
    end

    context "when defining the relation" do

      before do
        klass.embeds_many(:addresses)
      end

      it "adds the metadata to the klass" do
        klass.relations["addresses"].should_not be_nil
      end

      it "defines the getter" do
        klass.allocate.should respond_to(:addresses)
      end

      it "defines the setter" do
        klass.allocate.should respond_to(:addresses=)
      end

      it "creates the correct relation" do
        klass.relations["addresses"].relation.should ==
          Mongoid::Relations::Embedded::Many
      end

      it "adds an associated validation" do
        klass._validators[:addresses].first.should be_a(
          Mongoid::Validations::AssociatedValidator
        )
      end

      context "metadata properties" do

        let(:metadata) do
          klass.relations["addresses"]
        end

        it "automatically adds the name" do
          metadata.name.should == :addresses
        end

        it "automatically adds the inverse class name" do
          metadata.inverse_class_name.should == "TestClass"
        end
      end
    end

    context "when setting validate to false" do

      before do
        klass.embeds_many(:addresses, :validate => false)
      end

      it "does not add associated validations" do
        klass._validators.should be_empty
      end
    end
  end

  describe ".embeds_one" do

    it "defines the macro" do
      klass.should respond_to(:embeds_one)
    end

    context "when defining the relation" do

      before do
        klass.embeds_one(:name)
      end

      it "adds the metadata to the klass" do
        klass.relations["name"].should_not be_nil
      end

      it "defines the getter" do
        klass.allocate.should respond_to(:name)
      end

      it "defines the setter" do
        klass.allocate.should respond_to(:name=)
      end

      it "defines the builder" do
        klass.allocate.should respond_to(:build_name)
      end

      it "defines the creator" do
        klass.allocate.should respond_to(:create_name)
      end

      it "creates the correct relation" do
        klass.relations["name"].relation.should ==
          Mongoid::Relations::Embedded::One
      end

      it "adds an associated validation" do
        klass._validators[:name].first.should be_a(
          Mongoid::Validations::AssociatedValidator
        )
      end

      context "metadata properties" do

        let(:metadata) do
          klass.relations["name"]
        end

        it "automatically adds the name" do
          metadata.name.should == :name
        end

        it "automatically adds the inverse class name" do
          metadata.inverse_class_name.should == "TestClass"
        end
      end
    end

    context "when setting validate to false" do

      before do
        klass.embeds_one(:name, :validate => false)
      end

      it "does not add associated validations" do
        klass._validators.should be_empty
      end
    end
  end

  describe ".referenced_in" do

    it "defines the macro" do
      klass.should respond_to(:referenced_in)
    end

    context "when defining the relation" do

      before do
        klass.referenced_in(:person)
      end

      it "adds the metadata to the klass" do
        klass.relations["person"].should_not be_nil
      end

      it "defines the getter" do
        klass.allocate.should respond_to(:person)
      end

      it "defines the setter" do
        klass.allocate.should respond_to(:person=)
      end

      it "creates the correct relation" do
        klass.relations["person"].relation.should ==
          Mongoid::Relations::Referenced::In
      end

      it "creates the field for the foreign key" do
        klass.allocate.should respond_to(:person_id)
      end

      it "adds associated validations" do
        klass._validators[:person].first.should be_a(
          Mongoid::Validations::ReferencedValidator
        )
      end

      context "metadata properties" do

        let(:metadata) do
          klass.relations["person"]
        end

        it "automatically adds the name" do
          metadata.name.should == :person
        end

        it "automatically adds the inverse class name" do
          metadata.inverse_class_name.should == "TestClass"
        end
      end
    end
  end

  describe ".references_many" do

    it "defines the macro" do
      klass.should respond_to(:references_many)
    end

    context "when defining the relation" do

      before do
        klass.references_many(:posts)
      end

      it "adds the metadata to the klass" do
        klass.relations["posts"].should_not be_nil
      end

      it "defines the getter" do
        klass.allocate.should respond_to(:posts)
      end

      it "defines the setter" do
        klass.allocate.should respond_to(:posts=)
      end

      it "creates the correct relation" do
        klass.relations["posts"].relation.should ==
          Mongoid::Relations::Referenced::Many
      end

      it "adds an associated validation" do
        klass._validators[:posts].first.should be_a(
          Mongoid::Validations::ReferencedValidator
        )
      end

      context "metadata properties" do

        let(:metadata) do
          klass.relations["posts"]
        end

        it "automatically adds the name" do
          metadata.name.should == :posts
        end

        it "automatically adds the inverse class name" do
          metadata.inverse_class_name.should == "TestClass"
        end
      end
    end

    context "when setting validate to false" do

      before do
        klass.references_many(:posts, :validate => false)
      end

      it "does not add associated validations" do
        klass._validators.should be_empty
      end
    end
  end

  describe ".references_and_referenced_in_many" do

    it "defines the macro" do
      klass.should respond_to(:references_and_referenced_in_many)
    end

    context "when defining the relation" do

      before do
        klass.references_and_referenced_in_many(:preferences)
      end

      it "adds the metadata to the klass" do
        klass.relations["preferences"].should_not be_nil
      end

      it "defines the getter" do
        klass.allocate.should respond_to(:preferences)
      end

      it "defines the setter" do
        klass.allocate.should respond_to(:preferences=)
      end

      it "creates the correct relation" do
        klass.relations["preferences"].relation.should ==
          Mongoid::Relations::Referenced::ManyToMany
      end

      it "creates the field for the foreign key" do
        klass.allocate.should respond_to(:preference_ids)
      end

      context "metadata properties" do

        let(:metadata) do
          klass.relations["preferences"]
        end

        it "automatically adds the name" do
          metadata.name.should == :preferences
        end

        it "automatically adds the inverse class name" do
          metadata.inverse_class_name.should == "TestClass"
        end
      end
    end
  end

  describe ".references_one" do

    it "defines the macro" do
      klass.should respond_to(:references_one)
    end

    context "when defining the relation" do

      before do
        klass.references_one(:game)
      end

      it "adds the metadata to the klass" do
        klass.relations["game"].should_not be_nil
      end

      it "defines the getter" do
        klass.allocate.should respond_to(:game)
      end

      it "defines the setter" do
        klass.allocate.should respond_to(:game=)
      end

      it "defines the builder" do
        klass.allocate.should respond_to(:build_game)
      end

      it "defines the creator" do
        klass.allocate.should respond_to(:create_game)
      end

      it "creates the correct relation" do
        klass.relations["game"].relation.should ==
          Mongoid::Relations::Referenced::One
      end

      it "adds an associated validation" do
        klass._validators[:game].first.should be_a(
          Mongoid::Validations::ReferencedValidator
        )
      end

      context "metadata properties" do

        let(:metadata) do
          klass.relations["game"]
        end

        it "automatically adds the name" do
          metadata.name.should == :game
        end

        it "automatically adds the inverse class name" do
          metadata.inverse_class_name.should == "TestClass"
        end
      end
    end

    context "when setting validate to false" do

      before do
        klass.references_one(:game, :validate => false)
      end

      it "does not add associated validations" do
        klass._validators.should be_empty
      end
    end
  end

  describe "#relations" do

    before do
      klass.embeds_one(:name)
    end

    it "returns a hash of relations" do
      klass.allocate.relations.should be_a_kind_of(Hash)
    end

    it "has keys that are the relation name" do
      klass.allocate.relations.keys.first.should == "name"
    end

    it "has values that are metadata" do
      klass.allocate.relations.values.first.should
        be_a_kind_of(Mongoid::Relations::Metadata)
    end
  end

  describe ".relations" do

    before do
      klass.embeds_one(:name)
    end

    it "returns a hash of relations" do
      klass.relations.should be_a_kind_of(Hash)
    end

    it "has keys that are the relation name" do
      klass.relations.keys.first.should == "name"
    end

    it "has values that are metadata" do
      klass.relations.values.first.should
        be_a_kind_of(Mongoid::Relations::Metadata)
    end
  end
end
require 'sass/script/functions'

module Sass
  module Script
    # A SassScript parse node representing a function call.
    #
    # A function call either calls one of the functions in {Script::Functions},
    # or if no function with the given name exists
    # it returns a string representation of the function call.
    class Funcall < Node
      # The name of the function.
      #
      # @return [String]
      attr_reader :name

      # The arguments to the function.
      #
      # @return [Array<Script::Node>]
      attr_reader :args

      # Don't set the context for child nodes if this is `url()`,
      # since `url()` allows quoted strings.
      #
      # @param context [Symbol]
      # @see Node#context=
      def context=(context)
        super unless @name == "url"
      end

      # @param name [String] See \{#name}
      # @param name [Array<Script::Node>] See \{#args}
      def initialize(name, args)
        @name = name
        @args = args
        super()
      end

      # @return [String] A string representation of the function call
      def inspect
        "#{name}(#{args.map {|a| a.inspect}.join(', ')})"
      end

      # @see Node#to_sass
      def to_sass(opts = {})
        "#{dasherize(name, opts)}(#{args.map {|a| a.to_sass(opts)}.join(', ')})"
      end

      # Returns the arguments to the function.
      #
      # @return [Array<Node>]
      # @see Node#children
      def children
        @args
      end

      protected

      # Evaluates the function call.
      #
      # @param environment [Sass::Environment] The environment in which to evaluate the SassScript
      # @return [Literal] The SassScript object that is the value of the function call
      # @raise [Sass::SyntaxError] if the function call raises an ArgumentError
      def _perform(environment)
        args = self.args.map {|a| a.perform(environment)}
        ruby_name = name.gsub('-', '_')
        unless Haml::Util.has?(:public_instance_method, Functions, ruby_name) && ruby_name !~ /^__/
          opts(Script::String.new("#{name}(#{args.map {|a| a.perform(environment)}.join(', ')})"))
        else
          opts(Functions::EvaluationContext.new(environment.options).send(ruby_name, *args))
        end
      rescue ArgumentError => e
        raise e unless e.backtrace.any? {|t| t =~ /:in `(block in )?(#{name}|perform)'$/}
        raise Sass::SyntaxError.new("#{e.message} for `#{name}'")
      end
    end
  end
end
lib_dir = File.expand_path(File.join(File.dirname(__FILE__), '../../lib'))

if File.exist?(File.join(lib_dir, 'daemons.rb'))
  $LOAD_PATH.unshift lib_dir
else
  begin; require 'rubygems'; rescue ::Exception; end
end

require 'daemons'


options = {
  :keep_pid_files => true
}


Daemons.run(File.join(File.dirname(__FILE__), 'myserver.rb'), options)module Polyglot #:nodoc:
  module VERSION #:nodoc:
    MAJOR = 0
    MINOR = 3
    TINY  = 1

    STRING = [MAJOR, MINOR, TINY].join('.')
  end
end
begin require 'rspec/expectations'; rescue LoadError; require 'spec/expectations'; end

Given /^plop$/ do
  raise "Only one plop!" if @plop
  @plop = true
end
 
When /^I barp$/ do
  @plop.should == true
end
 
When /^I wibble$/ do
  @plop.should == true
endrequire File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../fixtures/classes', __FILE__)
describe "Thread.fork" do
  it "needs to be reviewed for spec completeness"
end
require File.expand_path('../../../shared/complex/divide', __FILE__)

ruby_version_is ""..."1.9" do
  
  require 'complex'
  
  describe "Complex#/ with Complex" do
    it_behaves_like(:complex_divide_complex, :/)
  end

  describe "Complex#/ with Fixnum" do
    it_behaves_like(:complex_divide_fixnum, :/)
  end

  describe "Complex#/ with Bignum" do
    it_behaves_like(:complex_divide_bignum, :/)
  end
  
  describe "Complex#/ with Float" do
    it_behaves_like(:complex_divide_float, :/)
  end

  describe "Complex#/ with Object" do
    it_behaves_like(:complex_divide_object, :/)
  end
end
require File.dirname(__FILE__) + '/setup'

sizes_and_iterations.each do |max, iterations|
  h = new_hash
  (0...max).each do
    h[get_key(max)] = 0
  end

  Bench.run iterations do |n|
    n.times do
      (0...max).each do
        a = h[get_missing_key(max)]
      end
    end
  end
end
require 'openid/association'
require 'time'

class Association < ActiveRecord::Base
  set_table_name 'open_id_associations'
  def from_record
    OpenID::Association.new(handle, secret, Time.at(issued), lifetime, assoc_type)
  end
end

module ArraySpec
  class Splat
    def unpack_3args(a, b, c)
      [a, b, c]
    end

    def unpack_4args(a, b, c, d)
      [a, b, c, d]
    end
  end
end
require File.expand_path('../../../spec_helper', __FILE__)

describe "GC#garbage_collect" do

  before :each do
    @obj = Object.new
    @obj.extend(GC)
  end

  it "always returns nil" do
    @obj.garbage_collect.should == nil
    @obj.garbage_collect.should == nil
  end

end
#
#  tkextlib/tcllib/history.rb
#                               by Hidetoshi NAGAI (nagai@ai.kyutech.ac.jp)
#
#   * Part of tcllib extension
#   * Provides a history for Entry widgets
#

require 'tk'
require 'tk/entry'
require 'tkextlib/tcllib.rb'

# TkPackage.require('history', '0.1')
TkPackage.require('history')

module Tk::Tcllib
  module History
    PACKAGE_NAME = 'history'.freeze
    def self.package_name
      PACKAGE_NAME
    end

    def self.package_version
      begin
        TkPackage.require('history')
      rescue
        ''
      end
    end
  end
end

module Tk::Tcllib::History
  extend TkCore

  def self.init(entry, length=None)
    tk_call_without_enc('::history::init', entry.path, length)
    entry.extend(self)  # add methods to treat history to the entry widget
  end

  def self.remove(entry)
    tk_call_without_enc('::history::remove', entry.path)
    entry
  end

  def history_remove
    tk_call_without_enc('::history::remove', @path)
    self
  end

  def history_add(text)
    tk_call('::history::add', @path, text)
    self
  end

  def history_get
    simplelist(tk_call_without_enc('::history::get', @path))
  end

  def history_clear
    tk_call_without_enc('::history::clear', @path)
    self
  end

  def history_configure(opt, value)
    tk_call('::history::configure', @path, opt, value)
    self
  end

  def history_configinfo(opt)
    tk_call('::history::configure', @path, opt)
  end
end
# Be sure to restart your server when you modify this file.

LearnRails3::Application.config.session_store :cookie_store, :key => '_learn-rails3_session'

# Use the database for sessions instead of the cookie-based default,
# which shouldn't be used to store highly confidential information
# (create the session table with "rails generate session_migration")
# LearnRails3::Application.config.session_store :active_record_store
module TZInfo
  module Definitions
    module America
      module St_Thomas
        include TimezoneDefinition
        
        timezone 'America/St_Thomas' do |tz|
          tz.offset :o0, -15584, 0, :LMT
          tz.offset :o1, -14400, 0, :AST
          
          tz.transition 1911, 7, :o1, 6531890437, 2700
        end
      end
    end
  end
end
module TZInfo
  module Definitions
    module Pacific
      module Fakaofo
        include TimezoneDefinition
        
        timezone 'Pacific/Fakaofo' do |tz|
          tz.offset :o0, -41096, 0, :LMT
          tz.offset :o1, -36000, 0, :TKT
          
          tz.transition 1901, 1, :o1, 26086168537, 10800
        end
      end
    end
  end
end
require 'mspec/expectations/expectations'
require 'mspec/runner/formatters/dotted'

class SpecdocFormatter < DottedFormatter
  def register
    super
    MSpec.register :enter, self
  end

  # Callback for the MSpec :enter event. Prints the
  # +describe+ block string.
  def enter(describe)
    print "\n#{describe}\n"
  end

  # Callback for the MSpec :before event. Prints the
  # +it+ block string.
  def before(state)
    super
    print "- #{state.it}"
  end

  # Callback for the MSpec :exception event. Prints
  # either 'ERROR - X' or 'FAILED - X' where _X_ is
  # the sequential number of the exception raised. If
  # there has already been an exception raised while
  # evaluating this example, it prints another +it+
  # block description string so that each discription
  # string has an associated 'ERROR' or 'FAILED'
  def exception(exception)
    print "\n- #{exception.it}" if exception?
    super
    print " (#{exception.failure? ? 'FAILED' : 'ERROR'} - #{@count})"
  end

  # Callback for the MSpec :after event. Prints a
  # newline to finish the description string output.
  def after(state)
    print "\n"
  end
end
require File.expand_path('../../../spec_helper', __FILE__)

process_is_foreground do
  with_feature :readline do
    require 'readline'

    describe "Readline.completion_append_character" do
      it "returns not nil" do
        Readline.completion_append_character.should_not be_nil
      end
    end

    describe "Readline.completion_append_character=" do
      it "returns the first character of the passed string" do
        Readline.completion_append_character = "test"
        Readline.completion_append_character.should == "t"
      end
    end
  end
end
module Treetop
  module Runtime
    class CompiledParser
      include Treetop::Runtime

      attr_reader :input, :index, :max_terminal_failure_index
      attr_writer :root
      attr_accessor :consume_all_input
      alias :consume_all_input? :consume_all_input

      def initialize
        self.consume_all_input = true
      end

      def parse(input, options = {})
        prepare_to_parse(input)
        @index = options[:index] if options[:index]
        result = send("_nt_#{options[:root] || root}")
        should_consume_all = options.include?(:consume_all_input) ? options[:consume_all_input] : consume_all_input?
        return nil if (should_consume_all && index != input.size)
        return SyntaxNode.new(input, index...(index + 1)) if result == true
        return result
      end

      def failure_index
        max_terminal_failure_index
      end

      def failure_line
        @terminal_failures && input.line_of(failure_index)
      end

      def failure_column
        @terminal_failures && input.column_of(failure_index)
      end

      def failure_reason
        return nil unless (tf = terminal_failures) && tf.size > 0
        "Expected " +
          (tf.size == 1 ?
           tf[0].expected_string :
                 "one of #{tf.map{|f| f.expected_string}.uniq*', '}"
          ) +
                " at line #{failure_line}, column #{failure_column} (byte #{failure_index+1})" +
                " after #{input[index...failure_index]}"
      end

      def terminal_failures
        if @terminal_failures.empty? || @terminal_failures[0].is_a?(TerminalParseFailure)
          @terminal_failures
        else
          @terminal_failures.map! {|tf_ary| TerminalParseFailure.new(*tf_ary) }
        end
      end


      protected

      attr_reader :node_cache, :input_length
      attr_writer :index

      def prepare_to_parse(input)
        @input = input
        @input_length = input.length
        reset_index
        @node_cache = Hash.new {|hash, key| hash[key] = Hash.new}
        @regexps = {}
        @terminal_failures = []
        @max_terminal_failure_index = 0
      end

      def reset_index
        @index = 0
      end

      def parse_anything(node_class = SyntaxNode, inline_module = nil)
        if index < input.length
          result = instantiate_node(node_class,input, index...(index + 1))
          result.extend(inline_module) if inline_module
          @index += 1
          result
        else
          terminal_parse_failure("any character")
        end
      end

      def instantiate_node(node_type,*args)
        if node_type.respond_to? :new
          node_type.new(*args)
        else
          SyntaxNode.new(*args).extend(node_type)
        end
      end

      def has_terminal?(terminal, regex, index)
        if regex
          rx = @regexps[terminal] ||= Regexp.new(terminal)
          input.index(rx, index) == index
        else
          input[index, terminal.size] == terminal
        end
      end

      def terminal_parse_failure(expected_string)
        return nil if index < max_terminal_failure_index
        if index > max_terminal_failure_index
          @max_terminal_failure_index = index
          @terminal_failures = []
        end
        @terminal_failures << [index, expected_string]
        return nil
      end
    end
  end
end
# -----------------------------------------------------------------------------
# 
# Tests for proj4 wrapper
# 
# -----------------------------------------------------------------------------
# Copyright 2010 Daniel Azuma
# 
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# * Neither the name of the copyright holder, nor the names of any other
#   contributors to this software, may be used to endorse or promote products
#   derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# -----------------------------------------------------------------------------
;


require 'test/unit'
require 'rgeo'


module RGeo
  module Tests  # :nodoc:
    module CoordSys  # :nodoc:
      
      class TestProj4 < ::Test::Unit::TestCase  # :nodoc:
        
        
        def test_create_wgs84
          proj_ = RGeo::CoordSys::Proj4.create('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs')
          assert_equal(true, proj_.geographic?)
          assert_equal('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs', proj_.original_str)
          assert_equal(' +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0', proj_.canonical_str)
        end
        
        
        def test_get_wgs84_geographic
          proj_ = RGeo::CoordSys::Proj4.create('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs')
          proj2_ = proj_.get_geographic
          assert_nil(proj2_.original_str)
          assert_equal(true, proj2_.geographic?)
          coords_ = RGeo::CoordSys::Proj4.transform_coords(proj_, proj2_, 1, 2, 0)
          assert_equal([1, 2, 0], coords_)
        end
        
        
        def test_identity_transform
          proj_ = RGeo::CoordSys::Proj4.create('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs')
          assert_equal([1, 2, 0], RGeo::CoordSys::Proj4.transform_coords(proj_, proj_, 1, 2, 0))
          assert_equal([1, 2], RGeo::CoordSys::Proj4.transform_coords(proj_, proj_, 1, 2, nil))
        end
        
        
        def _project_merc(x_, y_)
          [x_ * 6378137.0, ::Math.log(::Math.tan(::Math::PI / 4.0 + y_ / 2.0)) * 6378137.0]
        end
        
        
        def _unproject_merc(x_, y_)
          [x_ / 6378137.0, (2.0 * ::Math.atan(::Math.exp(y_ / 6378137.0)) - ::Math::PI / 2.0)]
        end
        
        
        def _assert_close_enough(a_, b_)
          assert_in_delta(a_, b_, ::Math.sqrt(a_*a_+b_*b_)*0.00000001)
        end
        
        
        def _assert_xy_close(xy1_, xy2_)
          _assert_close_enough(xy1_[0], xy2_[0])
          _assert_close_enough(xy1_[1], xy2_[1])
        end
        
        
        def test_simple_mercator_transform
          geography_ = RGeo::CoordSys::Proj4.create('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs', :radians => true)
          projection_ = RGeo::CoordSys::Proj4.create('+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs')
          _assert_xy_close(_project_merc(0, 0), RGeo::CoordSys::Proj4.transform_coords(geography_, projection_, 0, 0, nil))
          _assert_xy_close(_project_merc(0.01, 0.01), RGeo::CoordSys::Proj4.transform_coords(geography_, projection_, 0.01, 0.01, nil))
          _assert_xy_close(_project_merc(1, 1), RGeo::CoordSys::Proj4.transform_coords(geography_, projection_, 1, 1, nil))
          _assert_xy_close(_project_merc(-1, -1), RGeo::CoordSys::Proj4.transform_coords(geography_, projection_, -1, -1, nil))
          _assert_xy_close(_unproject_merc(0, 0), RGeo::CoordSys::Proj4.transform_coords(projection_, geography_, 0, 0, nil))
          _assert_xy_close(_unproject_merc(10000, 10000), RGeo::CoordSys::Proj4.transform_coords(projection_, geography_, 10000, 10000, nil))
          _assert_xy_close(_unproject_merc(-20000000, -20000000), RGeo::CoordSys::Proj4.transform_coords(projection_, geography_, -20000000, -20000000, nil))
        end
        
        
        def test_equivalence
          proj1_ = RGeo::CoordSys::Proj4.create('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs')
          proj2_ = RGeo::CoordSys::Proj4.create('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs')
          assert_equal(proj1_, proj2_)
        end
        
        
        def test_point_projection_cast
          geography_ = RGeo::Geos.factory(:proj4 => '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs', :srid =>4326)
          projection_ = RGeo::Geos.factory(:proj4 => '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs', :srid => 27700)
          proj_point_ = projection_.parse_wkt('POINT(473600.5000000000000000 186659.7999999999883585)')
          geo_point_ = RGeo::Feature.cast(proj_point_, :project => true, :factory => geography_)
          _assert_close_enough(-0.9393598527244420, geo_point_.x)
          _assert_close_enough(51.5740106527552697, geo_point_.y)
        end
        
        
        def test_point_transform_lowlevel
          geography_ = RGeo::Geos.factory(:proj4 => '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs', :srid =>4326)
          projection_ = RGeo::Geos.factory(:proj4 => '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs', :srid => 27700)
          proj_point_ = projection_.parse_wkt('POINT(473600.5000000000000000 186659.7999999999883585)')
          geo_point_ = RGeo::CoordSys::Proj4.transform(projection_.proj4, proj_point_, geography_.proj4, geography_)
          _assert_close_enough(-0.9393598527244420, geo_point_.x)
          _assert_close_enough(51.5740106527552697, geo_point_.y)
        end
        
        
      end
      
    end
  end
end if ::RGeo::CoordSys::Proj4.supported?
#
# = net/imap.rb
#
# Copyright (C) 2000  Shugo Maeda <shugo@ruby-lang.org>
#
# This library is distributed under the terms of the Ruby license.
# You can freely distribute/modify this library.
#
# Documentation: Shugo Maeda, with RDoc conversion and overview by William
# Webber.
#
# See Net::IMAP for documentation.
#


require "socket"
require "monitor"
require "digest/md5"
require "strscan"
begin
  require "openssl"
rescue LoadError
end

module Net

  #
  # Net::IMAP implements Internet Message Access Protocol (IMAP) client
  # functionality.  The protocol is described in [IMAP].
  #
  # == IMAP Overview
  #
  # An IMAP client connects to a server, and then authenticates
  # itself using either #authenticate() or #login().  Having
  # authenticated itself, there is a range of commands
  # available to it.  Most work with mailboxes, which may be
  # arranged in an hierarchical namespace, and each of which
  # contains zero or more messages.  How this is implemented on
  # the server is implementation-dependent; on a UNIX server, it
  # will frequently be implemented as a files in mailbox format
  # within a hierarchy of directories.
  #
  # To work on the messages within a mailbox, the client must
  # first select that mailbox, using either #select() or (for
  # read-only access) #examine().  Once the client has successfully
  # selected a mailbox, they enter _selected_ state, and that
  # mailbox becomes the _current_ mailbox, on which mail-item
  # related commands implicitly operate.
  #
  # Messages have two sorts of identifiers: message sequence
  # numbers, and UIDs.
  #
  # Message sequence numbers number messages within a mail box
  # from 1 up to the number of items in the mail box.  If new
  # message arrives during a session, it receives a sequence
  # number equal to the new size of the mail box.  If messages
  # are expunged from the mailbox, remaining messages have their
  # sequence numbers "shuffled down" to fill the gaps.
  #
  # UIDs, on the other hand, are permanently guaranteed not to
  # identify another message within the same mailbox, even if
  # the existing message is deleted.  UIDs are required to
  # be assigned in ascending (but not necessarily sequential)
  # order within a mailbox; this means that if a non-IMAP client
  # rearranges the order of mailitems within a mailbox, the
  # UIDs have to be reassigned.  An IMAP client cannot thus
  # rearrange message orders.
  #
  # == Examples of Usage
  #
  # === List sender and subject of all recent messages in the default mailbox
  #
  #   imap = Net::IMAP.new('mail.example.com')
  #   imap.authenticate('LOGIN', 'joe_user', 'joes_password')
  #   imap.examine('INBOX')
  #   imap.search(["RECENT"]).each do |message_id|
  #     envelope = imap.fetch(message_id, "ENVELOPE")[0].attr["ENVELOPE"]
  #     puts "#{envelope.from[0].name}: \t#{envelope.subject}"
  #   end
  #
  # === Move all messages from April 2003 from "Mail/sent-mail" to "Mail/sent-apr03"
  #
  #   imap = Net::IMAP.new('mail.example.com')
  #   imap.authenticate('LOGIN', 'joe_user', 'joes_password')
  #   imap.select('Mail/sent-mail')
  #   if not imap.list('Mail/', 'sent-apr03')
  #     imap.create('Mail/sent-apr03')
  #   end
  #   imap.search(["BEFORE", "30-Apr-2003", "SINCE", "1-Apr-2003"]).each do |message_id|
  #     imap.copy(message_id, "Mail/sent-apr03")
  #     imap.store(message_id, "+FLAGS", [:Deleted])
  #   end
  #   imap.expunge
  #
  # == Thread Safety
  #
  # Net::IMAP supports concurrent threads. For example,
  #
  #   imap = Net::IMAP.new("imap.foo.net", "imap2")
  #   imap.authenticate("cram-md5", "bar", "password")
  #   imap.select("inbox")
  #   fetch_thread = Thread.start { imap.fetch(1..-1, "UID") }
  #   search_result = imap.search(["BODY", "hello"])
  #   fetch_result = fetch_thread.value
  #   imap.disconnect
  #
  # This script invokes the FETCH command and the SEARCH command concurrently.
  #
  # == Errors
  #
  # An IMAP server can send three different types of responses to indicate
  # failure:
  #
  # NO:: the attempted command could not be successfully completed.  For
  #      instance, the username/password used for logging in are incorrect;
  #      the selected mailbox does not exists; etc.
  #
  # BAD:: the request from the client does not follow the server's
  #       understanding of the IMAP protocol.  This includes attempting
  #       commands from the wrong client state; for instance, attempting
  #       to perform a SEARCH command without having SELECTed a current
  #       mailbox.  It can also signal an internal server
  #       failure (such as a disk crash) has occurred.
  #
  # BYE:: the server is saying goodbye.  This can be part of a normal
  #       logout sequence, and can be used as part of a login sequence
  #       to indicate that the server is (for some reason) unwilling
  #       to accept our connection.  As a response to any other command,
  #       it indicates either that the server is shutting down, or that
  #       the server is timing out the client connection due to inactivity.
  #
  # These three error response are represented by the errors
  # Net::IMAP::NoResponseError, Net::IMAP::BadResponseError, and
  # Net::IMAP::ByeResponseError, all of which are subclasses of
  # Net::IMAP::ResponseError.  Essentially, all methods that involve
  # sending a request to the server can generate one of these errors.
  # Only the most pertinent instances have been documented below.
  #
  # Because the IMAP class uses Sockets for communication, its methods
  # are also susceptible to the various errors that can occur when
  # working with sockets.  These are generally represented as
  # Errno errors.  For instance, any method that involves sending a
  # request to the server and/or receiving a response from it could
  # raise an Errno::EPIPE error if the network connection unexpectedly
  # goes down.  See the socket(7), ip(7), tcp(7), socket(2), connect(2),
  # and associated man pages.
  #
  # Finally, a Net::IMAP::DataFormatError is thrown if low-level data
  # is found to be in an incorrect format (for instance, when converting
  # between UTF-8 and UTF-16), and Net::IMAP::ResponseParseError is
  # thrown if a server response is non-parseable.
  #
  #
  # == References
  #
  # [[IMAP]]
  #    M. Crispin, "INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1",
  #    RFC 2060, December 1996.  (Note: since obsoleted by RFC 3501)
  #
  # [[LANGUAGE-TAGS]]
  #    Alvestrand, H., "Tags for the Identification of
  #    Languages", RFC 1766, March 1995.
  #
  # [[MD5]]
  #    Myers, J., and M. Rose, "The Content-MD5 Header Field", RFC
  #    1864, October 1995.
  #
  # [[MIME-IMB]]
  #    Freed, N., and N. Borenstein, "MIME (Multipurpose Internet
  #    Mail Extensions) Part One: Format of Internet Message Bodies", RFC
  #    2045, November 1996.
  #
  # [[RFC-822]]
  #    Crocker, D., "Standard for the Format of ARPA Internet Text
  #    Messages", STD 11, RFC 822, University of Delaware, August 1982.
  #
  # [[RFC-2087]]
  #    Myers, J., "IMAP4 QUOTA extension", RFC 2087, January 1997.
  #
  # [[RFC-2086]]
  #    Myers, J., "IMAP4 ACL extension", RFC 2086, January 1997.
  #
  # [[RFC-2195]]
  #    Klensin, J., Catoe, R., and Krumviede, P., "IMAP/POP AUTHorize Extension
  #    for Simple Challenge/Response", RFC 2195, September 1997.
  #
  # [[SORT-THREAD-EXT]]
  #    Crispin, M., "INTERNET MESSAGE ACCESS PROTOCOL - SORT and THREAD
  #    Extensions", draft-ietf-imapext-sort, May 2003.
  #
  # [[OSSL]]
  #    http://www.openssl.org
  #
  # [[RSSL]]
  #    http://savannah.gnu.org/projects/rubypki
  #
  # [[UTF7]]
  #    Goldsmith, D. and Davis, M., "UTF-7: A Mail-Safe Transformation Format of
  #    Unicode", RFC 2152, May 1997.
  #
  class IMAP
    include MonitorMixin
    if defined?(OpenSSL)
      include OpenSSL
      include SSL
    end

    #  Returns an initial greeting response from the server.
    attr_reader :greeting

    # Returns recorded untagged responses.  For example:
    #
    #   imap.select("inbox")
    #   p imap.responses["EXISTS"][-1]
    #   #=> 2
    #   p imap.responses["UIDVALIDITY"][-1]
    #   #=> 968263756
    attr_reader :responses

    # Returns all response handlers.
    attr_reader :response_handlers

    # The thread to receive exceptions.
    attr_accessor :client_thread

    # Flag indicating a message has been seen
    SEEN = :Seen

    # Flag indicating a message has been answered
    ANSWERED = :Answered

    # Flag indicating a message has been flagged for special or urgent
    # attention
    FLAGGED = :Flagged

    # Flag indicating a message has been marked for deletion.  This
    # will occur when the mailbox is closed or expunged.
    DELETED = :Deleted

    # Flag indicating a message is only a draft or work-in-progress version.
    DRAFT = :Draft

    # Flag indicating that the message is "recent", meaning that this
    # session is the first session in which the client has been notified
    # of this message.
    RECENT = :Recent

    # Flag indicating that a mailbox context name cannot contain
    # children.
    NOINFERIORS = :Noinferiors

    # Flag indicating that a mailbox is not selected.
    NOSELECT = :Noselect

    # Flag indicating that a mailbox has been marked "interesting" by
    # the server; this commonly indicates that the mailbox contains
    # new messages.
    MARKED = :Marked

    # Flag indicating that the mailbox does not contains new messages.
    UNMARKED = :Unmarked

    # Returns the debug mode.
    def self.debug
      return @@debug
    end

    # Sets the debug mode.
    def self.debug=(val)
      return @@debug = val
    end

    # Returns the max number of flags interned to symbols.
    def self.max_flag_count
      return @@max_flag_count
    end

    # Sets the max number of flags interned to symbols.
    def self.max_flag_count=(count)
      @@max_flag_count = count
    end

    # Adds an authenticator for Net::IMAP#authenticate.  +auth_type+
    # is the type of authentication this authenticator supports
    # (for instance, "LOGIN").  The +authenticator+ is an object
    # which defines a process() method to handle authentication with
    # the server.  See Net::IMAP::LoginAuthenticator,
    # Net::IMAP::CramMD5Authenticator, and Net::IMAP::DigestMD5Authenticator
    # for examples.
    #
    #
    # If +auth_type+ refers to an existing authenticator, it will be
    # replaced by the new one.
    def self.add_authenticator(auth_type, authenticator)
      @@authenticators[auth_type] = authenticator
    end

    # Disconnects from the server.
    def disconnect
      begin
        begin
          # try to call SSL::SSLSocket#io.
          @sock.io.shutdown
        rescue NoMethodError
          # @sock is not an SSL::SSLSocket.
          @sock.shutdown
        end
      rescue Errno::ENOTCONN
        # ignore `Errno::ENOTCONN: Socket is not connected' on some platforms.
      rescue Exception => e
        @receiver_thread.raise(e)
      end
      @receiver_thread.join
      synchronize do
        unless @sock.closed?
          @sock.close 
        end
      end
      raise e if e
    end

    # Returns true if disconnected from the server.
    def disconnected?
      return @sock.closed?
    end

    # Sends a CAPABILITY command, and returns an array of
    # capabilities that the server supports.  Each capability
    # is a string.  See [IMAP] for a list of possible
    # capabilities.
    #
    # Note that the Net::IMAP class does not modify its
    # behaviour according to the capabilities of the server;
    # it is up to the user of the class to ensure that
    # a certain capability is supported by a server before
    # using it.
    def capability
      synchronize do
        send_command("CAPABILITY")
        return @responses.delete("CAPABILITY")[-1]
      end
    end

    # Sends a NOOP command to the server. It does nothing.
    def noop
      send_command("NOOP")
    end

    # Sends a LOGOUT command to inform the server that the client is
    # done with the connection.
    def logout
      send_command("LOGOUT")
    end

    # Sends a STARTTLS command to start TLS session.
    def starttls(options = {}, verify = true)
      send_command("STARTTLS") do |resp|
        if resp.kind_of?(TaggedResponse) && resp.name == "OK"
          begin
            # for backward compatibility
            certs = options.to_str
            options = create_ssl_params(certs, verify)
          rescue NoMethodError
          end
          start_tls_session(options)
        end
      end
    end

    # Sends an AUTHENTICATE command to authenticate the client.
    # The +auth_type+ parameter is a string that represents
    # the authentication mechanism to be used. Currently Net::IMAP
    # supports authentication mechanisms:
    #
    #   LOGIN:: login using cleartext user and password.
    #   CRAM-MD5:: login with cleartext user and encrypted password
    #              (see [RFC-2195] for a full description).  This
    #              mechanism requires that the server have the user's
    #              password stored in clear-text password.
    #
    # For both these mechanisms, there should be two +args+: username
    # and (cleartext) password.  A server may not support one or other
    # of these mechanisms; check #capability() for a capability of
    # the form "AUTH=LOGIN" or "AUTH=CRAM-MD5".
    #
    # Authentication is done using the appropriate authenticator object:
    # see @@authenticators for more information on plugging in your own
    # authenticator.
    #
    # For example:
    #
    #    imap.authenticate('LOGIN', user, password)
    #
    # A Net::IMAP::NoResponseError is raised if authentication fails.
    def authenticate(auth_type, *args)
      auth_type = auth_type.upcase
      unless @@authenticators.has_key?(auth_type)
        raise ArgumentError,
          format('unknown auth type - "%s"', auth_type)
      end
      authenticator = @@authenticators[auth_type].new(*args)
      send_command("AUTHENTICATE", auth_type) do |resp|
        if resp.instance_of?(ContinuationRequest)
          data = authenticator.process(resp.data.text.unpack("m")[0])
          s = [data].pack("m").gsub(/\n/, "")
          send_string_data(s)
          put_string(CRLF)
        end
      end
    end

    # Sends a LOGIN command to identify the client and carries
    # the plaintext +password+ authenticating this +user+.  Note
    # that, unlike calling #authenticate() with an +auth_type+
    # of "LOGIN", #login() does *not* use the login authenticator.
    #
    # A Net::IMAP::NoResponseError is raised if authentication fails.
    def login(user, password)
      send_command("LOGIN", user, password)
    end

    # Sends a SELECT command to select a +mailbox+ so that messages
    # in the +mailbox+ can be accessed.
    #
    # After you have selected a mailbox, you may retrieve the
    # number of items in that mailbox from @responses["EXISTS"][-1],
    # and the number of recent messages from @responses["RECENT"][-1].
    # Note that these values can change if new messages arrive
    # during a session; see #add_response_handler() for a way of
    # detecting this event.
    #
    # A Net::IMAP::NoResponseError is raised if the mailbox does not
    # exist or is for some reason non-selectable.
    def select(mailbox)
      synchronize do
        @responses.clear
        send_command("SELECT", mailbox)
      end
    end

    # Sends a EXAMINE command to select a +mailbox+ so that messages
    # in the +mailbox+ can be accessed.  Behaves the same as #select(),
    # except that the selected +mailbox+ is identified as read-only.
    #
    # A Net::IMAP::NoResponseError is raised if the mailbox does not
    # exist or is for some reason non-examinable.
    def examine(mailbox)
      synchronize do
        @responses.clear
        send_command("EXAMINE", mailbox)
      end
    end

    # Sends a CREATE command to create a new +mailbox+.
    #
    # A Net::IMAP::NoResponseError is raised if a mailbox with that name
    # cannot be created.
    def create(mailbox)
      send_command("CREATE", mailbox)
    end

    # Sends a DELETE command to remove the +mailbox+.
    #
    # A Net::IMAP::NoResponseError is raised if a mailbox with that name
    # cannot be deleted, either because it does not exist or because the
    # client does not have permission to delete it.
    def delete(mailbox)
      send_command("DELETE", mailbox)
    end

    # Sends a RENAME command to change the name of the +mailbox+ to
    # +newname+.
    #
    # A Net::IMAP::NoResponseError is raised if a mailbox with the
    # name +mailbox+ cannot be renamed to +newname+ for whatever
    # reason; for instance, because +mailbox+ does not exist, or
    # because there is already a mailbox with the name +newname+.
    def rename(mailbox, newname)
      send_command("RENAME", mailbox, newname)
    end

    # Sends a SUBSCRIBE command to add the specified +mailbox+ name to
    # the server's set of "active" or "subscribed" mailboxes as returned
    # by #lsub().
    #
    # A Net::IMAP::NoResponseError is raised if +mailbox+ cannot be
    # subscribed to, for instance because it does not exist.
    def subscribe(mailbox)
      send_command("SUBSCRIBE", mailbox)
    end

    # Sends a UNSUBSCRIBE command to remove the specified +mailbox+ name
    # from the server's set of "active" or "subscribed" mailboxes.
    #
    # A Net::IMAP::NoResponseError is raised if +mailbox+ cannot be
    # unsubscribed from, for instance because the client is not currently
    # subscribed to it.
    def unsubscribe(mailbox)
      send_command("UNSUBSCRIBE", mailbox)
    end

    # Sends a LIST command, and returns a subset of names from
    # the complete set of all names available to the client.
    # +refname+ provides a context (for instance, a base directory
    # in a directory-based mailbox hierarchy).  +mailbox+ specifies
    # a mailbox or (via wildcards) mailboxes under that context.
    # Two wildcards may be used in +mailbox+: '*', which matches
    # all characters *including* the hierarchy delimiter (for instance,
    # '/' on a UNIX-hosted directory-based mailbox hierarchy); and '%',
    # which matches all characters *except* the hierarchy delimiter.
    #
    # If +refname+ is empty, +mailbox+ is used directly to determine
    # which mailboxes to match.  If +mailbox+ is empty, the root
    # name of +refname+ and the hierarchy delimiter are returned.
    #
    # The return value is an array of +Net::IMAP::MailboxList+. For example:
    #
    #   imap.create("foo/bar")
    #   imap.create("foo/baz")
    #   p imap.list("", "foo/%")
    #   #=> [#<Net::IMAP::MailboxList attr=[:Noselect], delim="/", name="foo/">, \\
    #        #<Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim="/", name="foo/bar">, \\
    #        #<Net::IMAP::MailboxList attr=[:Noinferiors], delim="/", name="foo/baz">]
    def list(refname, mailbox)
      synchronize do
        send_command("LIST", refname, mailbox)
        return @responses.delete("LIST")
      end
    end

    # Sends the GETQUOTAROOT command along with specified +mailbox+.
    # This command is generally available to both admin and user.
    # If mailbox exists, returns an array containing objects of
    # Net::IMAP::MailboxQuotaRoot and Net::IMAP::MailboxQuota.
    def getquotaroot(mailbox)
      synchronize do
        send_command("GETQUOTAROOT", mailbox)
        result = []
        result.concat(@responses.delete("QUOTAROOT"))
        result.concat(@responses.delete("QUOTA"))
        return result
      end
    end

    # Sends the GETQUOTA command along with specified +mailbox+.
    # If this mailbox exists, then an array containing a
    # Net::IMAP::MailboxQuota object is returned.  This
    # command generally is only available to server admin.
    def getquota(mailbox)
      synchronize do
        send_command("GETQUOTA", mailbox)
        return @responses.delete("QUOTA")
      end
    end

    # Sends a SETQUOTA command along with the specified +mailbox+ and
    # +quota+.  If +quota+ is nil, then quota will be unset for that
    # mailbox.  Typically one needs to be logged in as server admin
    # for this to work.  The IMAP quota commands are described in
    # [RFC-2087].
    def setquota(mailbox, quota)
      if quota.nil?
        data = '()'
      else
        data = '(STORAGE ' + quota.to_s + ')'
      end
      send_command("SETQUOTA", mailbox, RawData.new(data))
    end

    # Sends the SETACL command along with +mailbox+, +user+ and the
    # +rights+ that user is to have on that mailbox.  If +rights+ is nil,
    # then that user will be stripped of any rights to that mailbox.
    # The IMAP ACL commands are described in [RFC-2086].
    def setacl(mailbox, user, rights)
      if rights.nil?
        send_command("SETACL", mailbox, user, "")
      else
        send_command("SETACL", mailbox, user, rights)
      end
    end

    # Send the GETACL command along with specified +mailbox+.
    # If this mailbox exists, an array containing objects of
    # Net::IMAP::MailboxACLItem will be returned.
    def getacl(mailbox)
      synchronize do
        send_command("GETACL", mailbox)
        return @responses.delete("ACL")[-1]
      end
    end

    # Sends a LSUB command, and returns a subset of names from the set
    # of names that the user has declared as being "active" or
    # "subscribed".  +refname+ and +mailbox+ are interpreted as
    # for #list().
    # The return value is an array of +Net::IMAP::MailboxList+.
    def lsub(refname, mailbox)
      synchronize do
        send_command("LSUB", refname, mailbox)
        return @responses.delete("LSUB")
      end
    end

    # Sends a STATUS command, and returns the status of the indicated
    # +mailbox+. +attr+ is a list of one or more attributes that
    # we are request the status of.  Supported attributes include:
    #
    #   MESSAGES:: the number of messages in the mailbox.
    #   RECENT:: the number of recent messages in the mailbox.
    #   UNSEEN:: the number of unseen messages in the mailbox.
    #
    # The return value is a hash of attributes. For example:
    #
    #   p imap.status("inbox", ["MESSAGES", "RECENT"])
    #   #=> {"RECENT"=>0, "MESSAGES"=>44}
    #
    # A Net::IMAP::NoResponseError is raised if status values
    # for +mailbox+ cannot be returned, for instance because it
    # does not exist.
    def status(mailbox, attr)
      synchronize do
        send_command("STATUS", mailbox, attr)
        return @responses.delete("STATUS")[-1].attr
      end
    end

    # Sends a APPEND command to append the +message+ to the end of
    # the +mailbox+. The optional +flags+ argument is an array of
    # flags to initially passing to the new message.  The optional
    # +date_time+ argument specifies the creation time to assign to the
    # new message; it defaults to the current time.
    # For example:
    #
    #   imap.append("inbox", <<EOF.gsub(/\n/, "\r\n"), [:Seen], Time.now)
    #   Subject: hello
    #   From: shugo@ruby-lang.org
    #   To: shugo@ruby-lang.org
    #
    #   hello world
    #   EOF
    #
    # A Net::IMAP::NoResponseError is raised if the mailbox does
    # not exist (it is not created automatically), or if the flags,
    # date_time, or message arguments contain errors.
    def append(mailbox, message, flags = nil, date_time = nil)
      args = []
      if flags
        args.push(flags)
      end
      args.push(date_time) if date_time
      args.push(Literal.new(message))
      send_command("APPEND", mailbox, *args)
    end

    # Sends a CHECK command to request a checkpoint of the currently
    # selected mailbox.  This performs implementation-specific
    # housekeeping, for instance, reconciling the mailbox's
    # in-memory and on-disk state.
    def check
      send_command("CHECK")
    end

    # Sends a CLOSE command to close the currently selected mailbox.
    # The CLOSE command permanently removes from the mailbox all
    # messages that have the \Deleted flag set.
    def close
      send_command("CLOSE")
    end

    # Sends a EXPUNGE command to permanently remove from the currently
    # selected mailbox all messages that have the \Deleted flag set.
    def expunge
      synchronize do
        send_command("EXPUNGE")
        return @responses.delete("EXPUNGE")
      end
    end

    # Sends a SEARCH command to search the mailbox for messages that
    # match the given searching criteria, and returns message sequence
    # numbers.  +keys+ can either be a string holding the entire
    # search string, or a single-dimension array of search keywords and
    # arguments.  The following are some common search criteria;
    # see [IMAP] section 6.4.4 for a full list.
    #
    # <message set>:: a set of message sequence numbers.  ',' indicates
    #                 an interval, ':' indicates a range.  For instance,
    #                 '2,10:12,15' means "2,10,11,12,15".
    #
    # BEFORE <date>:: messages with an internal date strictly before
    #                 <date>.  The date argument has a format similar
    #                 to 8-Aug-2002.
    #
    # BODY <string>:: messages that contain <string> within their body.
    #
    # CC <string>:: messages containing <string> in their CC field.
    #
    # FROM <string>:: messages that contain <string> in their FROM field.
    #
    # NEW:: messages with the \Recent, but not the \Seen, flag set.
    #
    # NOT <search-key>:: negate the following search key.
    #
    # OR <search-key> <search-key>:: "or" two search keys together.
    #
    # ON <date>:: messages with an internal date exactly equal to <date>,
    #             which has a format similar to 8-Aug-2002.
    #
    # SINCE <date>:: messages with an internal date on or after <date>.
    #
    # SUBJECT <string>:: messages with <string> in their subject.
    #
    # TO <string>:: messages with <string> in their TO field.
    #
    # For example:
    #
    #   p imap.search(["SUBJECT", "hello", "NOT", "NEW"])
    #   #=> [1, 6, 7, 8]
    def search(keys, charset = nil)
      return search_internal("SEARCH", keys, charset)
    end

    # As for #search(), but returns unique identifiers.
    def uid_search(keys, charset = nil)
      return search_internal("UID SEARCH", keys, charset)
    end

    # Sends a FETCH command to retrieve data associated with a message
    # in the mailbox. The +set+ parameter is a number or an array of
    # numbers or a Range object. The number is a message sequence
    # number.  +attr+ is a list of attributes to fetch; see the
    # documentation for Net::IMAP::FetchData for a list of valid
    # attributes.
    # The return value is an array of Net::IMAP::FetchData. For example:
    #
    #   p imap.fetch(6..8, "UID")
    #   #=> [#<Net::IMAP::FetchData seqno=6, attr={"UID"=>98}>, \\
    #        #<Net::IMAP::FetchData seqno=7, attr={"UID"=>99}>, \\
    #        #<Net::IMAP::FetchData seqno=8, attr={"UID"=>100}>]
    #   p imap.fetch(6, "BODY[HEADER.FIELDS (SUBJECT)]")
    #   #=> [#<Net::IMAP::FetchData seqno=6, attr={"BODY[HEADER.FIELDS (SUBJECT)]"=>"Subject: test\r\n\r\n"}>]
    #   data = imap.uid_fetch(98, ["RFC822.SIZE", "INTERNALDATE"])[0]
    #   p data.seqno
    #   #=> 6
    #   p data.attr["RFC822.SIZE"]
    #   #=> 611
    #   p data.attr["INTERNALDATE"]
    #   #=> "12-Oct-2000 22:40:59 +0900"
    #   p data.attr["UID"]
    #   #=> 98
    def fetch(set, attr)
      return fetch_internal("FETCH", set, attr)
    end

    # As for #fetch(), but +set+ contains unique identifiers.
    def uid_fetch(set, attr)
      return fetch_internal("UID FETCH", set, attr)
    end

    # Sends a STORE command to alter data associated with messages
    # in the mailbox, in particular their flags. The +set+ parameter
    # is a number or an array of numbers or a Range object. Each number
    # is a message sequence number.  +attr+ is the name of a data item
    # to store: 'FLAGS' means to replace the message's flag list
    # with the provided one; '+FLAGS' means to add the provided flags;
    # and '-FLAGS' means to remove them.  +flags+ is a list of flags.
    #
    # The return value is an array of Net::IMAP::FetchData. For example:
    #
    #   p imap.store(6..8, "+FLAGS", [:Deleted])
    #   #=> [#<Net::IMAP::FetchData seqno=6, attr={"FLAGS"=>[:Seen, :Deleted]}>, \\
    #        #<Net::IMAP::FetchData seqno=7, attr={"FLAGS"=>[:Seen, :Deleted]}>, \\
    #        #<Net::IMAP::FetchData seqno=8, attr={"FLAGS"=>[:Seen, :Deleted]}>]
    def store(set, attr, flags)
      return store_internal("STORE", set, attr, flags)
    end

    # As for #store(), but +set+ contains unique identifiers.
    def uid_store(set, attr, flags)
      return store_internal("UID STORE", set, attr, flags)
    end

    # Sends a COPY command to copy the specified message(s) to the end
    # of the specified destination +mailbox+. The +set+ parameter is
    # a number or an array of numbers or a Range object. The number is
    # a message sequence number.
    def copy(set, mailbox)
      copy_internal("COPY", set, mailbox)
    end

    # As for #copy(), but +set+ contains unique identifiers.
    def uid_copy(set, mailbox)
      copy_internal("UID COPY", set, mailbox)
    end

    # Sends a SORT command to sort messages in the mailbox.
    # Returns an array of message sequence numbers. For example:
    #
    #   p imap.sort(["FROM"], ["ALL"], "US-ASCII")
    #   #=> [1, 2, 3, 5, 6, 7, 8, 4, 9]
    #   p imap.sort(["DATE"], ["SUBJECT", "hello"], "US-ASCII")
    #   #=> [6, 7, 8, 1]
    #
    # See [SORT-THREAD-EXT] for more details.
    def sort(sort_keys, search_keys, charset)
      return sort_internal("SORT", sort_keys, search_keys, charset)
    end

    # As for #sort(), but returns an array of unique identifiers.
    def uid_sort(sort_keys, search_keys, charset)
      return sort_internal("UID SORT", sort_keys, search_keys, charset)
    end

    # Adds a response handler. For example, to detect when
    # the server sends us a new EXISTS response (which normally
    # indicates new messages being added to the mail box),
    # you could add the following handler after selecting the
    # mailbox.
    #
    #   imap.add_response_handler { |resp|
    #     if resp.kind_of?(Net::IMAP::UntaggedResponse) and resp.name == "EXISTS"
    #       puts "Mailbox now has #{resp.data} messages"
    #     end
    #   }
    #
    def add_response_handler(handler = Proc.new)
      @response_handlers.push(handler)
    end

    # Removes the response handler.
    def remove_response_handler(handler)
      @response_handlers.delete(handler)
    end

    # As for #search(), but returns message sequence numbers in threaded
    # format, as a Net::IMAP::ThreadMember tree.  The supported algorithms
    # are:
    #
    # ORDEREDSUBJECT:: split into single-level threads according to subject,
    #                  ordered by date.
    # REFERENCES:: split into threads by parent/child relationships determined
    #              by which message is a reply to which.
    #
    # Unlike #search(), +charset+ is a required argument.  US-ASCII
    # and UTF-8 are sample values.
    #
    # See [SORT-THREAD-EXT] for more details.
    def thread(algorithm, search_keys, charset)
      return thread_internal("THREAD", algorithm, search_keys, charset)
    end

    # As for #thread(), but returns unique identifiers instead of
    # message sequence numbers.
    def uid_thread(algorithm, search_keys, charset)
      return thread_internal("UID THREAD", algorithm, search_keys, charset)
    end

    # Sends an IDLE command that waits for notifications of new or expunged
    # messages.  Yields responses from the server during the IDLE.
    #
    # Use #idle_done() to leave IDLE.
    def idle(&response_handler)
      raise LocalJumpError, "no block given" unless response_handler

      response = nil

      synchronize do
        tag = Thread.current[:net_imap_tag] = generate_tag
        put_string("#{tag} IDLE#{CRLF}")

        begin
          add_response_handler(response_handler)
          @idle_done_cond = new_cond
          @idle_done_cond.wait
          @idle_done_cond = nil
        ensure
          remove_response_handler(response_handler)
          put_string("DONE#{CRLF}")
          response = get_tagged_response(tag, "IDLE")
        end
      end

      return response
    end

    # Leaves IDLE.
    def idle_done
      synchronize do
        if @idle_done_cond.nil?
          raise Net::IMAP::Error, "not during IDLE"
        end
        @idle_done_cond.signal
      end
    end

    # Decode a string from modified UTF-7 format to UTF-8.
    #
    # UTF-7 is a 7-bit encoding of Unicode [UTF7].  IMAP uses a
    # slightly modified version of this to encode mailbox names
    # containing non-ASCII characters; see [IMAP] section 5.1.3.
    #
    # Net::IMAP does _not_ automatically encode and decode
    # mailbox names to and from utf7.
    def self.decode_utf7(s)
      return s.gsub(/&(.*?)-/n) {
        if $1.empty?
          "&"
        else
          base64 = $1.tr(",", "/")
          x = base64.length % 4
          if x > 0
            base64.concat("=" * (4 - x))
          end
          base64.unpack("m")[0].unpack("n*").pack("U*")
        end
      }.force_encoding("UTF-8")
    end

    # Encode a string from UTF-8 format to modified UTF-7.
    def self.encode_utf7(s)
      return s.gsub(/(&)|([^\x20-\x7e]+)/u) {
        if $1
          "&-"
        else
          base64 = [$&.unpack("U*").pack("n*")].pack("m")
          "&" + base64.delete("=\n").tr("/", ",") + "-"
        end
      }.force_encoding("ASCII-8BIT")
    end

    # Formats +time+ as an IMAP-style date.
    def self.format_date(time)
      return time.strftime('%d-%b-%Y')
    end

    # Formats +time+ as an IMAP-style date-time.
    def self.format_datetime(time)
      return time.strftime('%d-%b-%Y %H:%M %z')
    end

    private

    CRLF = "\r\n"      # :nodoc:
    PORT = 143         # :nodoc:
    SSL_PORT = 993   # :nodoc:

    @@debug = false
    @@authenticators = {}
    @@max_flag_count = 10000

    # call-seq:
    #    Net::IMAP.new(host, options = {})
    #
    # Creates a new Net::IMAP object and connects it to the specified
    # +host+.
    #
    # +options+ is an option hash, each key of which is a symbol.
    #
    # The available options are:
    #
    # port::  port number (default value is 143 for imap, or 993 for imaps)
    # ssl::   if options[:ssl] is true, then an attempt will be made
    #         to use SSL (now TLS) to connect to the server.  For this to work
    #         OpenSSL [OSSL] and the Ruby OpenSSL [RSSL] extensions need to
    #         be installed.
    #         if options[:ssl] is a hash, it's passed to
    #         OpenSSL::SSL::SSLContext#set_params as parameters.
    #
    # The most common errors are:
    #
    # Errno::ECONNREFUSED:: connection refused by +host+ or an intervening
    #                       firewall.
    # Errno::ETIMEDOUT:: connection timed out (possibly due to packets
    #                    being dropped by an intervening firewall).
    # Errno::ENETUNREACH:: there is no route to that network.
    # SocketError:: hostname not known or other socket error.
    # Net::IMAP::ByeResponseError:: we connected to the host, but they
    #                               immediately said goodbye to us.
    def initialize(host, port_or_options = {},
                   usessl = false, certs = nil, verify = true)
      super()
      @host = host
      begin
        options = port_or_options.to_hash
      rescue NoMethodError
        # for backward compatibility
        options = {}
        options[:port] = port_or_options
        if usessl
          options[:ssl] = create_ssl_params(certs, verify)
        end
      end
      @port = options[:port] || (options[:ssl] ? SSL_PORT : PORT)
      @tag_prefix = "RUBY"
      @tagno = 0
      @parser = ResponseParser.new
      @sock = TCPSocket.open(@host, @port)
      if options[:ssl]
        start_tls_session(options[:ssl])
        @usessl = true
      else
        @usessl = false
      end
      @responses = Hash.new([].freeze)
      @tagged_responses = {}
      @response_handlers = []
      @tagged_response_arrival = new_cond
      @continuation_request_arrival = new_cond
      @idle_done_cond = nil
      @logout_command_tag = nil
      @debug_output_bol = true
      @exception = nil

      @greeting = get_response
      if @greeting.name == "BYE"
        @sock.close
        raise ByeResponseError, @greeting
      end

      @client_thread = Thread.current
      @receiver_thread = Thread.start {
        begin
          receive_responses
        rescue Exception
        end
      }
    end

    def receive_responses
      connection_closed = false
      until connection_closed
        synchronize do
          @exception = nil
        end
        begin
          resp = get_response
        rescue Exception => e
          synchronize do
            @sock.close
            @exception = e
          end
          break
        end
        unless resp
          synchronize do
            @exception = EOFError.new("end of file reached")
          end
          break
        end
        begin
          synchronize do
            case resp
            when TaggedResponse
              @tagged_responses[resp.tag] = resp
              @tagged_response_arrival.broadcast
              if resp.tag == @logout_command_tag
                return
              end
            when UntaggedResponse
              record_response(resp.name, resp.data)
              if resp.data.instance_of?(ResponseText) &&
                  (code = resp.data.code)
                record_response(code.name, code.data)
              end
              if resp.name == "BYE" && @logout_command_tag.nil?
                @sock.close
                @exception = ByeResponseError.new(resp)
                connection_closed = true
              end
            when ContinuationRequest
              @continuation_request_arrival.signal
            end
            @response_handlers.each do |handler|
              handler.call(resp)
            end
          end
        rescue Exception => e
          @exception = e
          synchronize do
            @tagged_response_arrival.broadcast
            @continuation_request_arrival.broadcast
          end
        end
      end
      synchronize do
        @tagged_response_arrival.broadcast
        @continuation_request_arrival.broadcast
      end
    end

    def get_tagged_response(tag, cmd)
      until @tagged_responses.key?(tag)
        raise @exception if @exception
        @tagged_response_arrival.wait
      end
      resp = @tagged_responses.delete(tag)
      case resp.name
      when /\A(?:NO)\z/ni
        raise NoResponseError, resp
      when /\A(?:BAD)\z/ni
        raise BadResponseError, resp
      else
        return resp
      end
    end

    def get_response
      buff = ""
      while true
        s = @sock.gets(CRLF)
        break unless s
        buff.concat(s)
        if /\{(\d+)\}\r\n/n =~ s
          s = @sock.read($1.to_i)
          buff.concat(s)
        else
          break
        end
      end
      return nil if buff.length == 0
      if @@debug
        $stderr.print(buff.gsub(/^/n, "S: "))
      end
      return @parser.parse(buff)
    end

    def record_response(name, data)
      unless @responses.has_key?(name)
        @responses[name] = []
      end
      @responses[name].push(data)
    end

    def send_command(cmd, *args, &block)
      synchronize do
        args.each do |i|
          validate_data(i)
        end
        tag = generate_tag
        put_string(tag + " " + cmd)
        args.each do |i|
          put_string(" ")
          send_data(i)
        end
        put_string(CRLF)
        if cmd == "LOGOUT"
          @logout_command_tag = tag
        end
        if block
          add_response_handler(block)
        end
        begin
          return get_tagged_response(tag, cmd)
        ensure
          if block
            remove_response_handler(block)
          end
        end
      end
    end

    def generate_tag
      @tagno += 1
      return format("%s%04d", @tag_prefix, @tagno)
    end

    def put_string(str)
      @sock.print(str)
      if @@debug
        if @debug_output_bol
          $stderr.print("C: ")
        end
        $stderr.print(str.gsub(/\n(?!\z)/n, "\nC: "))
        if /\r\n\z/n.match(str)
          @debug_output_bol = true
        else
          @debug_output_bol = false
        end
      end
    end

    def validate_data(data)
      case data
      when nil
      when String
      when Integer
        if data < 0 || data >= 4294967296
          raise DataFormatError, num.to_s
        end
      when Array
        data.each do |i|
          validate_data(i)
        end
      when Time
      when Symbol
      else
        data.validate
      end
    end

    def send_data(data)
      case data
      when nil
        put_string("NIL")
      when String
        send_string_data(data)
      when Integer
        send_number_data(data)
      when Array
        send_list_data(data)
      when Time
        send_time_data(data)
      when Symbol
        send_symbol_data(data)
      else
        data.send_data(self)
      end
    end

    def send_string_data(str)
      case str
      when ""
        put_string('""')
      when /[\x80-\xff\r\n]/n
        # literal
        send_literal(str)
      when /[(){ \x00-\x1f\x7f%*"\\]/n
        # quoted string
        send_quoted_string(str)
      else
        put_string(str)
      end
    end

    def send_quoted_string(str)
      put_string('"' + str.gsub(/["\\]/n, "\\\\\\&") + '"')
    end

    def send_literal(str)
      put_string("{" + str.length.to_s + "}" + CRLF)
      @continuation_request_arrival.wait
      raise @exception if @exception
      put_string(str)
    end

    def send_number_data(num)
      put_string(num.to_s)
    end

    def send_list_data(list)
      put_string("(")
      first = true
      list.each do |i|
        if first
          first = false
        else
          put_string(" ")
        end
        send_data(i)
      end
      put_string(")")
    end

    DATE_MONTH = %w(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)

    def send_time_data(time)
      t = time.dup.gmtime
      s = format('"%2d-%3s-%4d %02d:%02d:%02d +0000"',
                 t.day, DATE_MONTH[t.month - 1], t.year,
                 t.hour, t.min, t.sec)
      put_string(s)
    end

    def send_symbol_data(symbol)
      put_string("\\" + symbol.to_s)
    end

    def search_internal(cmd, keys, charset)
      if keys.instance_of?(String)
        keys = [RawData.new(keys)]
      else
        normalize_searching_criteria(keys)
      end
      synchronize do
        if charset
          send_command(cmd, "CHARSET", charset, *keys)
        else
          send_command(cmd, *keys)
        end
        return @responses.delete("SEARCH")[-1]
      end
    end

    def fetch_internal(cmd, set, attr)
      case attr
      when String then
        attr = RawData.new(attr)
      when Array then
        attr = attr.map { |arg|
          arg.is_a?(String) ? RawData.new(arg) : arg
        }
      end

      synchronize do
        @responses.delete("FETCH")
        send_command(cmd, MessageSet.new(set), attr)
        return @responses.delete("FETCH")
      end
    end

    def store_internal(cmd, set, attr, flags)
      if attr.instance_of?(String)
        attr = RawData.new(attr)
      end
      synchronize do
        @responses.delete("FETCH")
        send_command(cmd, MessageSet.new(set), attr, flags)
        return @responses.delete("FETCH")
      end
    end

    def copy_internal(cmd, set, mailbox)
      send_command(cmd, MessageSet.new(set), mailbox)
    end

    def sort_internal(cmd, sort_keys, search_keys, charset)
      if search_keys.instance_of?(String)
        search_keys = [RawData.new(search_keys)]
      else
        normalize_searching_criteria(search_keys)
      end
      normalize_searching_criteria(search_keys)
      synchronize do
        send_command(cmd, sort_keys, charset, *search_keys)
        return @responses.delete("SORT")[-1]
      end
    end

    def thread_internal(cmd, algorithm, search_keys, charset)
      if search_keys.instance_of?(String)
        search_keys = [RawData.new(search_keys)]
      else
        normalize_searching_criteria(search_keys)
      end
      normalize_searching_criteria(search_keys)
      send_command(cmd, algorithm, charset, *search_keys)
      return @responses.delete("THREAD")[-1]
    end

    def normalize_searching_criteria(keys)
      keys.collect! do |i|
        case i
        when -1, Range, Array
          MessageSet.new(i)
        else
          i
        end
      end
    end

    def create_ssl_params(certs = nil, verify = true)
      params = {}
      if certs
        if File.file?(certs)
          params[:ca_file] = certs
        elsif File.directory?(certs)
          params[:ca_path] = certs
        end
      end
      if verify
        params[:verify_mode] = VERIFY_PEER
      else
        params[:verify_mode] = VERIFY_NONE
      end
      return params
    end

    def start_tls_session(params = {})
      unless defined?(OpenSSL)
        raise "SSL extension not installed"
      end
      if @sock.kind_of?(OpenSSL::SSL::SSLSocket)
        raise RuntimeError, "already using SSL"
      end
      begin
        params = params.to_hash
      rescue NoMethodError
        params = {}
      end
      context = SSLContext.new
      context.set_params(params)
      if defined?(VerifyCallbackProc)
        context.verify_callback = VerifyCallbackProc
      end
      @sock = SSLSocket.new(@sock, context)
      @sock.sync_close = true
      @sock.connect
      if context.verify_mode != VERIFY_NONE
        @sock.post_connection_check(@host)
      end
    end

    class RawData # :nodoc:
      def send_data(imap)
        imap.send(:put_string, @data)
      end

      def validate
      end

      private

      def initialize(data)
        @data = data
      end
    end

    class Atom # :nodoc:
      def send_data(imap)
        imap.send(:put_string, @data)
      end

      def validate
      end

      private

      def initialize(data)
        @data = data
      end
    end

    class QuotedString # :nodoc:
      def send_data(imap)
        imap.send(:send_quoted_string, @data)
      end

      def validate
      end

      private

      def initialize(data)
        @data = data
      end
    end

    class Literal # :nodoc:
      def send_data(imap)
        imap.send(:send_literal, @data)
      end

      def validate
      end

      private

      def initialize(data)
        @data = data
      end
    end

    class MessageSet # :nodoc:
      def send_data(imap)
        imap.send(:put_string, format_internal(@data))
      end

      def validate
        validate_internal(@data)
      end

      private

      def initialize(data)
        @data = data
      end

      def format_internal(data)
        case data
        when "*"
          return data
        when Integer
          if data == -1
            return "*"
          else
            return data.to_s
          end
        when Range
          return format_internal(data.first) +
            ":" + format_internal(data.last)
        when Array
          return data.collect {|i| format_internal(i)}.join(",")
        when ThreadMember
          return data.seqno.to_s +
            ":" + data.children.collect {|i| format_internal(i).join(",")}
        end
      end

      def validate_internal(data)
        case data
        when "*"
        when Integer
          ensure_nz_number(data)
        when Range
        when Array
          data.each do |i|
            validate_internal(i)
          end
        when ThreadMember
          data.children.each do |i|
            validate_internal(i)
          end
        else
          raise DataFormatError, data.inspect
        end
      end

      def ensure_nz_number(num)
        if num < -1 || num == 0 || num >= 4294967296
          msg = "nz_number must be non-zero unsigned 32-bit integer: " +
                num.inspect
          raise DataFormatError, msg
        end
      end
    end

    # Net::IMAP::ContinuationRequest represents command continuation requests.
    #
    # The command continuation request response is indicated by a "+" token
    # instead of a tag.  This form of response indicates that the server is
    # ready to accept the continuation of a command from the client.  The
    # remainder of this response is a line of text.
    #
    #   continue_req    ::= "+" SPACE (resp_text / base64)
    #
    # ==== Fields:
    #
    # data:: Returns the data (Net::IMAP::ResponseText).
    #
    # raw_data:: Returns the raw data string.
    ContinuationRequest = Struct.new(:data, :raw_data)

    # Net::IMAP::UntaggedResponse represents untagged responses.
    #
    # Data transmitted by the server to the client and status responses
    # that do not indicate command completion are prefixed with the token
    # "*", and are called untagged responses.
    #
    #   response_data   ::= "*" SPACE (resp_cond_state / resp_cond_bye /
    #                       mailbox_data / message_data / capability_data)
    #
    # ==== Fields:
    #
    # name:: Returns the name such as "FLAGS", "LIST", "FETCH"....
    #
    # data:: Returns the data such as an array of flag symbols,
    #         a ((<Net::IMAP::MailboxList>)) object....
    #
    # raw_data:: Returns the raw data string.
    UntaggedResponse = Struct.new(:name, :data, :raw_data)

    # Net::IMAP::TaggedResponse represents tagged responses.
    #
    # The server completion result response indicates the success or
    # failure of the operation.  It is tagged with the same tag as the
    # client command which began the operation.
    #
    #   response_tagged ::= tag SPACE resp_cond_state CRLF
    #
    #   tag             ::= 1*<any ATOM_CHAR except "+">
    #
    #   resp_cond_state ::= ("OK" / "NO" / "BAD") SPACE resp_text
    #
    # ==== Fields:
    #
    # tag:: Returns the tag.
    #
    # name:: Returns the name. the name is one of "OK", "NO", "BAD".
    #
    # data:: Returns the data. See ((<Net::IMAP::ResponseText>)).
    #
    # raw_data:: Returns the raw data string.
    #
    TaggedResponse = Struct.new(:tag, :name, :data, :raw_data)

    # Net::IMAP::ResponseText represents texts of responses.
    # The text may be prefixed by the response code.
    #
    #   resp_text       ::= ["[" resp_text_code "]" SPACE] (text_mime2 / text)
    #                       ;; text SHOULD NOT begin with "[" or "="
    #
    # ==== Fields:
    #
    # code:: Returns the response code. See ((<Net::IMAP::ResponseCode>)).
    #
    # text:: Returns the text.
    #
    ResponseText = Struct.new(:code, :text)

    #
    # Net::IMAP::ResponseCode represents response codes.
    #
    #   resp_text_code  ::= "ALERT" / "PARSE" /
    #                       "PERMANENTFLAGS" SPACE "(" #(flag / "\*") ")" /
    #                       "READ-ONLY" / "READ-WRITE" / "TRYCREATE" /
    #                       "UIDVALIDITY" SPACE nz_number /
    #                       "UNSEEN" SPACE nz_number /
    #                       atom [SPACE 1*<any TEXT_CHAR except "]">]
    #
    # ==== Fields:
    #
    # name:: Returns the name such as "ALERT", "PERMANENTFLAGS", "UIDVALIDITY"....
    #
    # data:: Returns the data if it exists.
    #
    ResponseCode = Struct.new(:name, :data)

    # Net::IMAP::MailboxList represents contents of the LIST response.
    #
    #   mailbox_list    ::= "(" #("\Marked" / "\Noinferiors" /
    #                       "\Noselect" / "\Unmarked" / flag_extension) ")"
    #                       SPACE (<"> QUOTED_CHAR <"> / nil) SPACE mailbox
    #
    # ==== Fields:
    #
    # attr:: Returns the name attributes. Each name attribute is a symbol
    #        capitalized by String#capitalize, such as :Noselect (not :NoSelect).
    #
    # delim:: Returns the hierarchy delimiter
    #
    # name:: Returns the mailbox name.
    #
    MailboxList = Struct.new(:attr, :delim, :name)

    # Net::IMAP::MailboxQuota represents contents of GETQUOTA response.
    # This object can also be a response to GETQUOTAROOT.  In the syntax
    # specification below, the delimiter used with the "#" construct is a
    # single space (SPACE).
    #
    #    quota_list      ::= "(" #quota_resource ")"
    #
    #    quota_resource  ::= atom SPACE number SPACE number
    #
    #    quota_response  ::= "QUOTA" SPACE astring SPACE quota_list
    #
    # ==== Fields:
    #
    # mailbox:: The mailbox with the associated quota.
    #
    # usage:: Current storage usage of mailbox.
    #
    # quota:: Quota limit imposed on mailbox.
    #
    MailboxQuota = Struct.new(:mailbox, :usage, :quota)

    # Net::IMAP::MailboxQuotaRoot represents part of the GETQUOTAROOT
    # response. (GETQUOTAROOT can also return Net::IMAP::MailboxQuota.)
    #
    #    quotaroot_response ::= "QUOTAROOT" SPACE astring *(SPACE astring)
    #
    # ==== Fields:
    #
    # mailbox:: The mailbox with the associated quota.
    #
    # quotaroots:: Zero or more quotaroots that effect the quota on the
    #              specified mailbox.
    #
    MailboxQuotaRoot = Struct.new(:mailbox, :quotaroots)

    # Net::IMAP::MailboxACLItem represents response from GETACL.
    #
    #    acl_data        ::= "ACL" SPACE mailbox *(SPACE identifier SPACE rights)
    #
    #    identifier      ::= astring
    #
    #    rights          ::= astring
    #
    # ==== Fields:
    #
    # user:: Login name that has certain rights to the mailbox
    #        that was specified with the getacl command.
    #
    # rights:: The access rights the indicated user has to the
    #          mailbox.
    #
    MailboxACLItem = Struct.new(:user, :rights)

    # Net::IMAP::StatusData represents contents of the STATUS response.
    #
    # ==== Fields:
    #
    # mailbox:: Returns the mailbox name.
    #
    # attr:: Returns a hash. Each key is one of "MESSAGES", "RECENT", "UIDNEXT",
    #        "UIDVALIDITY", "UNSEEN". Each value is a number.
    #
    StatusData = Struct.new(:mailbox, :attr)

    # Net::IMAP::FetchData represents contents of the FETCH response.
    #
    # ==== Fields:
    #
    # seqno:: Returns the message sequence number.
    #         (Note: not the unique identifier, even for the UID command response.)
    #
    # attr:: Returns a hash. Each key is a data item name, and each value is
    #        its value.
    #
    #        The current data items are:
    #
    #        [BODY]
    #           A form of BODYSTRUCTURE without extension data.
    #        [BODY[<section>]<<origin_octet>>]
    #           A string expressing the body contents of the specified section.
    #        [BODYSTRUCTURE]
    #           An object that describes the [MIME-IMB] body structure of a message.
    #           See Net::IMAP::BodyTypeBasic, Net::IMAP::BodyTypeText,
    #           Net::IMAP::BodyTypeMessage, Net::IMAP::BodyTypeMultipart.
    #        [ENVELOPE]
    #           A Net::IMAP::Envelope object that describes the envelope
    #           structure of a message.
    #        [FLAGS]
    #           A array of flag symbols that are set for this message. flag symbols
    #           are capitalized by String#capitalize.
    #        [INTERNALDATE]
    #           A string representing the internal date of the message.
    #        [RFC822]
    #           Equivalent to BODY[].
    #        [RFC822.HEADER]
    #           Equivalent to BODY.PEEK[HEADER].
    #        [RFC822.SIZE]
    #           A number expressing the [RFC-822] size of the message.
    #        [RFC822.TEXT]
    #           Equivalent to BODY[TEXT].
    #        [UID]
    #           A number expressing the unique identifier of the message.
    #
    FetchData = Struct.new(:seqno, :attr)

    # Net::IMAP::Envelope represents envelope structures of messages.
    #
    # ==== Fields:
    #
    # date:: Returns a string that represents the date.
    #
    # subject:: Returns a string that represents the subject.
    #
    # from:: Returns an array of Net::IMAP::Address that represents the from.
    #
    # sender:: Returns an array of Net::IMAP::Address that represents the sender.
    #
    # reply_to:: Returns an array of Net::IMAP::Address that represents the reply-to.
    #
    # to:: Returns an array of Net::IMAP::Address that represents the to.
    #
    # cc:: Returns an array of Net::IMAP::Address that represents the cc.
    #
    # bcc:: Returns an array of Net::IMAP::Address that represents the bcc.
    #
    # in_reply_to:: Returns a string that represents the in-reply-to.
    #
    # message_id:: Returns a string that represents the message-id.
    #
    Envelope = Struct.new(:date, :subject, :from, :sender, :reply_to,
                          :to, :cc, :bcc, :in_reply_to, :message_id)

    #
    # Net::IMAP::Address represents electronic mail addresses.
    #
    # ==== Fields:
    #
    # name:: Returns the phrase from [RFC-822] mailbox.
    #
    # route:: Returns the route from [RFC-822] route-addr.
    #
    # mailbox:: nil indicates end of [RFC-822] group.
    #           If non-nil and host is nil, returns [RFC-822] group name.
    #           Otherwise, returns [RFC-822] local-part
    #
    # host:: nil indicates [RFC-822] group syntax.
    #        Otherwise, returns [RFC-822] domain name.
    #
    Address = Struct.new(:name, :route, :mailbox, :host)

    #
    # Net::IMAP::ContentDisposition represents Content-Disposition fields.
    #
    # ==== Fields:
    #
    # dsp_type:: Returns the disposition type.
    #
    # param:: Returns a hash that represents parameters of the Content-Disposition
    #         field.
    #
    ContentDisposition = Struct.new(:dsp_type, :param)

    # Net::IMAP::ThreadMember represents a thread-node returned
    # by Net::IMAP#thread
    #
    # ==== Fields:
    #
    # seqno:: The sequence number of this message.
    #
    # children:: an array of Net::IMAP::ThreadMember objects for mail
    # items that are children of this in the thread.
    #
    ThreadMember = Struct.new(:seqno, :children)

    # Net::IMAP::BodyTypeBasic represents basic body structures of messages.
    #
    # ==== Fields:
    #
    # media_type:: Returns the content media type name as defined in [MIME-IMB].
    #
    # subtype:: Returns the content subtype name as defined in [MIME-IMB].
    #
    # param:: Returns a hash that represents parameters as defined in [MIME-IMB].
    #
    # content_id:: Returns a string giving the content id as defined in [MIME-IMB].
    #
    # description:: Returns a string giving the content description as defined in
    #               [MIME-IMB].
    #
    # encoding:: Returns a string giving the content transfer encoding as defined in
    #            [MIME-IMB].
    #
    # size:: Returns a number giving the size of the body in octets.
    #
    # md5:: Returns a string giving the body MD5 value as defined in [MD5].
    #
    # disposition:: Returns a Net::IMAP::ContentDisposition object giving
    #               the content disposition.
    #
    # language:: Returns a string or an array of strings giving the body
    #            language value as defined in [LANGUAGE-TAGS].
    #
    # extension:: Returns extension data.
    #
    # multipart?:: Returns false.
    #
    class BodyTypeBasic < Struct.new(:media_type, :subtype,
                                     :param, :content_id,
                                     :description, :encoding, :size,
                                     :md5, :disposition, :language,
                                     :extension)
      def multipart?
        return false
      end

      # Obsolete: use +subtype+ instead.  Calling this will
      # generate a warning message to +stderr+, then return
      # the value of +subtype+.
      def media_subtype
        $stderr.printf("warning: media_subtype is obsolete.\n")
        $stderr.printf("         use subtype instead.\n")
        return subtype
      end
    end

    # Net::IMAP::BodyTypeText represents TEXT body structures of messages.
    #
    # ==== Fields:
    #
    # lines:: Returns the size of the body in text lines.
    #
    # And Net::IMAP::BodyTypeText has all fields of Net::IMAP::BodyTypeBasic.
    #
    class BodyTypeText < Struct.new(:media_type, :subtype,
                                    :param, :content_id,
                                    :description, :encoding, :size,
                                    :lines,
                                    :md5, :disposition, :language,
                                    :extension)
      def multipart?
        return false
      end

      # Obsolete: use +subtype+ instead.  Calling this will
      # generate a warning message to +stderr+, then return
      # the value of +subtype+.
      def media_subtype
        $stderr.printf("warning: media_subtype is obsolete.\n")
        $stderr.printf("         use subtype instead.\n")
        return subtype
      end
    end

    # Net::IMAP::BodyTypeMessage represents MESSAGE/RFC822 body structures of messages.
    #
    # ==== Fields:
    #
    # envelope:: Returns a Net::IMAP::Envelope giving the envelope structure.
    #
    # body:: Returns an object giving the body structure.
    #
    # And Net::IMAP::BodyTypeMessage has all methods of Net::IMAP::BodyTypeText.
    #
    class BodyTypeMessage < Struct.new(:media_type, :subtype,
                                       :param, :content_id,
                                       :description, :encoding, :size,
                                       :envelope, :body, :lines,
                                       :md5, :disposition, :language,
                                       :extension)
      def multipart?
        return false
      end

      # Obsolete: use +subtype+ instead.  Calling this will
      # generate a warning message to +stderr+, then return
      # the value of +subtype+.
      def media_subtype
        $stderr.printf("warning: media_subtype is obsolete.\n")
        $stderr.printf("         use subtype instead.\n")
        return subtype
      end
    end

    # Net::IMAP::BodyTypeMultipart represents multipart body structures
    # of messages.
    #
    # ==== Fields:
    #
    # media_type:: Returns the content media type name as defined in [MIME-IMB].
    #
    # subtype:: Returns the content subtype name as defined in [MIME-IMB].
    #
    # parts:: Returns multiple parts.
    #
    # param:: Returns a hash that represents parameters as defined in [MIME-IMB].
    #
    # disposition:: Returns a Net::IMAP::ContentDisposition object giving
    #               the content disposition.
    #
    # language:: Returns a string or an array of strings giving the body
    #            language value as defined in [LANGUAGE-TAGS].
    #
    # extension:: Returns extension data.
    #
    # multipart?:: Returns true.
    #
    class BodyTypeMultipart < Struct.new(:media_type, :subtype,
                                         :parts,
                                         :param, :disposition, :language,
                                         :extension)
      def multipart?
        return true
      end

      # Obsolete: use +subtype+ instead.  Calling this will
      # generate a warning message to +stderr+, then return
      # the value of +subtype+.
      def media_subtype
        $stderr.printf("warning: media_subtype is obsolete.\n")
        $stderr.printf("         use subtype instead.\n")
        return subtype
      end
    end

    class ResponseParser # :nodoc:
      def initialize
        @str = nil
        @pos = nil
        @lex_state = nil
        @token = nil
        @flag_symbols = {}
      end

      def parse(str)
        @str = str
        @pos = 0
        @lex_state = EXPR_BEG
        @token = nil
        return response
      end

      private

      EXPR_BEG          = :EXPR_BEG
      EXPR_DATA         = :EXPR_DATA
      EXPR_TEXT         = :EXPR_TEXT
      EXPR_RTEXT        = :EXPR_RTEXT
      EXPR_CTEXT        = :EXPR_CTEXT

      T_SPACE   = :SPACE
      T_NIL     = :NIL
      T_NUMBER  = :NUMBER
      T_ATOM    = :ATOM
      T_QUOTED  = :QUOTED
      T_LPAR    = :LPAR
      T_RPAR    = :RPAR
      T_BSLASH  = :BSLASH
      T_STAR    = :STAR
      T_LBRA    = :LBRA
      T_RBRA    = :RBRA
      T_LITERAL = :LITERAL
      T_PLUS    = :PLUS
      T_PERCENT = :PERCENT
      T_CRLF    = :CRLF
      T_EOF     = :EOF
      T_TEXT    = :TEXT

      BEG_REGEXP = /\G(?:\
(?# 1:  SPACE   )( +)|\
(?# 2:  NIL     )(NIL)(?=[\x80-\xff(){ \x00-\x1f\x7f%*"\\\[\]+])|\
(?# 3:  NUMBER  )(\d+)(?=[\x80-\xff(){ \x00-\x1f\x7f%*"\\\[\]+])|\
(?# 4:  ATOM    )([^\x80-\xff(){ \x00-\x1f\x7f%*"\\\[\]+]+)|\
(?# 5:  QUOTED  )"((?:[^\x00\r\n"\\]|\\["\\])*)"|\
(?# 6:  LPAR    )(\()|\
(?# 7:  RPAR    )(\))|\
(?# 8:  BSLASH  )(\\)|\
(?# 9:  STAR    )(\*)|\
(?# 10: LBRA    )(\[)|\
(?# 11: RBRA    )(\])|\
(?# 12: LITERAL )\{(\d+)\}\r\n|\
(?# 13: PLUS    )(\+)|\
(?# 14: PERCENT )(%)|\
(?# 15: CRLF    )(\r\n)|\
(?# 16: EOF     )(\z))/ni

      DATA_REGEXP = /\G(?:\
(?# 1:  SPACE   )( )|\
(?# 2:  NIL     )(NIL)|\
(?# 3:  NUMBER  )(\d+)|\
(?# 4:  QUOTED  )"((?:[^\x00\r\n"\\]|\\["\\])*)"|\
(?# 5:  LITERAL )\{(\d+)\}\r\n|\
(?# 6:  LPAR    )(\()|\
(?# 7:  RPAR    )(\)))/ni

      TEXT_REGEXP = /\G(?:\
(?# 1:  TEXT    )([^\x00\r\n]*))/ni

      RTEXT_REGEXP = /\G(?:\
(?# 1:  LBRA    )(\[)|\
(?# 2:  TEXT    )([^\x00\r\n]*))/ni

      CTEXT_REGEXP = /\G(?:\
(?# 1:  TEXT    )([^\x00\r\n\]]*))/ni

      Token = Struct.new(:symbol, :value)

      def response
        token = lookahead
        case token.symbol
        when T_PLUS
          result = continue_req
        when T_STAR
          result = response_untagged
        else
          result = response_tagged
        end
        match(T_CRLF)
        match(T_EOF)
        return result
      end

      def continue_req
        match(T_PLUS)
        match(T_SPACE)
        return ContinuationRequest.new(resp_text, @str)
      end

      def response_untagged
        match(T_STAR)
        match(T_SPACE)
        token = lookahead
        if token.symbol == T_NUMBER
          return numeric_response
        elsif token.symbol == T_ATOM
          case token.value
          when /\A(?:OK|NO|BAD|BYE|PREAUTH)\z/ni
            return response_cond
          when /\A(?:FLAGS)\z/ni
            return flags_response
          when /\A(?:LIST|LSUB)\z/ni
            return list_response
          when /\A(?:QUOTA)\z/ni
            return getquota_response
          when /\A(?:QUOTAROOT)\z/ni
            return getquotaroot_response
          when /\A(?:ACL)\z/ni
            return getacl_response
          when /\A(?:SEARCH|SORT)\z/ni
            return search_response
          when /\A(?:THREAD)\z/ni
            return thread_response
          when /\A(?:STATUS)\z/ni
            return status_response
          when /\A(?:CAPABILITY)\z/ni
            return capability_response
          else
            return text_response
          end
        else
          parse_error("unexpected token %s", token.symbol)
        end
      end

      def response_tagged
        tag = atom
        match(T_SPACE)
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        return TaggedResponse.new(tag, name, resp_text, @str)
      end

      def response_cond
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        return UntaggedResponse.new(name, resp_text, @str)
      end

      def numeric_response
        n = number
        match(T_SPACE)
        token = match(T_ATOM)
        name = token.value.upcase
        case name
        when "EXISTS", "RECENT", "EXPUNGE"
          return UntaggedResponse.new(name, n, @str)
        when "FETCH"
          shift_token
          match(T_SPACE)
          data = FetchData.new(n, msg_att)
          return UntaggedResponse.new(name, data, @str)
        end
      end

      def msg_att
        match(T_LPAR)
        attr = {}
        while true
          token = lookahead
          case token.symbol
          when T_RPAR
            shift_token
            break
          when T_SPACE
            shift_token
            token = lookahead
          end
          case token.value
          when /\A(?:ENVELOPE)\z/ni
            name, val = envelope_data
          when /\A(?:FLAGS)\z/ni
            name, val = flags_data
          when /\A(?:INTERNALDATE)\z/ni
            name, val = internaldate_data
          when /\A(?:RFC822(?:\.HEADER|\.TEXT)?)\z/ni
            name, val = rfc822_text
          when /\A(?:RFC822\.SIZE)\z/ni
            name, val = rfc822_size
          when /\A(?:BODY(?:STRUCTURE)?)\z/ni
            name, val = body_data
          when /\A(?:UID)\z/ni
            name, val = uid_data
          else
            parse_error("unknown attribute `%s'", token.value)
          end
          attr[name] = val
        end
        return attr
      end

      def envelope_data
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        return name, envelope
      end

      def envelope
        @lex_state = EXPR_DATA
        token = lookahead
        if token.symbol == T_NIL
          shift_token
          result = nil
        else
          match(T_LPAR)
          date = nstring
          match(T_SPACE)
          subject = nstring
          match(T_SPACE)
          from = address_list
          match(T_SPACE)
          sender = address_list
          match(T_SPACE)
          reply_to = address_list
          match(T_SPACE)
          to = address_list
          match(T_SPACE)
          cc = address_list
          match(T_SPACE)
          bcc = address_list
          match(T_SPACE)
          in_reply_to = nstring
          match(T_SPACE)
          message_id = nstring
          match(T_RPAR)
          result = Envelope.new(date, subject, from, sender, reply_to,
                                to, cc, bcc, in_reply_to, message_id)
        end
        @lex_state = EXPR_BEG
        return result
      end

      def flags_data
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        return name, flag_list
      end

      def internaldate_data
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        token = match(T_QUOTED)
        return name, token.value
      end

      def rfc822_text
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        return name, nstring
      end

      def rfc822_size
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        return name, number
      end

      def body_data
        token = match(T_ATOM)
        name = token.value.upcase
        token = lookahead
        if token.symbol == T_SPACE
          shift_token
          return name, body
        end
        name.concat(section)
        token = lookahead
        if token.symbol == T_ATOM
          name.concat(token.value)
          shift_token
        end
        match(T_SPACE)
        data = nstring
        return name, data
      end

      def body
        @lex_state = EXPR_DATA
        token = lookahead
        if token.symbol == T_NIL
          shift_token
          result = nil
        else
          match(T_LPAR)
          token = lookahead
          if token.symbol == T_LPAR
            result = body_type_mpart
          else
            result = body_type_1part
          end
          match(T_RPAR)
        end
        @lex_state = EXPR_BEG
        return result
      end

      def body_type_1part
        token = lookahead
        case token.value
        when /\A(?:TEXT)\z/ni
          return body_type_text
        when /\A(?:MESSAGE)\z/ni
          return body_type_msg
        else
          return body_type_basic
        end
      end

      def body_type_basic
        mtype, msubtype = media_type
        token = lookahead
        if token.symbol == T_RPAR
          return BodyTypeBasic.new(mtype, msubtype)
        end
        match(T_SPACE)
        param, content_id, desc, enc, size = body_fields
        md5, disposition, language, extension = body_ext_1part
        return BodyTypeBasic.new(mtype, msubtype,
                                 param, content_id,
                                 desc, enc, size,
                                 md5, disposition, language, extension)
      end

      def body_type_text
        mtype, msubtype = media_type
        match(T_SPACE)
        param, content_id, desc, enc, size = body_fields
        match(T_SPACE)
        lines = number
        md5, disposition, language, extension = body_ext_1part
        return BodyTypeText.new(mtype, msubtype,
                                param, content_id,
                                desc, enc, size,
                                lines,
                                md5, disposition, language, extension)
      end

      def body_type_msg
        mtype, msubtype = media_type
        match(T_SPACE)
        param, content_id, desc, enc, size = body_fields
        match(T_SPACE)
        env = envelope
        match(T_SPACE)
        b = body
        match(T_SPACE)
        lines = number
        md5, disposition, language, extension = body_ext_1part
        return BodyTypeMessage.new(mtype, msubtype,
                                   param, content_id,
                                   desc, enc, size,
                                   env, b, lines,
                                   md5, disposition, language, extension)
      end

      def body_type_mpart
        parts = []
        while true
          token = lookahead
          if token.symbol == T_SPACE
            shift_token
            break
          end
          parts.push(body)
        end
        mtype = "MULTIPART"
        msubtype = case_insensitive_string
        param, disposition, language, extension = body_ext_mpart
        return BodyTypeMultipart.new(mtype, msubtype, parts,
                                     param, disposition, language,
                                     extension)
      end

      def media_type
        mtype = case_insensitive_string
        match(T_SPACE)
        msubtype = case_insensitive_string
        return mtype, msubtype
      end

      def body_fields
        param = body_fld_param
        match(T_SPACE)
        content_id = nstring
        match(T_SPACE)
        desc = nstring
        match(T_SPACE)
        enc = case_insensitive_string
        match(T_SPACE)
        size = number
        return param, content_id, desc, enc, size
      end

      def body_fld_param
        token = lookahead
        if token.symbol == T_NIL
          shift_token
          return nil
        end
        match(T_LPAR)
        param = {}
        while true
          token = lookahead
          case token.symbol
          when T_RPAR
            shift_token
            break
          when T_SPACE
            shift_token
          end
          name = case_insensitive_string
          match(T_SPACE)
          val = string
          param[name] = val
        end
        return param
      end

      def body_ext_1part
        token = lookahead
        if token.symbol == T_SPACE
          shift_token
        else
          return nil
        end
        md5 = nstring

        token = lookahead
        if token.symbol == T_SPACE
          shift_token
        else
          return md5
        end
        disposition = body_fld_dsp

        token = lookahead
        if token.symbol == T_SPACE
          shift_token
        else
          return md5, disposition
        end
        language = body_fld_lang

        token = lookahead
        if token.symbol == T_SPACE
          shift_token
        else
          return md5, disposition, language
        end

        extension = body_extensions
        return md5, disposition, language, extension
      end

      def body_ext_mpart
        token = lookahead
        if token.symbol == T_SPACE
          shift_token
        else
          return nil
        end
        param = body_fld_param

        token = lookahead
        if token.symbol == T_SPACE
          shift_token
        else
          return param
        end
        disposition = body_fld_dsp
        match(T_SPACE)
        language = body_fld_lang

        token = lookahead
        if token.symbol == T_SPACE
          shift_token
        else
          return param, disposition, language
        end

        extension = body_extensions
        return param, disposition, language, extension
      end

      def body_fld_dsp
        token = lookahead
        if token.symbol == T_NIL
          shift_token
          return nil
        end
        match(T_LPAR)
        dsp_type = case_insensitive_string
        match(T_SPACE)
        param = body_fld_param
        match(T_RPAR)
        return ContentDisposition.new(dsp_type, param)
      end

      def body_fld_lang
        token = lookahead
        if token.symbol == T_LPAR
          shift_token
          result = []
          while true
            token = lookahead
            case token.symbol
            when T_RPAR
              shift_token
              return result
            when T_SPACE
              shift_token
            end
            result.push(case_insensitive_string)
          end
        else
          lang = nstring
          if lang
            return lang.upcase
          else
            return lang
          end
        end
      end

      def body_extensions
        result = []
        while true
          token = lookahead
          case token.symbol
          when T_RPAR
            return result
          when T_SPACE
            shift_token
          end
          result.push(body_extension)
        end
      end

      def body_extension
        token = lookahead
        case token.symbol
        when T_LPAR
          shift_token
          result = body_extensions
          match(T_RPAR)
          return result
        when T_NUMBER
          return number
        else
          return nstring
        end
      end

      def section
        str = ""
        token = match(T_LBRA)
        str.concat(token.value)
        token = match(T_ATOM, T_NUMBER, T_RBRA)
        if token.symbol == T_RBRA
          str.concat(token.value)
          return str
        end
        str.concat(token.value)
        token = lookahead
        if token.symbol == T_SPACE
          shift_token
          str.concat(token.value)
          token = match(T_LPAR)
          str.concat(token.value)
          while true
            token = lookahead
            case token.symbol
            when T_RPAR
              str.concat(token.value)
              shift_token
              break
            when T_SPACE
              shift_token
              str.concat(token.value)
            end
            str.concat(format_string(astring))
          end
        end
        token = match(T_RBRA)
        str.concat(token.value)
        return str
      end

      def format_string(str)
        case str
        when ""
          return '""'
        when /[\x80-\xff\r\n]/n
          # literal
          return "{" + str.length.to_s + "}" + CRLF + str
        when /[(){ \x00-\x1f\x7f%*"\\]/n
          # quoted string
          return '"' + str.gsub(/["\\]/n, "\\\\\\&") + '"'
        else
          # atom
          return str
        end
      end

      def uid_data
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        return name, number
      end

      def text_response
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        @lex_state = EXPR_TEXT
        token = match(T_TEXT)
        @lex_state = EXPR_BEG
        return UntaggedResponse.new(name, token.value)
      end

      def flags_response
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        return UntaggedResponse.new(name, flag_list, @str)
      end

      def list_response
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        return UntaggedResponse.new(name, mailbox_list, @str)
      end

      def mailbox_list
        attr = flag_list
        match(T_SPACE)
        token = match(T_QUOTED, T_NIL)
        if token.symbol == T_NIL
          delim = nil
        else
          delim = token.value
        end
        match(T_SPACE)
        name = astring
        return MailboxList.new(attr, delim, name)
      end

      def getquota_response
        # If quota never established, get back
        # `NO Quota root does not exist'.
        # If quota removed, get `()' after the
        # folder spec with no mention of `STORAGE'.
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        mailbox = astring
        match(T_SPACE)
        match(T_LPAR)
        token = lookahead
        case token.symbol
        when T_RPAR
          shift_token
          data = MailboxQuota.new(mailbox, nil, nil)
          return UntaggedResponse.new(name, data, @str)
        when T_ATOM
          shift_token
          match(T_SPACE)
          token = match(T_NUMBER)
          usage = token.value
          match(T_SPACE)
          token = match(T_NUMBER)
          quota = token.value
          match(T_RPAR)
          data = MailboxQuota.new(mailbox, usage, quota)
          return UntaggedResponse.new(name, data, @str)
        else
          parse_error("unexpected token %s", token.symbol)
        end
      end

      def getquotaroot_response
        # Similar to getquota, but only admin can use getquota.
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        mailbox = astring
        quotaroots = []
        while true
          token = lookahead
          break unless token.symbol == T_SPACE
          shift_token
          quotaroots.push(astring)
        end
        data = MailboxQuotaRoot.new(mailbox, quotaroots)
        return UntaggedResponse.new(name, data, @str)
      end

      def getacl_response
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        mailbox = astring
        data = []
        token = lookahead
        if token.symbol == T_SPACE
          shift_token
          while true
            token = lookahead
            case token.symbol
            when T_CRLF
              break
            when T_SPACE
              shift_token
            end
            user = astring
            match(T_SPACE)
            rights = astring
            ##XXX data.push([user, rights])
            data.push(MailboxACLItem.new(user, rights))
          end
        end
        return UntaggedResponse.new(name, data, @str)
      end

      def search_response
        token = match(T_ATOM)
        name = token.value.upcase
        token = lookahead
        if token.symbol == T_SPACE
          shift_token
          data = []
          while true
            token = lookahead
            case token.symbol
            when T_CRLF
              break
            when T_SPACE
              shift_token
            end
            data.push(number)
          end
        else
          data = []
        end
        return UntaggedResponse.new(name, data, @str)
      end

      def thread_response
        token = match(T_ATOM)
        name = token.value.upcase
        token = lookahead

        if token.symbol == T_SPACE
          threads = []

          while true
            shift_token
            token = lookahead

            case token.symbol
            when T_LPAR
              threads << thread_branch(token)
            when T_CRLF
              break
            end
          end
        else
          # no member
          threads = []
        end

        return UntaggedResponse.new(name, threads, @str)
      end

      def thread_branch(token)
        rootmember = nil
        lastmember = nil

        while true
          shift_token    # ignore first T_LPAR
          token = lookahead

          case token.symbol
          when T_NUMBER
            # new member
            newmember = ThreadMember.new(number, [])
            if rootmember.nil?
              rootmember = newmember
            else
              lastmember.children << newmember
            end
            lastmember = newmember
          when T_SPACE
            # do nothing
          when T_LPAR
            if rootmember.nil?
              # dummy member
              lastmember = rootmember = ThreadMember.new(nil, [])
            end

            lastmember.children << thread_branch(token)
          when T_RPAR
            break
          end
        end

        return rootmember
      end

      def status_response
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        mailbox = astring
        match(T_SPACE)
        match(T_LPAR)
        attr = {}
        while true
          token = lookahead
          case token.symbol
          when T_RPAR
            shift_token
            break
          when T_SPACE
            shift_token
          end
          token = match(T_ATOM)
          key = token.value.upcase
          match(T_SPACE)
          val = number
          attr[key] = val
        end
        data = StatusData.new(mailbox, attr)
        return UntaggedResponse.new(name, data, @str)
      end

      def capability_response
        token = match(T_ATOM)
        name = token.value.upcase
        match(T_SPACE)
        data = []
        while true
          token = lookahead
          case token.symbol
          when T_CRLF
            break
          when T_SPACE
            shift_token
          end
          data.push(atom.upcase)
        end
        return UntaggedResponse.new(name, data, @str)
      end

      def resp_text
        @lex_state = EXPR_RTEXT
        token = lookahead
        if token.symbol == T_LBRA
          code = resp_text_code
        else
          code = nil
        end
        token = match(T_TEXT)
        @lex_state = EXPR_BEG
        return ResponseText.new(code, token.value)
      end

      def resp_text_code
        @lex_state = EXPR_BEG
        match(T_LBRA)
        token = match(T_ATOM)
        name = token.value.upcase
        case name
        when /\A(?:ALERT|PARSE|READ-ONLY|READ-WRITE|TRYCREATE|NOMODSEQ)\z/n
          result = ResponseCode.new(name, nil)
        when /\A(?:PERMANENTFLAGS)\z/n
          match(T_SPACE)
          result = ResponseCode.new(name, flag_list)
        when /\A(?:UIDVALIDITY|UIDNEXT|UNSEEN)\z/n
          match(T_SPACE)
          result = ResponseCode.new(name, number)
        else
          token = lookahead
          if token.symbol == T_SPACE
            shift_token
            @lex_state = EXPR_CTEXT
            token = match(T_TEXT)
            @lex_state = EXPR_BEG
            result = ResponseCode.new(name, token.value)
          else
            result = ResponseCode.new(name, nil)
          end
        end
        match(T_RBRA)
        @lex_state = EXPR_RTEXT
        return result
      end

      def address_list
        token = lookahead
        if token.symbol == T_NIL
          shift_token
          return nil
        else
          result = []
          match(T_LPAR)
          while true
            token = lookahead
            case token.symbol
            when T_RPAR
              shift_token
              break
            when T_SPACE
              shift_token
            end
            result.push(address)
          end
          return result
        end
      end

      ADDRESS_REGEXP = /\G\
(?# 1: NAME     )(?:NIL|"((?:[^\x80-\xff\x00\r\n"\\]|\\["\\])*)") \
(?# 2: ROUTE    )(?:NIL|"((?:[^\x80-\xff\x00\r\n"\\]|\\["\\])*)") \
(?# 3: MAILBOX  )(?:NIL|"((?:[^\x80-\xff\x00\r\n"\\]|\\["\\])*)") \
(?# 4: HOST     )(?:NIL|"((?:[^\x80-\xff\x00\r\n"\\]|\\["\\])*)")\
\)/ni

      def address
        match(T_LPAR)
        if @str.index(ADDRESS_REGEXP, @pos)
          # address does not include literal.
          @pos = $~.end(0)
          name = $1
          route = $2
          mailbox = $3
          host = $4
          for s in [name, route, mailbox, host]
            if s
              s.gsub!(/\\(["\\])/n, "\\1")
            end
          end
        else
          name = nstring
          match(T_SPACE)
          route = nstring
          match(T_SPACE)
          mailbox = nstring
          match(T_SPACE)
          host = nstring
          match(T_RPAR)
        end
        return Address.new(name, route, mailbox, host)
      end

#        def flag_list
#       result = []
#       match(T_LPAR)
#       while true
#         token = lookahead
#         case token.symbol
#         when T_RPAR
#           shift_token
#           break
#         when T_SPACE
#           shift_token
#         end
#         result.push(flag)
#       end
#       return result
#        end

#        def flag
#       token = lookahead
#       if token.symbol == T_BSLASH
#         shift_token
#         token = lookahead
#         if token.symbol == T_STAR
#           shift_token
#           return token.value.intern
#         else
#           return atom.intern
#         end
#       else
#         return atom
#       end
#        end

      FLAG_REGEXP = /\
(?# FLAG        )\\([^\x80-\xff(){ \x00-\x1f\x7f%"\\]+)|\
(?# ATOM        )([^\x80-\xff(){ \x00-\x1f\x7f%*"\\]+)/n

      def flag_list
        if @str.index(/\(([^)]*)\)/ni, @pos)
          @pos = $~.end(0)
          return $1.scan(FLAG_REGEXP).collect { |flag, atom|
            if atom
              atom
            else
              symbol = flag.capitalize.untaint.intern
              @flag_symbols[symbol] = true
              if @flag_symbols.length > IMAP.max_flag_count
                raise FlagCountError, "number of flag symbols exceeded"
              end
              symbol
            end
          }
        else
          parse_error("invalid flag list")
        end
      end

      def nstring
        token = lookahead
        if token.symbol == T_NIL
          shift_token
          return nil
        else
          return string
        end
      end

      def astring
        token = lookahead
        if string_token?(token)
          return string
        else
          return atom
        end
      end

      def string
        token = lookahead
        if token.symbol == T_NIL
          shift_token
          return nil
        end
        token = match(T_QUOTED, T_LITERAL)
        return token.value
      end

      STRING_TOKENS = [T_QUOTED, T_LITERAL, T_NIL]

      def string_token?(token)
        return STRING_TOKENS.include?(token.symbol)
      end

      def case_insensitive_string
        token = lookahead
        if token.symbol == T_NIL
          shift_token
          return nil
        end
        token = match(T_QUOTED, T_LITERAL)
        return token.value.upcase
      end

      def atom
        result = ""
        while true
          token = lookahead
          if atom_token?(token)
            result.concat(token.value)
            shift_token
          else
            if result.empty?
              parse_error("unexpected token %s", token.symbol)
            else
              return result
            end
          end
        end
      end

      ATOM_TOKENS = [
        T_ATOM,
        T_NUMBER,
        T_NIL,
        T_LBRA,
        T_RBRA,
        T_PLUS
      ]

      def atom_token?(token)
        return ATOM_TOKENS.include?(token.symbol)
      end

      def number
        token = lookahead
        if token.symbol == T_NIL
          shift_token
          return nil
        end
        token = match(T_NUMBER)
        return token.value.to_i
      end

      def nil_atom
        match(T_NIL)
        return nil
      end

      def match(*args)
        token = lookahead
        unless args.include?(token.symbol)
          parse_error('unexpected token %s (expected %s)',
                      token.symbol.id2name,
                      args.collect {|i| i.id2name}.join(" or "))
        end
        shift_token
        return token
      end

      def lookahead
        unless @token
          @token = next_token
        end
        return @token
      end

      def shift_token
        @token = nil
      end

      def next_token
        case @lex_state
        when EXPR_BEG
          if @str.index(BEG_REGEXP, @pos)
            @pos = $~.end(0)
            if $1
              return Token.new(T_SPACE, $+)
            elsif $2
              return Token.new(T_NIL, $+)
            elsif $3
              return Token.new(T_NUMBER, $+)
            elsif $4
              return Token.new(T_ATOM, $+)
            elsif $5
              return Token.new(T_QUOTED,
                               $+.gsub(/\\(["\\])/n, "\\1"))
            elsif $6
              return Token.new(T_LPAR, $+)
            elsif $7
              return Token.new(T_RPAR, $+)
            elsif $8
              return Token.new(T_BSLASH, $+)
            elsif $9
              return Token.new(T_STAR, $+)
            elsif $10
              return Token.new(T_LBRA, $+)
            elsif $11
              return Token.new(T_RBRA, $+)
            elsif $12
              len = $+.to_i
              val = @str[@pos, len]
              @pos += len
              return Token.new(T_LITERAL, val)
            elsif $13
              return Token.new(T_PLUS, $+)
            elsif $14
              return Token.new(T_PERCENT, $+)
            elsif $15
              return Token.new(T_CRLF, $+)
            elsif $16
              return Token.new(T_EOF, $+)
            else
              parse_error("[Net::IMAP BUG] BEG_REGEXP is invalid")
            end
          else
            @str.index(/\S*/n, @pos)
            parse_error("unknown token - %s", $&.dump)
          end
        when EXPR_DATA
          if @str.index(DATA_REGEXP, @pos)
            @pos = $~.end(0)
            if $1
              return Token.new(T_SPACE, $+)
            elsif $2
              return Token.new(T_NIL, $+)
            elsif $3
              return Token.new(T_NUMBER, $+)
            elsif $4
              return Token.new(T_QUOTED,
                               $+.gsub(/\\(["\\])/n, "\\1"))
            elsif $5
              len = $+.to_i
              val = @str[@pos, len]
              @pos += len
              return Token.new(T_LITERAL, val)
            elsif $6
              return Token.new(T_LPAR, $+)
            elsif $7
              return Token.new(T_RPAR, $+)
            else
              parse_error("[Net::IMAP BUG] DATA_REGEXP is invalid")
            end
          else
            @str.index(/\S*/n, @pos)
            parse_error("unknown token - %s", $&.dump)
          end
        when EXPR_TEXT
          if @str.index(TEXT_REGEXP, @pos)
            @pos = $~.end(0)
            if $1
              return Token.new(T_TEXT, $+)
            else
              parse_error("[Net::IMAP BUG] TEXT_REGEXP is invalid")
            end
          else
            @str.index(/\S*/n, @pos)
            parse_error("unknown token - %s", $&.dump)
          end
        when EXPR_RTEXT
          if @str.index(RTEXT_REGEXP, @pos)
            @pos = $~.end(0)
            if $1
              return Token.new(T_LBRA, $+)
            elsif $2
              return Token.new(T_TEXT, $+)
            else
              parse_error("[Net::IMAP BUG] RTEXT_REGEXP is invalid")
            end
          else
            @str.index(/\S*/n, @pos)
            parse_error("unknown token - %s", $&.dump)
          end
        when EXPR_CTEXT
          if @str.index(CTEXT_REGEXP, @pos)
            @pos = $~.end(0)
            if $1
              return Token.new(T_TEXT, $+)
            else
              parse_error("[Net::IMAP BUG] CTEXT_REGEXP is invalid")
            end
          else
            @str.index(/\S*/n, @pos) #/
            parse_error("unknown token - %s", $&.dump)
          end
        else
          parse_error("invalid @lex_state - %s", @lex_state.inspect)
        end
      end

      def parse_error(fmt, *args)
        if IMAP.debug
          $stderr.printf("@str: %s\n", @str.dump)
          $stderr.printf("@pos: %d\n", @pos)
          $stderr.printf("@lex_state: %s\n", @lex_state)
          if @token
            $stderr.printf("@token.symbol: %s\n", @token.symbol)
            $stderr.printf("@token.value: %s\n", @token.value.inspect)
          end
        end
        raise ResponseParseError, format(fmt, *args)
      end
    end

    # Authenticator for the "LOGIN" authentication type.  See
    # #authenticate().
    class LoginAuthenticator
      def process(data)
        case @state
        when STATE_USER
          @state = STATE_PASSWORD
          return @user
        when STATE_PASSWORD
          return @password
        end
      end

      private

      STATE_USER = :USER
      STATE_PASSWORD = :PASSWORD

      def initialize(user, password)
        @user = user
        @password = password
        @state = STATE_USER
      end
    end
    add_authenticator "LOGIN", LoginAuthenticator

    # Authenticator for the "PLAIN" authentication type.  See
    # #authenticate().
    class PlainAuthenticator
      def process(data)
        return "\0#{@user}\0#{@password}"
      end

      private

      def initialize(user, password)
        @user = user
        @password = password
      end
    end
    add_authenticator "PLAIN", PlainAuthenticator

    # Authenticator for the "CRAM-MD5" authentication type.  See
    # #authenticate().
    class CramMD5Authenticator
      def process(challenge)
        digest = hmac_md5(challenge, @password)
        return @user + " " + digest
      end

      private

      def initialize(user, password)
        @user = user
        @password = password
      end

      def hmac_md5(text, key)
        if key.length > 64
          key = Digest::MD5.digest(key)
        end

        k_ipad = key + "\0" * (64 - key.length)
        k_opad = key + "\0" * (64 - key.length)
        for i in 0..63
          k_ipad[i] = (k_ipad[i].ord ^ 0x36).chr
          k_opad[i] = (k_opad[i].ord ^ 0x5c).chr
        end

        digest = Digest::MD5.digest(k_ipad + text)

        return Digest::MD5.hexdigest(k_opad + digest)
      end
    end
    add_authenticator "CRAM-MD5", CramMD5Authenticator

    # Authenticator for the "DIGEST-MD5" authentication type.  See
    # #authenticate().
    class DigestMD5Authenticator
      def process(challenge)
	case @stage
	when STAGE_ONE
	  @stage = STAGE_TWO
	  sparams = {}
	  c = StringScanner.new(challenge)
	  while c.scan(/(?:\s*,)?\s*(\w+)=("(?:[^\\"]+|\\.)*"|[^,]+)\s*/)
	    k, v = c[1], c[2]
	    if v =~ /^"(.*)"$/
	      v = $1
	      if v =~ /,/
		v = v.split(',')
	      end
	    end
	    sparams[k] = v
	  end

	  raise DataFormatError, "Bad Challenge: '#{challenge}'" unless c.rest.size == 0
	  raise Error, "Server does not support auth (qop = #{sparams['qop'].join(',')})" unless sparams['qop'].include?("auth")

	  response = {
	    :nonce => sparams['nonce'],
	    :username => @user,
	    :realm => sparams['realm'],
	    :cnonce => Digest::MD5.hexdigest("%.15f:%.15f:%d" % [Time.now.to_f, rand, Process.pid.to_s]),
	    :'digest-uri' => 'imap/' + sparams['realm'],
	    :qop => 'auth',
	    :maxbuf => 65535,
	    :nc => "%08d" % nc(sparams['nonce']),
	    :charset => sparams['charset'],
	  }

	  response[:authzid] = @authname unless @authname.nil?

	  # now, the real thing
	  a0 = Digest::MD5.digest( [ response.values_at(:username, :realm), @password ].join(':') )

	  a1 = [ a0, response.values_at(:nonce,:cnonce) ].join(':')
	  a1 << ':' + response[:authzid] unless response[:authzid].nil?

	  a2 = "AUTHENTICATE:" + response[:'digest-uri']
	  a2 << ":00000000000000000000000000000000" if response[:qop] and response[:qop] =~ /^auth-(?:conf|int)$/

	  response[:response] = Digest::MD5.hexdigest(
	    [
	     Digest::MD5.hexdigest(a1),
	     response.values_at(:nonce, :nc, :cnonce, :qop),
	     Digest::MD5.hexdigest(a2)
	    ].join(':')
	  )

	  return response.keys.map {|key| qdval(key.to_s, response[key]) }.join(',')
	when STAGE_TWO
	  @stage = nil
	  # if at the second stage, return an empty string
	  if challenge =~ /rspauth=/
	    return ''
	  else
	    raise ResponseParseError, challenge
	  end
	else
	  raise ResponseParseError, challenge
	end
      end

      def initialize(user, password, authname = nil)
	@user, @password, @authname = user, password, authname
	@nc, @stage = {}, STAGE_ONE
      end

      private

      STAGE_ONE = :stage_one
      STAGE_TWO = :stage_two

      def nc(nonce)
	if @nc.has_key? nonce
	  @nc[nonce] = @nc[nonce] + 1
	else
	  @nc[nonce] = 1
	end
	return @nc[nonce]
      end

      # some responses need quoting
      def qdval(k, v)
	return if k.nil? or v.nil?
	if %w"username authzid realm nonce cnonce digest-uri qop".include? k
	  v.gsub!(/([\\"])/, "\\\1")
	  return '%s="%s"' % [k, v]
	else
	  return '%s=%s' % [k, v]
	end
      end
    end
    add_authenticator "DIGEST-MD5", DigestMD5Authenticator

    # Superclass of IMAP errors.
    class Error < StandardError
    end

    # Error raised when data is in the incorrect format.
    class DataFormatError < Error
    end

    # Error raised when a response from the server is non-parseable.
    class ResponseParseError < Error
    end

    # Superclass of all errors used to encapsulate "fail" responses
    # from the server.
    class ResponseError < Error

      # The response that caused this error
      attr_accessor :response

      def initialize(response)
        @response = response

        super @response.data.text
      end

    end

    # Error raised upon a "NO" response from the server, indicating
    # that the client command could not be completed successfully.
    class NoResponseError < ResponseError
    end

    # Error raised upon a "BAD" response from the server, indicating
    # that the client command violated the IMAP protocol, or an internal
    # server failure has occurred.
    class BadResponseError < ResponseError
    end

    # Error raised upon a "BYE" response from the server, indicating
    # that the client is not being allowed to login, or has been timed
    # out due to inactivity.
    class ByeResponseError < ResponseError
    end

    # Error raised when too many flags are interned to symbols.
    class FlagCountError < Error
    end
  end
end

if __FILE__ == $0
  # :enddoc:
  require "getoptlong"

  $stdout.sync = true
  $port = nil
  $user = ENV["USER"] || ENV["LOGNAME"]
  $auth = "login"
  $ssl = false

  def usage
    $stderr.print <<EOF
usage: #{$0} [options] <host>

  --help                        print this message
  --port=PORT                   specifies port
  --user=USER                   specifies user
  --auth=AUTH                   specifies auth type
  --ssl                         use ssl
EOF
  end

  def get_password
    print "password: "
    system("stty", "-echo")
    begin
      return gets.chop
    ensure
      system("stty", "echo")
      print "\n"
    end
  end

  def get_command
    printf("%s@%s> ", $user, $host)
    if line = gets
      return line.strip.split(/\s+/)
    else
      return nil
    end
  end

  parser = GetoptLong.new
  parser.set_options(['--debug', GetoptLong::NO_ARGUMENT],
                     ['--help', GetoptLong::NO_ARGUMENT],
                     ['--port', GetoptLong::REQUIRED_ARGUMENT],
                     ['--user', GetoptLong::REQUIRED_ARGUMENT],
                     ['--auth', GetoptLong::REQUIRED_ARGUMENT],
                     ['--ssl', GetoptLong::NO_ARGUMENT])
  begin
    parser.each_option do |name, arg|
      case name
      when "--port"
        $port = arg
      when "--user"
        $user = arg
      when "--auth"
        $auth = arg
      when "--ssl"
        $ssl = true
      when "--debug"
        Net::IMAP.debug = true
      when "--help"
        usage
        exit(1)
      end
    end
  rescue
    usage
    exit(1)
  end

  $host = ARGV.shift
  unless $host
    usage
    exit(1)
  end

  imap = Net::IMAP.new($host, :port => $port, :ssl => $ssl)
  begin
    password = get_password
    imap.authenticate($auth, $user, password)
    while true
      cmd, *args = get_command
      break unless cmd
      begin
        case cmd
        when "list"
          for mbox in imap.list("", args[0] || "*")
            if mbox.attr.include?(Net::IMAP::NOSELECT)
              prefix = "!"
            elsif mbox.attr.include?(Net::IMAP::MARKED)
              prefix = "*"
            else
              prefix = " "
            end
            print prefix, mbox.name, "\n"
          end
        when "select"
          imap.select(args[0] || "inbox")
          print "ok\n"
        when "close"
          imap.close
          print "ok\n"
        when "summary"
          unless messages = imap.responses["EXISTS"][-1]
            puts "not selected"
            next
          end
          if messages > 0
            for data in imap.fetch(1..-1, ["ENVELOPE"])
              print data.seqno, ": ", data.attr["ENVELOPE"].subject, "\n"
            end
          else
            puts "no message"
          end
        when "fetch"
          if args[0]
            data = imap.fetch(args[0].to_i, ["RFC822.HEADER", "RFC822.TEXT"])[0]
            puts data.attr["RFC822.HEADER"]
            puts data.attr["RFC822.TEXT"]
          else
            puts "missing argument"
          end
        when "logout", "exit", "quit"
          break
        when "help", "?"
          print <<EOF
list [pattern]                  list mailboxes
select [mailbox]                select mailbox
close                           close mailbox
summary                         display summary
fetch [msgno]                   display message
logout                          logout
help, ?                         display help message
EOF
        else
          print "unknown command: ", cmd, "\n"
        end
      rescue Net::IMAP::Error
        puts $!
      end
    end
  ensure
    imap.logout
    imap.disconnect
  end
end

# -*- coding: euc-jp -*-
#
# radio3.rb
#
# This demonstration script creates a toplevel window containing
# several radiobutton widgets.
#
# radiobutton widget demo (called by 'widget')
#

# toplevel widget
if defined?($radio3_demo) && $radio3_demo
  $radio3_demo.destroy
  $radio3_demo = nil
end

# demo toplevel widget
$radio3_demo = TkToplevel.new {|w|
  title("Radiobutton Demonstration 3")
  iconname("radio3")
  positionWindow(w)
}

base_frame = TkFrame.new($radio3_demo).pack(:fill=>:both, :expand=>true)

# label
msg = TkLabel.new(base_frame) {
  font $font
  wraplength '5i'
  justify 'left'
  text '3on/off'
}
msg.grid(:row=>0, :column=>0, :columnspan=>3, :sticky=>'nsew')

# variable
size = TkVariable.new
color = TkVariable.new
align = TkVariable.new

# frame
TkFrame.new(base_frame) {|frame|
  TkGrid(TkFrame.new(frame, :height=>2, :relief=>:sunken, :bd=>2),
         :columnspan=>4, :row=>0, :sticky=>'ew', :pady=>2)
  TkGrid('x',
         TkButton.new(frame, :text=>'',
                      :image=>$image['view'], :compound=>:left,
                      :command=>proc{
                        showVars(base_frame, ['size', size],
                                 ['color', color], ['compound', align])
                      }),
         TkButton.new(frame, :text=>'',
                      :image=>$image['view'], :compound=>:left,
                      :command=>proc{showCode 'radio3'}),
         TkButton.new(frame, :text=>'',
                      :image=>$image['delete'], :compound=>:left,
                      :command=>proc{
                        tmppath = $radio3_demo
                        $radio3_demo = nil
                        $showVarsWin[tmppath.path] = nil
                        tmppath.destroy
                      }),
         :padx=>4, :pady=>4)
  frame.grid_columnconfigure(0, :weight=>1)
  TkGrid(frame, :row=>3, :column=>0, :columnspan=>3, :sticky=>'nsew')
}

# frame
f_left  = TkLabelFrame.new(base_frame, 'text'=>'',
                           'pady'=>2, 'padx'=>2)
f_mid   = TkLabelFrame.new(base_frame, 'text'=>'',
                           'pady'=>2, 'padx'=>2)
f_right = TkLabelFrame.new(base_frame, 'text'=>'',
                           'pady'=>2, 'padx'=>2)
f_left .grid('column'=>0, 'row'=>1, 'pady'=>'.5c', 'padx'=>'.5c', 'rowspan'=>2)
f_mid  .grid('column'=>1, 'row'=>1, 'pady'=>'.5c', 'padx'=>'.5c', 'rowspan'=>2)
f_right.grid('column'=>2, 'row'=>1, 'pady'=>'.5c', 'padx'=>'.5c')

TkButton.new(base_frame, 'text'=>'',
             'command'=>proc{size.value = 'multi'; color.value = 'multi'}){
  grid('column'=>2, 'row'=>2, 'pady'=>'.5c', 'padx'=>'.5c')
}

# radiobutton
[10, 12, 14, 18, 24].each {|sz|
  TkRadioButton.new(f_left) {
    text " #{sz}"
    variable size
    relief 'flat'
    value sz
    tristatevalue 'multi'
  }.pack('side'=>'top', 'pady'=>2, 'anchor'=>'w', 'fill'=>'x')
}

['Red', 'Green', 'Blue', 'Yellow', 'Orange', 'Purple'].each {|col|
  TkRadioButton.new(f_mid) {
    text col
    variable color
    relief 'flat'
    value col.downcase
    anchor 'w'
    tristatevalue 'multi'
    command proc{f_mid.fg(color.value)}
  }.pack('side'=>'top', 'pady'=>2, 'fill'=>'x')
}

# label = TkLabel.new(f_right, 'text'=>'', 'bitmap'=>'questhead',
label = Tk::Label.new(f_right, 'text'=>'', 'bitmap'=>'questhead',
                    'compound'=>'left')
label.configure('width'=>TkWinfo.reqwidth(label), 'compound'=>'top')
label.height(TkWinfo.reqheight(label))
a_btn = ['Top', 'Left', 'Right', 'Bottom'].collect{|a|
  TkRadioButton.new(f_right, 'text'=>a, 'variable'=>align, 'relief'=>'flat',
                    'value'=>a.downcase, 'indicatoron'=>0, 'width'=>7,
                    'command'=>proc{label.compound(align.value)})
}

Tk.grid('x', a_btn[0])
Tk.grid(a_btn[1], label, a_btn[2])
Tk.grid('x', a_btn[3])
require File.dirname(__FILE__) + '/../spec_helper'

describe Module do
  describe '#class_name' do
    it "should return just the name of the class/module" do
      YARD::CodeObjects::Base.class_name.should == "Base"
    end
  end
  
  describe '#namespace' do
    it "should return everything before the class name" do
      YARD::CodeObjects::Base.namespace_name.should == "YARD::CodeObjects"
    end
  end
endrequire 'rexml/child'
require 'rexml/source'
require 'rexml/xmltokens'

module REXML
	# God, I hate DTDs.  I really do.  Why this idiot standard still
	# plagues us is beyond me.
	class Entity < Child
		include XMLTokens
		PUBIDCHAR = "\x20\x0D\x0Aa-zA-Z0-9\\-()+,./:=?;!*@$_%#"
		SYSTEMLITERAL = %Q{((?:"[^"]*")|(?:'[^']*'))}
		PUBIDLITERAL = %Q{("[#{PUBIDCHAR}']*"|'[#{PUBIDCHAR}]*')}
		EXTERNALID = "(?:(?:(SYSTEM)\\s+#{SYSTEMLITERAL})|(?:(PUBLIC)\\s+#{PUBIDLITERAL}\\s+#{SYSTEMLITERAL}))"
		NDATADECL = "\\s+NDATA\\s+#{NAME}"
		PEREFERENCE = "%#{NAME};"
		ENTITYVALUE = %Q{((?:"(?:[^%&"]|#{PEREFERENCE}|#{REFERENCE})*")|(?:'([^%&']|#{PEREFERENCE}|#{REFERENCE})*'))}
		PEDEF = "(?:#{ENTITYVALUE}|#{EXTERNALID})"
		ENTITYDEF = "(?:#{ENTITYVALUE}|(?:#{EXTERNALID}(#{NDATADECL})?))"
		PEDECL = "<!ENTITY\\s+(%)\\s+#{NAME}\\s+#{PEDEF}\\s*>"
		GEDECL = "<!ENTITY\\s+#{NAME}\\s+#{ENTITYDEF}\\s*>"
		ENTITYDECL = /\s*(?:#{GEDECL})|(?:#{PEDECL})/um

		attr_reader :name, :external, :ref, :ndata, :pubid

		# Create a new entity.  Simple entities can be constructed by passing a
		# name, value to the constructor; this creates a generic, plain entity
		# reference. For anything more complicated, you have to pass a Source to
		# the constructor with the entity definiton, or use the accessor methods.
		# +WARNING+: There is no validation of entity state except when the entity
		# is read from a stream.  If you start poking around with the accessors,
		# you can easily create a non-conformant Entity.  The best thing to do is
		# dump the stupid DTDs and use XMLSchema instead.
		# 
		#  e = Entity.new( 'amp', '&' )
		def initialize stream, value=nil, parent=nil, reference=false
			super(parent)
			@ndata = @pubid = @value = @external = nil
			if stream.kind_of? Array
				@name = stream[1]
				if stream[-1] == '%'
					@reference = true 
					stream.pop
				else
					@reference = false
				end
				if stream[2] =~ /SYSTEM|PUBLIC/
					@external = stream[2]
					if @external == 'SYSTEM'
						@ref = stream[3]
						@ndata = stream[4] if stream.size == 5
					else
						@pubid = stream[3]
						@ref = stream[4]
					end
				else
					@value = stream[2]
				end
			else
				@reference = reference
				@external = nil
				@name = stream
				@value = value
			end
		end

		# Evaluates whether the given string matchs an entity definition,
		# returning true if so, and false otherwise.
		def Entity::matches? string
			(ENTITYDECL =~ string) == 0
		end

		# Evaluates to the unnormalized value of this entity; that is, replacing
		# all entities -- both %ent; and &ent; entities.  This differs from
		# +value()+ in that +value+ only replaces %ent; entities.
		def unnormalized
                        document.record_entity_expansion unless document.nil?
			v = value()
			return nil if v.nil?
			@unnormalized = Text::unnormalize(v, parent)
			@unnormalized
		end

		#once :unnormalized

		# Returns the value of this entity unprocessed -- raw.  This is the
		# normalized value; that is, with all %ent; and &ent; entities intact
		def normalized
			@value
		end

		# Write out a fully formed, correct entity definition (assuming the Entity
		# object itself is valid.)
    #
    # out::
    #   An object implementing <TT>&lt;&lt;<TT> to which the entity will be
    #   output
    # indent::
    #   *DEPRECATED* and ignored
		def write out, indent=-1
			out << '<!ENTITY '
			out << '% ' if @reference
			out << @name
			out << ' '
			if @external
				out << @external << ' '
				if @pubid
					q = @pubid.include?('"')?"'":'"'
					out << q << @pubid << q << ' '
				end
				q = @ref.include?('"')?"'":'"'
				out << q << @ref << q
				out << ' NDATA ' << @ndata if @ndata
			else
				q = @value.include?('"')?"'":'"'
				out << q << @value << q
			end
			out << '>'
		end

		# Returns this entity as a string.  See write().
		def to_s
			rv = ''
			write rv
			rv
		end

		PEREFERENCE_RE = /#{PEREFERENCE}/um
		# Returns the value of this entity.  At the moment, only internal entities
		# are processed.  If the value contains internal references (IE,
		# %blah;), those are replaced with their values.  IE, if the doctype
		# contains:
		#  <!ENTITY % foo "bar">
		#  <!ENTITY yada "nanoo %foo; nanoo>
		# then:
		#  doctype.entity('yada').value   #-> "nanoo bar nanoo"
		def value
			if @value
				matches = @value.scan(PEREFERENCE_RE)
				rv = @value.clone
				if @parent
					matches.each do |entity_reference|
						entity_value = @parent.entity( entity_reference[0] )
						rv.gsub!( /%#{entity_reference};/um, entity_value )
					end
				end
				return rv
			end
			nil
		end
	end

	# This is a set of entity constants -- the ones defined in the XML
	# specification.  These are +gt+, +lt+, +amp+, +quot+ and +apos+.
	module EntityConst
		# +>+
		GT = Entity.new( 'gt', '>' )
		# +<+
		LT = Entity.new( 'lt', '<' )
		# +&+
		AMP = Entity.new( 'amp', '&' )
		# +"+
		QUOT = Entity.new( 'quot', '"' )
		# +'+
		APOS = Entity.new( 'apos', "'" )
	end
end
#
#  tkextlib/bwidget/selectfont.rb
#                               by Hidetoshi NAGAI (nagai@ai.kyutech.ac.jp)
#

require 'tk'
require 'tkextlib/bwidget.rb'
require 'tkextlib/bwidget/messagedlg'

module Tk
  module BWidget
    class SelectFont < Tk::BWidget::MessageDlg
      class Dialog < Tk::BWidget::SelectFont
      end
      class Toolbar < TkWindow
      end
    end
  end
end

class Tk::BWidget::SelectFont
  extend Tk

  TkCommandNames = ['SelectFont'.freeze].freeze
  WidgetClassName = 'SelectFont'.freeze
  WidgetClassNames[WidgetClassName] ||= self

  def __strval_optkeys
    super() << 'sampletext' <<  'title'
  end
  private :__strval_optkeys

  def __boolval_optkeys
    super() << 'nosizes'
  end
  private :__boolval_optkeys

  def __font_optkeys
    [] # without fontobj operation
  end
  private :__font_optkeys

  def create
    tk_call(self.class::TkCommandNames[0], @path, *hash_kv(@keys))
  end

  def self.load_font
    tk_call('SelectFont::loadfont')
  end
end

class Tk::BWidget::SelectFont::Dialog
  def __font_optkeys
    [] # without fontobj operation
  end

  def create_self(keys)
    super(keys)
    @keys['type'] = 'dialog'
  end

  def configure(slot, value=None)
    if slot.kind_of?(Hash)
      slot.delete['type']
      slot.delete[:type]
      return self if slot.empty?
    else
      return self if slot == 'type' || slot == :type
    end
    super(slot, value)
  end

  def create
    @keys['type'] = 'dialog'  # 'dialog' type returns font name
    tk_call(Tk::BWidget::SelectFont::TkCommandNames[0], @path, *hash_kv(@keys))
  end
end

class Tk::BWidget::SelectFont::Toolbar
  def __font_optkeys
    [] # without fontobj operation
  end

  def create_self(keys)
    keys = {} unless keys
    keys = _symbolkey2str(keys)
    keys['type'] = 'toolbar'  # 'toolbar' type returns widget path
    window(tk_call(Tk::BWidget::SelectFont::TkCommandNames[0],
                   @path, *hash_kv(keys)))
  end
end
module TZInfo
  module Definitions
    module America
      module New_York
        include TimezoneDefinition
        
        timezone 'America/New_York' do |tz|
          tz.offset :o0, -17762, 0, :LMT
          tz.offset :o1, -18000, 0, :EST
          tz.offset :o2, -18000, 3600, :EDT
          tz.offset :o3, -18000, 3600, :EWT
          tz.offset :o4, -18000, 3600, :EPT
          
          tz.transition 1883, 11, :o1, 57819197, 24
          tz.transition 1918, 3, :o2, 58120411, 24
          tz.transition 1918, 10, :o1, 9687575, 4
          tz.transition 1919, 3, :o2, 58129147, 24
          tz.transition 1919, 10, :o1, 9689031, 4
          tz.transition 1920, 3, :o2, 58137883, 24
          tz.transition 1920, 10, :o1, 9690515, 4
          tz.transition 1921, 4, :o2, 58147291, 24
          tz.transition 1921, 9, :o1, 9691831, 4
          tz.transition 1922, 4, :o2, 58156195, 24
          tz.transition 1922, 9, :o1, 9693287, 4
          tz.transition 1923, 4, :o2, 58164931, 24
          tz.transition 1923, 9, :o1, 9694771, 4
          tz.transition 1924, 4, :o2, 58173667, 24
          tz.transition 1924, 9, :o1, 9696227, 4
          tz.transition 1925, 4, :o2, 58182403, 24
          tz.transition 1925, 9, :o1, 9697683, 4
          tz.transition 1926, 4, :o2, 58191139, 24
          tz.transition 1926, 9, :o1, 9699139, 4
          tz.transition 1927, 4, :o2, 58199875, 24
          tz.transition 1927, 9, :o1, 9700595, 4
          tz.transition 1928, 4, :o2, 58208779, 24
          tz.transition 1928, 9, :o1, 9702079, 4
          tz.transition 1929, 4, :o2, 58217515, 24
          tz.transition 1929, 9, :o1, 9703535, 4
          tz.transition 1930, 4, :o2, 58226251, 24
          tz.transition 1930, 9, :o1, 9704991, 4
          tz.transition 1931, 4, :o2, 58234987, 24
          tz.transition 1931, 9, :o1, 9706447, 4
          tz.transition 1932, 4, :o2, 58243723, 24
          tz.transition 1932, 9, :o1, 9707903, 4
          tz.transition 1933, 4, :o2, 58252627, 24
          tz.transition 1933, 9, :o1, 9709359, 4
          tz.transition 1934, 4, :o2, 58261363, 24
          tz.transition 1934, 9, :o1, 9710843, 4
          tz.transition 1935, 4, :o2, 58270099, 24
          tz.transition 1935, 9, :o1, 9712299, 4
          tz.transition 1936, 4, :o2, 58278835, 24
          tz.transition 1936, 9, :o1, 9713755, 4
          tz.transition 1937, 4, :o2, 58287571, 24
          tz.transition 1937, 9, :o1, 9715211, 4
          tz.transition 1938, 4, :o2, 58296307, 24
          tz.transition 1938, 9, :o1, 9716667, 4
          tz.transition 1939, 4, :o2, 58305211, 24
          tz.transition 1939, 9, :o1, 9718123, 4
          tz.transition 1940, 4, :o2, 58313947, 24
          tz.transition 1940, 9, :o1, 9719607, 4
          tz.transition 1941, 4, :o2, 58322683, 24
          tz.transition 1941, 9, :o1, 9721063, 4
          tz.transition 1942, 2, :o3, 58329595, 24
          tz.transition 1945, 8, :o4, 58360379, 24
          tz.transition 1945, 9, :o1, 9726915, 4
          tz.transition 1946, 4, :o2, 58366531, 24
          tz.transition 1946, 9, :o1, 9728371, 4
          tz.transition 1947, 4, :o2, 58375267, 24
          tz.transition 1947, 9, :o1, 9729827, 4
          tz.transition 1948, 4, :o2, 58384003, 24
          tz.transition 1948, 9, :o1, 9731283, 4
          tz.transition 1949, 4, :o2, 58392739, 24
          tz.transition 1949, 9, :o1, 9732739, 4
          tz.transition 1950, 4, :o2, 58401643, 24
          tz.transition 1950, 9, :o1, 9734195, 4
          tz.transition 1951, 4, :o2, 58410379, 24
          tz.transition 1951, 9, :o1, 9735679, 4
          tz.transition 1952, 4, :o2, 58419115, 24
          tz.transition 1952, 9, :o1, 9737135, 4
          tz.transition 1953, 4, :o2, 58427851, 24
          tz.transition 1953, 9, :o1, 9738591, 4
          tz.transition 1954, 4, :o2, 58436587, 24
          tz.transition 1954, 9, :o1, 9740047, 4
          tz.transition 1955, 4, :o2, 58445323, 24
          tz.transition 1955, 10, :o1, 9741643, 4
          tz.transition 1956, 4, :o2, 58454227, 24
          tz.transition 1956, 10, :o1, 9743099, 4
          tz.transition 1957, 4, :o2, 58462963, 24
          tz.transition 1957, 10, :o1, 9744555, 4
          tz.transition 1958, 4, :o2, 58471699, 24
          tz.transition 1958, 10, :o1, 9746011, 4
          tz.transition 1959, 4, :o2, 58480435, 24
          tz.transition 1959, 10, :o1, 9747467, 4
          tz.transition 1960, 4, :o2, 58489171, 24
          tz.transition 1960, 10, :o1, 9748951, 4
          tz.transition 1961, 4, :o2, 58498075, 24
          tz.transition 1961, 10, :o1, 9750407, 4
          tz.transition 1962, 4, :o2, 58506811, 24
          tz.transition 1962, 10, :o1, 9751863, 4
          tz.transition 1963, 4, :o2, 58515547, 24
          tz.transition 1963, 10, :o1, 9753319, 4
          tz.transition 1964, 4, :o2, 58524283, 24
          tz.transition 1964, 10, :o1, 9754775, 4
          tz.transition 1965, 4, :o2, 58533019, 24
          tz.transition 1965, 10, :o1, 9756259, 4
          tz.transition 1966, 4, :o2, 58541755, 24
          tz.transition 1966, 10, :o1, 9757715, 4
          tz.transition 1967, 4, :o2, 58550659, 24
          tz.transition 1967, 10, :o1, 9759171, 4
          tz.transition 1968, 4, :o2, 58559395, 24
          tz.transition 1968, 10, :o1, 9760627, 4
          tz.transition 1969, 4, :o2, 58568131, 24
          tz.transition 1969, 10, :o1, 9762083, 4
          tz.transition 1970, 4, :o2, 9961200
          tz.transition 1970, 10, :o1, 25682400
          tz.transition 1971, 4, :o2, 41410800
          tz.transition 1971, 10, :o1, 57736800
          tz.transition 1972, 4, :o2, 73465200
          tz.transition 1972, 10, :o1, 89186400
          tz.transition 1973, 4, :o2, 104914800
          tz.transition 1973, 10, :o1, 120636000
          tz.transition 1974, 1, :o2, 126687600
          tz.transition 1974, 10, :o1, 152085600
          tz.transition 1975, 2, :o2, 162370800
          tz.transition 1975, 10, :o1, 183535200
          tz.transition 1976, 4, :o2, 199263600
          tz.transition 1976, 10, :o1, 215589600
          tz.transition 1977, 4, :o2, 230713200
          tz.transition 1977, 10, :o1, 247039200
          tz.transition 1978, 4, :o2, 262767600
          tz.transition 1978, 10, :o1, 278488800
          tz.transition 1979, 4, :o2, 294217200
          tz.transition 1979, 10, :o1, 309938400
          tz.transition 1980, 4, :o2, 325666800
          tz.transition 1980, 10, :o1, 341388000
          tz.transition 1981, 4, :o2, 357116400
          tz.transition 1981, 10, :o1, 372837600
          tz.transition 1982, 4, :o2, 388566000
          tz.transition 1982, 10, :o1, 404892000
          tz.transition 1983, 4, :o2, 420015600
          tz.transition 1983, 10, :o1, 436341600
          tz.transition 1984, 4, :o2, 452070000
          tz.transition 1984, 10, :o1, 467791200
          tz.transition 1985, 4, :o2, 483519600
          tz.transition 1985, 10, :o1, 499240800
          tz.transition 1986, 4, :o2, 514969200
          tz.transition 1986, 10, :o1, 530690400
          tz.transition 1987, 4, :o2, 544604400
          tz.transition 1987, 10, :o1, 562140000
          tz.transition 1988, 4, :o2, 576054000
          tz.transition 1988, 10, :o1, 594194400
          tz.transition 1989, 4, :o2, 607503600
          tz.transition 1989, 10, :o1, 625644000
          tz.transition 1990, 4, :o2, 638953200
          tz.transition 1990, 10, :o1, 657093600
          tz.transition 1991, 4, :o2, 671007600
          tz.transition 1991, 10, :o1, 688543200
          tz.transition 1992, 4, :o2, 702457200
          tz.transition 1992, 10, :o1, 719992800
          tz.transition 1993, 4, :o2, 733906800
          tz.transition 1993, 10, :o1, 752047200
          tz.transition 1994, 4, :o2, 765356400
          tz.transition 1994, 10, :o1, 783496800
          tz.transition 1995, 4, :o2, 796806000
          tz.transition 1995, 10, :o1, 814946400
          tz.transition 1996, 4, :o2, 828860400
          tz.transition 1996, 10, :o1, 846396000
          tz.transition 1997, 4, :o2, 860310000
          tz.transition 1997, 10, :o1, 877845600
          tz.transition 1998, 4, :o2, 891759600
          tz.transition 1998, 10, :o1, 909295200
          tz.transition 1999, 4, :o2, 923209200
          tz.transition 1999, 10, :o1, 941349600
          tz.transition 2000, 4, :o2, 954658800
          tz.transition 2000, 10, :o1, 972799200
          tz.transition 2001, 4, :o2, 986108400
          tz.transition 2001, 10, :o1, 1004248800
          tz.transition 2002, 4, :o2, 1018162800
          tz.transition 2002, 10, :o1, 1035698400
          tz.transition 2003, 4, :o2, 1049612400
          tz.transition 2003, 10, :o1, 1067148000
          tz.transition 2004, 4, :o2, 1081062000
          tz.transition 2004, 10, :o1, 1099202400
          tz.transition 2005, 4, :o2, 1112511600
          tz.transition 2005, 10, :o1, 1130652000
          tz.transition 2006, 4, :o2, 1143961200
          tz.transition 2006, 10, :o1, 1162101600
          tz.transition 2007, 3, :o2, 1173596400
          tz.transition 2007, 11, :o1, 1194156000
          tz.transition 2008, 3, :o2, 1205046000
          tz.transition 2008, 11, :o1, 1225605600
          tz.transition 2009, 3, :o2, 1236495600
          tz.transition 2009, 11, :o1, 1257055200
          tz.transition 2010, 3, :o2, 1268550000
          tz.transition 2010, 11, :o1, 1289109600
          tz.transition 2011, 3, :o2, 1299999600
          tz.transition 2011, 11, :o1, 1320559200
          tz.transition 2012, 3, :o2, 1331449200
          tz.transition 2012, 11, :o1, 1352008800
          tz.transition 2013, 3, :o2, 1362898800
          tz.transition 2013, 11, :o1, 1383458400
          tz.transition 2014, 3, :o2, 1394348400
          tz.transition 2014, 11, :o1, 1414908000
          tz.transition 2015, 3, :o2, 1425798000
          tz.transition 2015, 11, :o1, 1446357600
          tz.transition 2016, 3, :o2, 1457852400
          tz.transition 2016, 11, :o1, 1478412000
          tz.transition 2017, 3, :o2, 1489302000
          tz.transition 2017, 11, :o1, 1509861600
          tz.transition 2018, 3, :o2, 1520751600
          tz.transition 2018, 11, :o1, 1541311200
          tz.transition 2019, 3, :o2, 1552201200
          tz.transition 2019, 11, :o1, 1572760800
          tz.transition 2020, 3, :o2, 1583650800
          tz.transition 2020, 11, :o1, 1604210400
          tz.transition 2021, 3, :o2, 1615705200
          tz.transition 2021, 11, :o1, 1636264800
          tz.transition 2022, 3, :o2, 1647154800
          tz.transition 2022, 11, :o1, 1667714400
          tz.transition 2023, 3, :o2, 1678604400
          tz.transition 2023, 11, :o1, 1699164000
          tz.transition 2024, 3, :o2, 1710054000
          tz.transition 2024, 11, :o1, 1730613600
          tz.transition 2025, 3, :o2, 1741503600
          tz.transition 2025, 11, :o1, 1762063200
          tz.transition 2026, 3, :o2, 1772953200
          tz.transition 2026, 11, :o1, 1793512800
          tz.transition 2027, 3, :o2, 1805007600
          tz.transition 2027, 11, :o1, 1825567200
          tz.transition 2028, 3, :o2, 1836457200
          tz.transition 2028, 11, :o1, 1857016800
          tz.transition 2029, 3, :o2, 1867906800
          tz.transition 2029, 11, :o1, 1888466400
          tz.transition 2030, 3, :o2, 1899356400
          tz.transition 2030, 11, :o1, 1919916000
          tz.transition 2031, 3, :o2, 1930806000
          tz.transition 2031, 11, :o1, 1951365600
          tz.transition 2032, 3, :o2, 1962860400
          tz.transition 2032, 11, :o1, 1983420000
          tz.transition 2033, 3, :o2, 1994310000
          tz.transition 2033, 11, :o1, 2014869600
          tz.transition 2034, 3, :o2, 2025759600
          tz.transition 2034, 11, :o1, 2046319200
          tz.transition 2035, 3, :o2, 2057209200
          tz.transition 2035, 11, :o1, 2077768800
          tz.transition 2036, 3, :o2, 2088658800
          tz.transition 2036, 11, :o1, 2109218400
          tz.transition 2037, 3, :o2, 2120108400
          tz.transition 2037, 11, :o1, 2140668000
          tz.transition 2038, 3, :o2, 59171923, 24
          tz.transition 2038, 11, :o1, 9862939, 4
          tz.transition 2039, 3, :o2, 59180659, 24
          tz.transition 2039, 11, :o1, 9864395, 4
          tz.transition 2040, 3, :o2, 59189395, 24
          tz.transition 2040, 11, :o1, 9865851, 4
          tz.transition 2041, 3, :o2, 59198131, 24
          tz.transition 2041, 11, :o1, 9867307, 4
          tz.transition 2042, 3, :o2, 59206867, 24
          tz.transition 2042, 11, :o1, 9868763, 4
          tz.transition 2043, 3, :o2, 59215603, 24
          tz.transition 2043, 11, :o1, 9870219, 4
          tz.transition 2044, 3, :o2, 59224507, 24
          tz.transition 2044, 11, :o1, 9871703, 4
          tz.transition 2045, 3, :o2, 59233243, 24
          tz.transition 2045, 11, :o1, 9873159, 4
          tz.transition 2046, 3, :o2, 59241979, 24
          tz.transition 2046, 11, :o1, 9874615, 4
          tz.transition 2047, 3, :o2, 59250715, 24
          tz.transition 2047, 11, :o1, 9876071, 4
          tz.transition 2048, 3, :o2, 59259451, 24
          tz.transition 2048, 11, :o1, 9877527, 4
          tz.transition 2049, 3, :o2, 59268355, 24
          tz.transition 2049, 11, :o1, 9879011, 4
          tz.transition 2050, 3, :o2, 59277091, 24
          tz.transition 2050, 11, :o1, 9880467, 4
        end
      end
    end
  end
end
#
#   version.rb - shell version definition file
#   	$Release Version: 0.7$
#   	$Revision: 25189 $
#   	by Keiju ISHITSUKA(keiju@ruby-lang.org)
#
# --
#
#
#

class Shell
  @RELEASE_VERSION = "0.7"
  @LAST_UPDATE_DATE = "07/03/20"
end
require 'term/ansicolor'

# Use this trick to work around namespace cluttering that
# happens if you just include Term::ANSIColor:

class Color
  extend Term::ANSIColor
end

print Color.red, Color.bold, "No Namespace cluttering:", Color.clear, "\n"
print Color.green + "green" + Color.clear, "\n"
print Color.on_red(Color.green("green")), "\n"
print Color.yellow { Color.on_black { "yellow on_black" } }, "\n\n"

# Or shortcut Term::ANSIColor by assignment:
c = Term::ANSIColor

print c.red, c.bold, "No Namespace cluttering (alternative):", c.clear, "\n"
print c.green + "green" + c.clear, "\n"
print c.on_red(c.green("green")), "\n"
print c.yellow { c.on_black { "yellow on_black" } }, "\n\n"

# Anyway, I don't define any of Term::ANSIColor's methods in this example
# and I want to keep it short:
include Term::ANSIColor

print red, bold, "Usage as constants:", reset, "\n"
print clear, "clear", reset, reset, "reset", reset,
  bold, "bold", reset, dark, "dark", reset,
  underscore, "underscore", reset, blink, "blink", reset,
  negative, "negative", reset, concealed, "concealed", reset, "|\n",
  black, "black", reset, red, "red", reset, green, "green", reset,
  yellow, "yellow", reset, blue, "blue", reset, magenta, "magenta", reset,
  cyan, "cyan", reset, white, "white", reset, "|\n",
  on_black, "on_black", reset, on_red, "on_red", reset,
  on_green, "on_green", reset, on_yellow, "on_yellow", reset,
  on_blue, "on_blue", reset, on_magenta, "on_magenta", reset,
  on_cyan, "on_cyan", reset, on_white, "on_white", reset, "|\n\n"

print red, bold, "Usage as unary argument methods:", reset, "\n"
print clear("clear"), reset("reset"), bold("bold"), dark("dark"),
  underscore("underscore"), blink("blink"), negative("negative"),
  concealed("concealed"), "|\n",
  black("black"), red("red"), green("green"), yellow("yellow"),
  blue("blue"), magenta("magenta"), cyan("cyan"), white("white"), "|\n",
  on_black("on_black"), on_red("on_red"), on_green("on_green"),#
  on_yellow("on_yellow"), on_blue("on_blue"), on_magenta("on_magenta"),
  on_cyan("on_cyan"), on_white("on_white"), "|\n\n"

print red { bold { "Usage as block forms:" } }, "\n"
print clear { "clear" }, reset { "reset" }, bold { "bold" },
  dark { "dark" }, underscore { "underscore" }, blink { "blink" },
  negative { "negative" }, concealed { "concealed" }, "|\n",
  black { "black" }, red { "red" }, green { "green" },
  yellow { "yellow" }, blue { "blue" }, magenta { "magenta" },
  cyan { "cyan" }, white { "white" }, "|\n",
  on_black { "on_black" }, on_red { "on_red" }, on_green { "on_green" },
  on_yellow { "on_yellow" }, on_blue { "on_blue" },
  on_magenta { "on_magenta" }, on_cyan { "on_cyan" },
  on_white { "on_white" }, "|\n\n"

# Usage as Mixin into String or its Subclasses
class String
  include Term::ANSIColor
end

print "Usage as String Mixins:".red.bold, "\n"
print "clear".clear, "reset".reset, "bold".bold, "dark".dark,
  "underscore".underscore, "blink".blink, "negative".negative,
  "concealed".concealed, "|\n",
  "black".black, "red".red, "green".green, "yellow".yellow,
  "blue".blue, "magenta".magenta, "cyan".cyan, "white".white, "|\n",
  "on_black".on_black, "on_red".on_red, "on_green".on_green,
  "on_yellow".on_yellow, "on_blue".on_blue, "on_magenta".on_magenta,
  "on_cyan".on_cyan, "on_white".on_white, "|\n\n"

symbols = Term::ANSIColor::attributes
print red { bold { "All supported attributes = " } },
  blue { symbols.inspect }, "\n\n"

print "Send symbols to strings:".send(:red).send(:bold), "\n"
print symbols[12, 8].map { |c| c.to_s.send(c) }, "\n\n"

print red { bold { "Make strings monochromatic again:" } }, "\n"
print [
    "red".red,
    "not red anymore".red.uncolored,
    uncolored { "not red anymore".red },
    uncolored("not red anymore".red)
  ].map { |x| x + "\n" }
platform_is :windows do
  require 'win32ole'

  describe 'WIN32OLE_TYPE#helpfile for Shell Controls' do
    before :each do
      @ole_type = WIN32OLE_TYPE.new("Microsoft Shell Controls And Automation", "Shell")
    end

    after :each do
      @ole_type = nil
    end

    it 'returns an empty string' do
      @ole_type.helpfile.should be_empty
    end

  end
endmodule Sass
  module CacheStores
    # A backend for the Sass cache using the filesystem.
    class Filesystem < Base
      # The directory where the cached files will be stored.
      #
      # @return [String]
      attr_accessor :cache_location

      # @param cache_location [String] see \{#cache\_location}
      def initialize(cache_location)
        @cache_location = cache_location
      end

      # @see Base#\_retrieve
      def _retrieve(key, version, sha)
        return unless File.readable?(path_to(key))
        contents = nil
        File.open(path_to(key), "rb") do |f|
          if f.readline("\n").strip == version && f.readline("\n").strip == sha
            return f.read
          end
        end
        File.unlink path_to(key)
        nil
      rescue EOFError, TypeError, ArgumentError => e
        Sass::Util.sass_warn "Warning. Error encountered while reading cache #{path_to(key)}: #{e}"
      end

      # @see Base#\_store
      def _store(key, version, sha, contents)
        return unless File.writable?(File.dirname(@cache_location))
        return if File.exists?(@cache_location) && !File.writable?(@cache_location)
        compiled_filename = path_to(key)
        return if File.exists?(File.dirname(compiled_filename)) && !File.writable?(File.dirname(compiled_filename))
        return if File.exists?(compiled_filename) && !File.writable?(compiled_filename)
        FileUtils.mkdir_p(File.dirname(compiled_filename))
        File.open(compiled_filename, "wb") do |f|
          f.puts(version)
          f.puts(sha)
          f.write(contents)
        end
      end

      private

      # Returns the path to a file for the given key.
      #
      # @param key [String]
      # @return [String] The path to the cache file.
      def path_to(key)
        File.join(cache_location, key)
      end
    end
  end
end
#
#  TkImg - format 'pixmap'
#                               by Hidetoshi NAGAI (nagai@ai.kyutech.ac.jp)
#
require 'tk'

# call setup script for general 'tkextlib' libraries
require 'tkextlib/setup.rb'

# call setup script
require 'tkextlib/tkimg/setup.rb'

# TkPackage.require('img::pixmap', '1.3')
TkPackage.require('img::pixmap')

module Tk
  module Img
    module PIXMAP
      PACKAGE_NAME = 'img::pixmap'.freeze
      def self.package_name
        PACKAGE_NAME
      end

      def self.package_version
        begin
          TkPackage.require('img::pixmap')
        rescue
          ''
        end
      end
    end
  end
end

class TkPixmapImage<TkImage
  def self.version
    Tk::Img::PIXMAP.version
  end

  def initialize(*args)
    @type = 'pixmap'
    super(*args)
  end
end
#
#  tkextlib/tcllib/canvas.rb
#                               by Hidetoshi NAGAI (nagai@ai.kyutech.ac.jp)
#
#   * Part of tcllib extension
#   * 
#

require 'tk'
require 'tkextlib/tcllib.rb'

# TkPackage.require('widget::canvas_sqmap', '0.2')
TkPackage.require('widget::canvas_sqmap')

module Tk::Tcllib
  module Widget
    class Canvas_Sqmap < Canvas
      TkCommandNames = ['::widget::canvas_sqmap'.freeze].freeze

      def image_set(cell, img)
        tk_send('image', 'set', cell, img)
        self
      end

      def image_unset(cell)
        tk_send('image', 'unset', cell)
        self
      end

      def flush
        tk_send('flush')
        self
      end
    end
  end
end
require 'rexml/parsers/baseparser'
require 'rexml/parseexception'
require 'rexml/namespace'
require 'rexml/text'

module REXML
	module Parsers
    # SAX2Parser
		class SAX2Parser
			def initialize source
				@parser = BaseParser.new(source)
				@listeners = []
				@procs = []
				@namespace_stack = []
				@has_listeners = false
				@tag_stack = []
        @entities = {}
			end

      def source
        @parser.source
      end
			
      def add_listener( listener )
        @parser.add_listener( listener )
      end

			# Listen arguments:
			#
			# Symbol, Array, Block
			# 	Listen to Symbol events on Array elements
			# Symbol, Block
			#   Listen to Symbol events
			# Array, Listener
			# 	Listen to all events on Array elements
			# Array, Block
			# 	Listen to :start_element events on Array elements
			# Listener
			# 	Listen to All events
			#
			# Symbol can be one of: :start_element, :end_element,
			# :start_prefix_mapping, :end_prefix_mapping, :characters,
			# :processing_instruction, :doctype, :attlistdecl, :elementdecl,
			# :entitydecl, :notationdecl, :cdata, :xmldecl, :comment
      #
      # There is an additional symbol that can be listened for: :progress.
      # This will be called for every event generated, passing in the current 
      # stream position.
			#
			# Array contains regular expressions or strings which will be matched
			# against fully qualified element names.
			#
			# Listener must implement the methods in SAX2Listener
			#
			# Block will be passed the same arguments as a SAX2Listener method would
			# be, where the method name is the same as the matched Symbol.
			# See the SAX2Listener for more information.
			def listen( *args, &blok )
				if args[0].kind_of? Symbol
					if args.size == 2
						args[1].each { |match| @procs << [args[0], match, blok] }
					else
						add( [args[0], nil, blok] )
					end
				elsif args[0].kind_of? Array
					if args.size == 2
						args[0].each { |match| add( [nil, match, args[1]] ) }
					else
						args[0].each { |match| add( [ :start_element, match, blok ] ) }
					end
				else
					add([nil, nil, args[0]])
				end
			end
			
			def deafen( listener=nil, &blok )
				if listener
					@listeners.delete_if {|item| item[-1] == listener }
					@has_listeners = false if @listeners.size == 0
				else
					@procs.delete_if {|item| item[-1] == blok }
				end
			end
			
			def parse
				@procs.each { |sym,match,block| block.call if sym == :start_document }
				@listeners.each { |sym,match,block| 
					block.start_document if sym == :start_document or sym.nil?
				}
				root = context = []
				while true
					event = @parser.pull
					case event[0]
					when :end_document
						handle( :end_document )
						break
          when :start_doctype
            handle( :doctype, *event[1..-1])
					when :end_doctype
						context = context[1]
					when :start_element
						@tag_stack.push(event[1])
						# find the observers for namespaces
						procs = get_procs( :start_prefix_mapping, event[1] )
						listeners = get_listeners( :start_prefix_mapping, event[1] )
						if procs or listeners
							# break out the namespace declarations
							# The attributes live in event[2]
							event[2].each {|n, v| event[2][n] = @parser.normalize(v)}
							nsdecl = event[2].find_all { |n, value| n =~ /^xmlns(:|$)/ }
							nsdecl.collect! { |n, value| [ n[6..-1], value ] }
							@namespace_stack.push({})
							nsdecl.each do |n,v|
								@namespace_stack[-1][n] = v
								# notify observers of namespaces
								procs.each { |ob| ob.call( n, v ) } if procs
								listeners.each { |ob| ob.start_prefix_mapping(n, v) } if listeners
							end
						end
						event[1] =~ Namespace::NAMESPLIT
						prefix = $1
						local = $2
						uri = get_namespace(prefix)
						# find the observers for start_element
						procs = get_procs( :start_element, event[1] )
						listeners = get_listeners( :start_element, event[1] )
						# notify observers
						procs.each { |ob| ob.call( uri, local, event[1], event[2] ) } if procs
						listeners.each { |ob| 
							ob.start_element( uri, local, event[1], event[2] ) 
						} if listeners
					when :end_element
						@tag_stack.pop
						event[1] =~ Namespace::NAMESPLIT
						prefix = $1
						local = $2
						uri = get_namespace(prefix)
						# find the observers for start_element
						procs = get_procs( :end_element, event[1] )
						listeners = get_listeners( :end_element, event[1] )
						# notify observers
						procs.each { |ob| ob.call( uri, local, event[1] ) } if procs
						listeners.each { |ob| 
							ob.end_element( uri, local, event[1] ) 
						} if listeners

						namespace_mapping = @namespace_stack.pop
						# find the observers for namespaces
						procs = get_procs( :end_prefix_mapping, event[1] )
						listeners = get_listeners( :end_prefix_mapping, event[1] )
						if procs or listeners
							namespace_mapping.each do |prefix, uri|
								# notify observers of namespaces
								procs.each { |ob| ob.call( prefix ) } if procs
								listeners.each { |ob| ob.end_prefix_mapping(prefix) } if listeners
							end
						end
					when :text
            #normalized = @parser.normalize( event[1] )
            #handle( :characters, normalized )
            copy = event[1].clone
            @entities.each { |key, value| copy = copy.gsub("&#{key};", value) }
            copy.gsub!( Text::NUMERICENTITY ) {|m|
              m=$1
              m = "0#{m}" if m[0] == ?x
              [Integer(m)].pack('U*')
            }
            handle( :characters, copy )
          when :entitydecl
            @entities[ event[1] ] = event[2] if event.size == 3
						handle( *event )
					when :processing_instruction, :comment, :attlistdecl, 
						:elementdecl, :cdata, :notationdecl, :xmldecl
						handle( *event )
					end
          handle( :progress, @parser.position )
				end
			end

			private
			def handle( symbol, *arguments )
				tag = @tag_stack[-1]
				procs = get_procs( symbol, tag )
				listeners = get_listeners( symbol, tag )
				# notify observers
				procs.each { |ob| ob.call( *arguments ) } if procs
				listeners.each { |l| 
					l.send( symbol.to_s, *arguments ) 
				} if listeners
			end

			# The following methods are duplicates, but it is faster than using
			# a helper
			def get_procs( symbol, name )
				return nil if @procs.size == 0
				@procs.find_all do |sym, match, block|
          #puts sym.inspect+"=="+symbol.inspect+ "\t"+match.inspect+"=="+name.inspect+ "\t"+( (sym.nil? or symbol == sym) and ((name.nil? and match.nil?) or match.nil? or ( (name == match) or (match.kind_of? Regexp and name =~ match)))).to_s
					(
						(sym.nil? or symbol == sym) and 
						((name.nil? and match.nil?) or match.nil? or (
							(name == match) or
							(match.kind_of? Regexp and name =~ match)
							)
						)
					)
				end.collect{|x| x[-1]}
			end
			def get_listeners( symbol, name )
				return nil if @listeners.size == 0
				@listeners.find_all do |sym, match, block|
					(
						(sym.nil? or symbol == sym) and 
						((name.nil? and match.nil?) or match.nil? or (
							(name == match) or
							(match.kind_of? Regexp and name =~ match)
							)
						)
					)
				end.collect{|x| x[-1]}
			end

			def add( pair )
				if pair[-1].respond_to? :call
					@procs << pair unless @procs.include? pair
				else
					@listeners << pair unless @listeners.include? pair
					@has_listeners = true
				end
			end

			def get_namespace( prefix ) 
        uris = (@namespace_stack.find_all { |ns| not ns[prefix].nil? }) ||
					(@namespace_stack.find { |ns| not ns[nil].nil? })
				uris[-1][prefix] unless uris.nil? or 0 == uris.size
			end
		end
	end
end
# encoding: utf-8
module Mongoid # :nodoc:
  module Relations #:nodoc:
    module Cascading #:nodoc:
      class Delete < Strategy

        # Execute the cascading deletion for the relation if it already exists.
        # This should be optimized in the future potentially not to load all
        # objects from the db.
        #
        # @example Perform the cascading delete.
        #   strategy.cascade
        def cascade
          relation.to_a.each { |doc| doc.delete } if relation
        end
      end
    end
  end
end
=begin
= $RCSfile$ -- Buffering mix-in module.

= Info
  'OpenSSL for Ruby 2' project
  Copyright (C) 2001 GOTOU YUUZOU <gotoyuzo@notwork.org>
  All rights reserved.

= Licence
  This program is licenced under the same licence as Ruby.
  (See the file 'LICENCE'.)

= Version
  $Id: buffering.rb 28004 2010-05-24 23:58:49Z shyouhei $
=end

module OpenSSL
module Buffering
  include Enumerable
  attr_accessor :sync
  BLOCK_SIZE = 1024*16

  def initialize(*args)
    @eof = false
    @rbuffer = ""
    @sync = @io.sync
  end

  #
  # for reading.
  #
  private

  def fill_rbuff
    begin
      @rbuffer << self.sysread(BLOCK_SIZE)
    rescue Errno::EAGAIN
      retry
    rescue EOFError
      @eof = true
    end
  end

  def consume_rbuff(size=nil)
    if @rbuffer.empty?
      nil
    else
      size = @rbuffer.size unless size
      ret = @rbuffer[0, size]
      @rbuffer[0, size] = ""
      ret
    end
  end

  public

  def read(size=nil, buf=nil)
    if size == 0
      if buf
        buf.clear
      else
        buf = ""
      end
      return @eof ? nil : buf
    end
    until @eof
      break if size && size <= @rbuffer.size
      fill_rbuff
    end
    ret = consume_rbuff(size) || ""
    if buf
      buf.replace(ret)
      ret = buf
    end
    (size && ret.empty?) ? nil : ret
  end

  def readpartial(maxlen, buf=nil)
    if maxlen == 0
      if buf
        buf.clear
      else
        buf = ""
      end
      return @eof ? nil : buf
    end
    if @rbuffer.empty?
      begin
        return sysread(maxlen, buf)
      rescue Errno::EAGAIN
        retry
      end
    end
    ret = consume_rbuff(maxlen)
    if buf
      buf.replace(ret)
      ret = buf
    end
    raise EOFError if ret.empty?
    ret
  end

  def gets(eol=$/)
    idx = @rbuffer.index(eol)
    until @eof
      break if idx
      fill_rbuff
      idx = @rbuffer.index(eol)
    end
    if eol.is_a?(Regexp)
      size = idx ? idx+$&.size : nil
    else
      size = idx ? idx+eol.size : nil
    end
    consume_rbuff(size)
  end

  def each(eol=$/)
    while line = self.gets(eol)
      yield line
    end
  end
  alias each_line each

  def readlines(eol=$/)
    ary = []
    while line = self.gets(eol)
      ary << line
    end
    ary
  end

  def readline(eol=$/)
    raise EOFError if eof?
    gets(eol)
  end

  def getc
    c = read(1)
    c ? c[0] : nil
  end

  def each_byte
    while c = getc
      yield(c)
    end
  end

  def readchar
    raise EOFError if eof?
    getc
  end

  def ungetc(c)
    @rbuffer[0,0] = c.chr
  end

  def eof?
    fill_rbuff if !@eof && @rbuffer.empty?
    @eof && @rbuffer.empty?
  end
  alias eof eof?

  #
  # for writing.
  #
  private

  def do_write(s)
    @wbuffer = "" unless defined? @wbuffer
    @wbuffer << s
    @sync ||= false
    if @sync or @wbuffer.size > BLOCK_SIZE or idx = @wbuffer.rindex($/)
      remain = idx ? idx + $/.size : @wbuffer.length
      nwritten = 0
      while remain > 0
        str = @wbuffer[nwritten,remain]
        begin
          nwrote = syswrite(str)
        rescue Errno::EAGAIN
          retry
        end
        remain -= nwrote
        nwritten += nwrote
      end
      @wbuffer[0,nwritten] = ""
    end
  end

  public

  def write(s)
    do_write(s)
    s.length
  end

  def << (s)
    do_write(s)
    self
  end

  def puts(*args)
    s = ""
    if args.empty?
      s << "\n"
    end
    args.each{|arg|
      s << arg.to_s
      if $/ && /\n\z/ !~ s
        s << "\n"
      end
    }
    do_write(s)
    nil
  end

  def print(*args)
    s = ""
    args.each{ |arg| s << arg.to_s }
    do_write(s)
    nil
  end

  def printf(s, *args)
    do_write(s % args)
    nil
  end

  def flush
    osync = @sync
    @sync = true
    do_write ""
    @sync = osync
  end

  def close
    flush rescue nil
    sysclose
  end
end
end
module Cucumber
  module Constantize #:nodoc:
    def constantize(camel_cased_word)
      try = 0
      begin
        try += 1
        names = camel_cased_word.split('::')
        names.shift if names.empty? || names.first.empty?

        constant = Object
        names.each do |name|
          constant = constant.const_defined?(name) ? constant.const_get(name) : constant.const_missing(name)
        end
        constant
      rescue NameError => e
        require underscore(camel_cased_word)
        if try < 2
          retry
        else
          raise e
        end
      end
    end

    # Snagged from active_support
    def underscore(camel_cased_word)
      camel_cased_word.to_s.gsub(/::/, '/').
        gsub(/([A-Z]+)([A-Z][a-z])/,'\1_\2').
        gsub(/([a-z\d])([A-Z])/,'\1_\2').
        tr("-", "_").
        downcase
    end
  end
endrequire "spec_helper"

describe Mongoid::Safety do

  describe ".safely" do

    context "default" do
      let(:proxy) do
        Person.safely
      end

      it "returns a safe proxy" do
        proxy.should be_an_instance_of(Mongoid::Safety::Proxy)
      end

      it "proxies the class" do
        proxy.target.should == Person
      end

      it "defaults the safety options to true" do
        proxy.safety_options.should be_true
      end
    end

    context "with options" do
      let(:proxy) { Person.safely(:w => 2) }

      it "returns a safe proxy" do
        proxy.should be_an_instance_of(Mongoid::Safety::Proxy)
      end

      it "proxies the class" do
        proxy.target.should == Person
      end

      it "stores the safety options" do
        proxy.safety_options.should == {:w => 2}
      end
    end
  end

  describe "#safely" do

    let(:person) do
      Person.new
    end

    context "default" do
      let(:proxy) do
        person.safely
      end

      it "returns a safe proxy" do
        proxy.should be_an_instance_of(Mongoid::Safety::Proxy)
      end

      it "proxies the document" do
        proxy.target.should == person
      end

      it "defaults the safety value to true" do
        proxy.safety_options.should be_true
      end
    end

    context "with options" do
      let(:proxy) { person.safely(:w => 2) }

      it "returns a safe proxy" do
        proxy.should be_an_instance_of(Mongoid::Safety::Proxy)
      end

      it "proxies the class" do
        proxy.target.should == person
      end

      it "stores the safety options" do
        proxy.safety_options.should == {:w => 2}
      end
    end
  end

  shared_examples_for 'a safely persisting document instance' do

    describe "#delete" do

      before do
        Mongoid::Persistence::Remove.expects(:new).with(
          person,
          { :safe => safety_options }
        ).returns(command)
        command.expects(:persist).returns(true)
      end

      context "without options provided" do

        it "sends the safe mode option to the command" do
          proxy.delete
        end
      end

      context "with options provided" do

        it "sends the safe mode option to the command" do
          proxy.delete(:safe => true)
        end
      end
    end

    describe "#destroy" do

      before do
        Mongoid::Persistence::Remove.expects(:new).with(
          person,
          { :safe => safety_options }
        ).returns(command)
        command.expects(:persist).returns(true)
      end

      context "without options provided" do

        it "sends the safe mode option to the command" do
          proxy.destroy
        end
      end

      context "with options provided" do

        it "sends the safe mode option to the command" do
          proxy.destroy(:safe => true)
        end
      end
    end

    describe "#inc" do

      before do
        Mongoid::Persistence::Atomic::Inc.expects(:new).with(
          person,
          :age,
          5,
          { :safe => safety_options }
        ).returns(modifier)
        modifier.expects(:persist).returns(true)
      end

      context "without options provided" do

        it "sends the safe mode option to the command" do
          proxy.inc(:age, 5)
        end
      end

      context "with options provided" do

        it "sends the safe mode option to the command" do
          proxy.inc(:age, 5, :safe => true)
        end
      end
    end

    describe "#insert" do

      before do
        Mongoid::Persistence::Insert.expects(:new).with(
          person,
          { :safe => safety_options }
        ).returns(command)
        command.expects(:persist).returns(true)
      end

      context "without options provided" do

        it "sends the safe mode option to the command" do
          proxy.insert
        end
      end

      context "with options provided" do

        it "sends the safe mode option to the command" do
          proxy.insert(:safe => true)
        end
      end
    end

    describe "#save!" do

      before do
        Mongoid::Persistence::Insert.expects(:new).with(
          person,
          { :safe => safety_options }
        ).returns(command)
        command.expects(:persist).returns(true)
      end

      context "without options provided" do

        it "sends the safe mode option to the command" do
          proxy.insert
        end
      end

      context "with options provided" do

        it "sends the safe mode option to the command" do
          proxy.insert(:safe => true)
        end
      end
    end

    describe "#update" do

      before do
        Mongoid::Persistence::Update.expects(:new).with(
          person,
          { :safe => safety_options }
        ).returns(command)
        command.expects(:persist).returns(true)
      end

      context "without options provided" do

        it "sends the safe mode option to the command" do
          proxy.update
        end
      end

      context "with options provided" do

        it "sends the safe mode option to the command" do
          proxy.update(:safe => true)
        end
      end
    end

    describe "#update_attributes" do

      before do
        Mongoid::Persistence::Update.expects(:new).with(
          person,
          { :safe => safety_options }
        ).returns(command)
        command.expects(:persist).returns(true)
      end

      context "without options provided" do

        it "sends the safe mode option to the command" do
          proxy.update_attributes(:title => "Sir")
        end
      end
    end

    describe "#update_attributes" do

      before do
        Mongoid::Persistence::Update.expects(:new).with(
          person,
          { :safe => safety_options }
        ).returns(command)
        command.expects(:persist).returns(true)
      end

      context "without options provided" do

        it "sends the safe mode option to the command" do
          proxy.update_attributes!(:title => "Sir")
        end
      end
    end

    describe "#upsert" do

      before do
        Mongoid::Persistence::Insert.expects(:new).with(
          person,
          { :safe => safety_options }
        ).returns(command)
        command.expects(:persist).returns(person)
      end

      context "without options provided" do

        it "sends the safe mode option to the command" do
          proxy.upsert
        end
      end

      context "with options provided" do

        it "sends the safe mode option to the command" do
          proxy.upsert(:safe => true)
        end
      end
    end
  end

  context "when proxying a document instance" do

    let(:command) do
      stub
    end

    let(:modifier) do
      stub
    end

    let(:person) do
      Person.new
    end

    context "when using default safety level" do
      let(:safety_options) { true }
      let(:proxy) { person.safely }

      it_behaves_like 'a safely persisting document instance'
    end

    context "when using specified safety level" do
      let(:safety_options) { {:w => true} }
      let(:proxy) { person.safely(safety_options) }

      it_behaves_like 'a safely persisting document instance'
    end

  end

  shared_examples_for 'a safely persisting class' do
    describe "#create" do

      before do
        Mongoid::Persistence::Insert.expects(:new).with(
          person,
          { :safe => safety_options }
        ).returns(command)
        Person.expects(:new).returns(person)
        command.expects(:persist).returns(person)
      end

      context "without attributes provided" do

        it "sends the safe mode option to the command" do
          proxy.create
        end
      end

      context "with attributes provided" do

        it "sends the safe mode option to the command" do
          proxy.create(:title => "Sir")
        end
      end
    end

    describe "#create!" do

      before do
        Mongoid::Persistence::Insert.expects(:new).with(
          person,
          { :safe => safety_options }
        ).returns(command)
        Person.expects(:new).returns(person)
        command.expects(:persist).returns(person)
      end

      context "without attributes provided" do

        it "sends the safe mode option to the command" do
          proxy.create!
        end
      end

      context "with attributes provided" do

        it "sends the safe mode option to the command" do
          proxy.create!(:title => "Sir")
        end
      end
    end

    describe "#delete_all" do

      context "without conditions provided" do

        before do
          Mongoid::Persistence::RemoveAll.expects(:new).with(
            Person,
            { :validate => false, :safe => safety_options },
            {}
          ).returns(command)
          command.expects(:persist).returns(true)
        end

        it "sends the safe mode option to the command" do
          proxy.delete_all
        end
      end

      context "with conditions provided" do

        before do
          Mongoid::Persistence::RemoveAll.expects(:new).with(
            Person,
            { :validate => false, :safe => safety_options },
            { :title => "Sir" }
          ).returns(command)
          command.expects(:persist).returns(true)
        end

        it "sends the safe mode option to the command" do
          proxy.delete_all(:conditions => { :title => "Sir" })
        end
      end
    end

    describe "#destroy_all" do

      before do
        Mongoid::Persistence::Remove.expects(:new).with(
          person,
          { :safe => safety_options }
        ).returns(command)
        command.expects(:persist).returns(person)
        Person.expects(:all).returns([ person ])
      end

      context "without onditions provided" do

        it "sends the safe mode option to the command" do
          proxy.destroy_all
        end
      end

      context "with conditions provided" do

        it "sends the safe mode option to the command" do
          proxy.destroy_all(:conditions => { :title => "Sir" })
        end
      end
    end
  end

  context "when proxying a class" do

    let(:command) do
      stub
    end

    let(:person) do
      Person.new
    end

    context "when using default safety level" do
      let(:safety_options) { true }
      let(:proxy) { Person.safely }
      it_behaves_like 'a safely persisting class'
    end

    context "when using a specified safety level" do
      let(:safety_options) { {:w => 2} }
      let(:proxy) { Person.safely(safety_options) }
      it_behaves_like 'a safely persisting class'
    end

  end
end
require File.expand_path('../../../spec_helper', __FILE__)
require 'ipaddr'

describe "IPAddr#reverse" do
  it 'should be able to generate the reverse DNS lookup entry' do
    IPAddr.new("3ffe:505:2::f").reverse.should == "f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.arpa"
    IPAddr.new("192.168.2.1").reverse.should == "1.2.168.192.in-addr.arpa"
  end
end

describe "IPAddr#ip6_arpa" do
  it 'should be able to convert an IPv6 address into the reverse DNS lookup representation according to RFC3172' do
    IPAddr.new("3ffe:505:2::f").ip6_arpa.should == "f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.arpa"
    lambda{
      IPAddr.new("192.168.2.1").ip6_arpa
    }.should raise_error(ArgumentError)
  end
end

describe "IPAddr#ip6_int" do
  it 'should be able to convert an IPv6 address into the reverse DNS lookup representation according to RFC1886' do
    IPAddr.new("3ffe:505:2::f").ip6_int.should == "f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.int"
    lambda{
      IPAddr.new("192.168.2.1").ip6_int
    }.should raise_error(ArgumentError)
  end
endrequire File.expand_path('../../../spec_helper', __FILE__)

describe "LocalJumpError#reason" do
  it "needs to be reviewed for spec completeness"
end
describe :file_setgid, :shared => true do
end
require 'sass/tree/node'

module Sass::Tree
  # A dynamic node representing a Sass `@for` loop.
  #
  # @see Sass::Tree
  class ForNode < Node
    # @param var [String] The name of the loop variable
    # @param from [Script::Node] The parse tree for the initial expression
    # @param to [Script::Node] The parse tree for the final expression
    # @param exclusive [Boolean] Whether to include `to` in the loop
    #   or stop just before
    def initialize(var, from, to, exclusive)
      @var = var
      @from = from
      @to = to
      @exclusive = exclusive
      super()
    end

    protected

    # @see Node#to_src
    def to_src(tabs, opts, fmt)
      to = @exclusive ? "to" : "through"
      "#{'  ' * tabs}@for $#{dasherize(@var, opts)} from #{@from.to_sass(opts)} #{to} #{@to.to_sass(opts)}" +
        children_to_src(tabs, opts, fmt)
    end

    # Runs the child nodes once for each time through the loop,
    # varying the variable each time.
    #
    # @param environment [Sass::Environment] The lexical environment containing
    #   variable and mixin values
    # @return [Array<Tree::Node>] The resulting static nodes
    # @see Sass::Tree
    def _perform(environment)
      from = @from.perform(environment)
      to = @to.perform(environment)
      from.assert_int!
      to.assert_int!

      to = to.coerce(from.numerator_units, from.denominator_units)
      range = Range.new(from.to_i, to.to_i, @exclusive)

      children = []
      environment = Sass::Environment.new(environment)
      range.each do |i|
        environment.set_local_var(@var, Sass::Script::Number.new(i, from.numerator_units, from.denominator_units))
        children += perform_children(environment)
      end
      children
    end

    # Returns an error message if the given child node is invalid,
    # and false otherwise.
    #
    # {ExtendNode}s are valid within {ForNode}s.
    #
    # @param child [Tree::Node] A potential child node.
    # @return [Boolean, String] Whether or not the child node is valid,
    #   as well as the error message to display if it is invalid
    def invalid_child?(child)
      super unless child.is_a?(ExtendNode)
    end
  end
end
# -----------------------------------------------------------------------------
# 
# RGeo version
# 
# -----------------------------------------------------------------------------
# Copyright 2010 Daniel Azuma
# 
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# * Redistributions of source code must retain the above copyright notice,
#   this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# * Neither the name of the copyright holder, nor the names of any other
#   contributors to this software, may be used to endorse or promote products
#   derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# -----------------------------------------------------------------------------
;


begin
  require 'versionomy'
rescue ::LoadError
end


module RGeo
  
  # Current version of RGeo as a frozen string
  VERSION_STRING = ::File.read(::File.dirname(__FILE__)+'/../../Version').strip.freeze
  
  # Current version of RGeo as a Versionomy object, if the Versionomy gem
  # is available.
  VERSION = defined?(::Versionomy) ? ::Versionomy.parse(VERSION_STRING) : VERSION_STRING
  
end
#
# dummyparser.rb
#

require 'ripper'

class Node
  def initialize(name, *nodes)
    @name = name
    @children = nodes
  end

  attr_reader :children

  def to_s
    "#{@name}(#{Node.trim_nil(@children).map {|n| n.to_s }.join(',')})"
  end

  def self.trim_nil(list)
    if !list.empty? and list.last.nil?
      list = list[0...-1]
      list.pop while !list.empty? and list.last.nil?
    end
    list
  end
end

class NodeList
  def initialize
    @list = []
  end

  attr_reader :list

  def push(item)
    @list.push item
    self
  end

  def prepend(items)
    @list.unshift items
  end

  def to_s
    "[#{@list.join(',')}]"
  end
end

class DummyParser < Ripper
  def hook(name)
    class << self; self; end.class_eval do
      define_method(name) do |*a, &b|
        result = super(*a, &b)
        yield(*a)
        result
      end
    end
    self
  end

  def on_program(stmts)
    stmts
  end

  def on_stmts_new
    NodeList.new
  end

  def on_stmts_add(stmts, st)
    stmts.push st
    stmts
  end

  def on_void_stmt
    Node.new('void')
  end

  def on_var_ref(name)
    Node.new('ref', name)
  end

  def on_var_alias(a, b)
    Node.new('valias', a, b)
  end

  def on_alias_error(a)
    Node.new('aliaserr', a)
  end

  def on_arg_paren(args)
    args
  end

  def on_args_new
    NodeList.new
  end

  def on_args_add(list, arg)
    list.push(arg)
  end

  def on_args_add_block(list, blk)
    if blk
      list.push('&' + blk.to_s)
    else
      list
    end
  end

  def on_args_add_star(list, arg)
    list.push('*' + arg.to_s)
  end

  def on_args_prepend(list, args)
    list.prepend args
    list
  end

  def on_method_add_arg(m, arg)
    if arg == nil
      arg = on_args_new
    end
    m.children.push arg
    m
  end

  def on_method_add_block(m, b)
    on_args_add_block(m.children, b)
    m
  end
  
  def on_paren(params)
    params
  end
  
  def on_brace_block(params, code)
    Node.new('block', params, code)
  end
  
  def on_block_var(params, shadow)
    params
  end
  
  def on_rest_param(var)
    "*#{var}"
  end
  
  def on_blockarg(var)
    "&#{var}"
  end
  
  def on_params(required, optional, rest, more, block)
    args = NodeList.new
    
    required.each do |req|
      args.push(req)
    end if required
    
    optional.each do |var, val|
      args.push("#{var}=#{val}")
    end if optional
    
    args.push(rest) if rest
    
    more.each do |m|
      args.push(m)
    end if more
    
    args.push(block) if block
    args
  end

  def on_assoc_new(a, b)
    Node.new('assoc', a, b)
  end

  def on_bare_assoc_hash(assoc_list)
    Node.new('assocs', *assoc_list)
  end

  def on_assoclist_from_args(a)
    Node.new('assocs', *a)
  end

  (Ripper::PARSER_EVENTS.map(&:to_s) - instance_methods(false).map {|n|n.to_s.sub(/^on_/, '')}).each do |event|
    define_method(:"on_#{event}") do |*args|
      Node.new(event, *args)
    end
  end
end
require File.expand_path('../../../spec_helper', __FILE__)

ruby_version_is "1.9" do
  describe "Symbol#[]" do
    it "needs to be reviewed for spec completeness"
  end
end
require File.expand_path('../../../spec_helper', __FILE__)
require "stringio"

describe "StringIO#gets when passed [separator]" do
  before(:each) do
    @io = StringIO.new("this>is>an>example")
  end

  it "returns the data read till the next occurence of the passed separator" do
    @io.gets(">").should == "this>"
    @io.gets(">").should == "is>"
    @io.gets(">").should == "an>"
    @io.gets(">").should == "example"
  end

  it "sets $_ to the read content" do
    @io.gets(">")
    $_.should == "this>"
    @io.gets(">")
    $_.should == "is>"
    @io.gets(">")
    $_.should == "an>"
    @io.gets(">")
    $_.should == "example"
    @io.gets(">")
    $_.should be_nil
  end

  it "accepts string as separator" do
    @io.gets("is>")
    $_.should == "this>"
    @io.gets("an>")
    $_.should == "is>an>"
    @io.gets("example")
    $_.should == "example"
    @io.gets("ple")
    $_.should be_nil
  end

  it "updates self's lineno by one" do
    @io.gets(">")
    @io.lineno.should eql(1)
    
    @io.gets(">")
    @io.lineno.should eql(2)
    
    @io.gets(">")
    @io.lineno.should eql(3)
  end
  
  ruby_bug "", "1.8.8" do
    it "returns the next paragraph when the passed separator is an empty String" do
      io = StringIO.new("this is\n\nan example")
      io.gets("").should == "this is\n\n"
      io.gets("").should == "an example"
    end
  end
  
  it "returns the remaining content starting at the current position when passed nil" do
    io = StringIO.new("this is\n\nan example")
    io.pos = 5
    io.gets(nil).should == "is\n\nan example"
  end

  it "tries to convert the passed separator to a String using #to_str" do
    obj = mock('to_str')
    obj.should_receive(:to_str).and_return(">")
    @io.gets(obj).should == "this>"
  end
end

describe "StringIO#gets when passed no argument" do
  before(:each) do
    @io = StringIO.new("this is\nan example\nfor StringIO#gets")
  end
  
  it "returns the data read till the next occurence of $/ or till eof" do
    @io.gets.should == "this is\n"
    
    begin
      old_sep, $/ = $/, " "
      @io.gets.should == "an "
      @io.gets.should == "example\nfor "
      @io.gets.should == "StringIO#gets"
    ensure
      $/ = old_sep
    end
  end

  it "sets $_ to the read content" do
    @io.gets
    $_.should == "this is\n"
    @io.gets
    $_.should == "an example\n"
    @io.gets
    $_.should == "for StringIO#gets"
    @io.gets
    $_.should be_nil
  end

  it "updates self's position" do
    @io.gets
    @io.pos.should eql(8)
    
    @io.gets
    @io.pos.should eql(19)

    @io.gets
    @io.pos.should eql(36)
  end
  
  it "updates self's lineno" do
    @io.gets
    @io.lineno.should eql(1)
    
    @io.gets
    @io.lineno.should eql(2)
    
    @io.gets
    @io.lineno.should eql(3)
  end

  it "returns nil if self is at the end" do
    @io.pos = 36
    @io.gets.should be_nil
    @io.gets.should be_nil
  end
end

describe "StringIO#gets when in write-only mode" do
  it "raises an IOError" do
    io = StringIO.new("xyz", "w")
    lambda { io.gets }.should raise_error(IOError)

    io = StringIO.new("xyz")
    io.close_read
    lambda { io.gets }.should raise_error(IOError)
  end
end
require File.expand_path('../../../spec_helper', __FILE__)
require File.expand_path('../fixtures/classes', __FILE__)
require File.expand_path('../shared/object_id', __FILE__)

describe "Object.object_id" do
  it_behaves_like(:kernel_object_id, :object_id) 
end

describe "Kernel#object_id" do
  it "needs to be reviewed for spec completeness"
end
require File.join(File.dirname(__FILE__), "spec_helper")

describe YARD::RegistryStore do
  before { @store = RegistryStore.new }
  
  describe '#load' do
    it "should load old yardoc format if .yardoc is a file" do
      File.should_receive(:directory?).with('foo').and_return(false)
      File.should_receive(:file?).with('foo').and_return(true)
      File.should_receive(:read_binary).with('foo').and_return('FOO')
      Marshal.should_receive(:load).with('FOO')

      @store.load('foo')
    end
    
    it "should load new yardoc format if .yardoc is a directory" do
      File.should_receive(:directory?).with('foo').and_return(true)
      File.should_receive(:file?).with('foo/checksums').and_return(false)
      File.should_receive(:file?).with('foo/proxy_types').and_return(false)
      File.should_receive(:file?).with('foo/objects/root.dat').and_return(false)

      @store.load('foo').should == true
    end
    
    it "should return true if .yardoc is loaded (file)" do
      File.should_receive(:directory?).with('myyardoc').and_return(false)
      File.should_receive(:file?).with('myyardoc').and_return(true)
      File.should_receive(:read_binary).with('myyardoc').and_return(Marshal.dump(''))
      @store.load('myyardoc').should == true
    end

    it "should return true if .yardoc is loaded (directory)" do
      File.should_receive(:directory?).with('foo').and_return(true)
      File.should_receive(:file?).with('foo/checksums').and_return(false)
      File.should_receive(:file?).with('foo/proxy_types').and_return(false)
      File.should_receive(:file?).with('foo/objects/root.dat').and_return(false)
      @store.load('foo').should == true
    end

    it "should return false if .yardoc does not exist" do
      @store.load('NONEXIST').should == false
    end
    
    it "should return false if there is no file to load" do
      @store.load(nil).should == false
    end
    
    it "should load checksums if they exist" do
      File.should_receive(:directory?).with('foo').and_return(true)
      File.should_receive(:file?).with('foo/checksums').and_return(true)
      File.should_receive(:file?).with('foo/proxy_types').and_return(false)
      File.should_receive(:file?).with('foo/objects/root.dat').and_return(false)
      File.should_receive(:readlines).with('foo/checksums').and_return([
        'file1 CHECKSUM1', '  file2 CHECKSUM2 '
      ])
      @store.load('foo').should == true
      @store.checksums.should == {'file1' => 'CHECKSUM1', 'file2' => 'CHECKSUM2'}
    end
    
    it "should load proxy_types if they exist" do
      File.should_receive(:directory?).with('foo').and_return(true)
      File.should_receive(:file?).with('foo/checksums').and_return(false)
      File.should_receive(:file?).with('foo/proxy_types').and_return(true)
      File.should_receive(:file?).with('foo/objects/root.dat').and_return(false)
      File.should_receive(:read_binary).with('foo/proxy_types').and_return(Marshal.dump({'a' => 'b'}))
      @store.load('foo').should == true
      @store.proxy_types.should == {'a' => 'b'}
    end

    it "should load root object if it exists" do
      File.should_receive(:directory?).with('foo').and_return(true)
      File.should_receive(:file?).with('foo/checksums').and_return(false)
      File.should_receive(:file?).with('foo/proxy_types').and_return(false)
      File.should_receive(:file?).with('foo/objects/root.dat').and_return(true)
      File.should_receive(:read_binary).with('foo/objects/root.dat').and_return(Marshal.dump('foo'))
      @store.load('foo').should == true
      @store.root.should == 'foo'
    end
  end
  
  describe '#put' do
    it "should assign values" do
      @store.put(:YARD, true)
      @store.get(:YARD).should == true
    end
    
    it "should treat '' as root" do
      @store.put('', 'value')
      @store.get(:root).should == 'value'
    end
  end
  
  describe '#get' do
    it "should hit cache if object exists" do
      @store.put(:YARD, true)
      @store.get(:YARD).should == true
    end
    
    it "should hit backstore on cache miss and cache is not fully loaded" do
      serializer = mock(:serializer)
      serializer.should_receive(:deserialize).once.with(:YARD).and_return('foo')
      @store.load('foo')
      @store.instance_variable_set("@loaded_objects", 0)
      @store.instance_variable_set("@available_objects", 100)
      @store.instance_variable_set("@serializer", serializer)
      @store.get(:YARD).should == 'foo'
      @store.get(:YARD).should == 'foo'
      @store.instance_variable_get("@loaded_objects").should == 1
    end
  end
  
  [:keys, :values].each do |item|
    describe "##{item}" do
      it "should load entire database if reload=true" do
        File.should_receive(:directory?).with('foo').and_return(true)
        @store.load('foo')
        @store.should_receive(:load_all)
        @store.send(item, true)
      end
    
      it "should not load entire database if reload=false" do
        File.should_receive(:directory?).with('foo').and_return(true)
        @store.load('foo')
        @store.should_not_receive(:load_all)
        @store.send(item, false)
      end
    end
  end
  
  describe '#load_all' do
    it "should load the entire database" do
      foomock = mock(:Foo)
      barmock = mock(:Bar)
      foomock.should_receive(:path).and_return('Foo')
      barmock.should_receive(:path).and_return('Bar')
      File.should_receive(:directory?).with('foo').and_return(true)
      File.should_receive(:file?).with('foo/proxy_types').and_return(false)
      File.should_receive(:file?).with('foo/checksums').and_return(false)
      File.should_receive(:file?).with('foo/objects/root.dat').and_return(false)
      @store.should_receive(:all_disk_objects).at_least(1).times.and_return(['foo/objects/foo', 'foo/objects/bar'])
      @store.load('foo')
      serializer = @store.instance_variable_get("@serializer")
      serializer.should_receive(:deserialize).with('foo/objects/foo', true).and_return(foomock)
      serializer.should_receive(:deserialize).with('foo/objects/bar', true).and_return(barmock)
      @store.send(:load_all)
      @store.instance_variable_get("@available_objects").should == 2
      @store.instance_variable_get("@loaded_objects").should == 2
      @store[:Foo].should == foomock
      @store[:Bar].should == barmock
    end
  end
  
  describe '#destroy' do
    it "should destroy file ending in .yardoc when force=false" do
      File.should_receive(:file?).with('foo.yardoc').and_return(true)
      File.should_receive(:unlink).with('foo.yardoc')
      @store.instance_variable_set("@file", 'foo.yardoc')
      @store.destroy.should == true
    end

    it "should destroy dir ending in .yardoc when force=false" do
      File.should_receive(:directory?).with('foo.yardoc').and_return(true)
      FileUtils.should_receive(:rm_rf).with('foo.yardoc')
      @store.instance_variable_set("@file", 'foo.yardoc')
      @store.destroy.should == true
    end

    it "should not destroy file/dir not ending in .yardoc when force=false" do
      File.should_not_receive(:file?).with('foo')
      File.should_not_receive(:directory?).with('foo')
      File.should_not_receive(:unlink).with('foo')
      FileUtils.should_not_receive(:rm_rf).with('foo')
      @store.instance_variable_set("@file", 'foo')
      @store.destroy.should == false
    end
    
    it "should destroy any file/dir when force=true" do
      File.should_receive(:file?).with('foo').and_return(true)
      File.should_receive(:unlink).with('foo')
      @store.instance_variable_set("@file", 'foo')
      @store.destroy(true).should == true
    end
  end
endrequire 'yaml'
require 'dbm'
#
# YAML + DBM = YDBM
# - Same interface as DBM class
#
module YAML

class DBM < ::DBM
    VERSION = "0.1"
    def []( key )
        fetch( key )
    end
    def []=( key, val )
        store( key, val )
    end
    def fetch( keystr, ifnone = nil )
        begin
            val = super( keystr )
            return YAML::load( val ) if String === val
        rescue IndexError
        end
        if block_given?
            yield keystr
        else
            ifnone
        end
    end
    def index( keystr )
        super( keystr.to_yaml )
    end
    def values_at( *keys )
        keys.collect { |k| fetch( k ) }
    end
    def delete( key )
        v = super( key )
        if String === v
            v = YAML::load( v ) 
        end
        v
    end
    def delete_if
        del_keys = keys.dup
        del_keys.delete_if { |k| yield( k, fetch( k ) ) == false }
        del_keys.each { |k| delete( k ) } 
        self
    end
    def reject
        hsh = self.to_hash
        hsh.reject { |k,v| yield k, v }
    end
    def each_pair
        keys.each { |k| yield k, fetch( k ) }
        self
    end
    def each_value
        super { |v| yield YAML::load( v ) }
        self
    end
    def values
        super.collect { |v| YAML::load( v ) }
    end
    def has_value?( val )
        each_value { |v| return true if v == val }
        return false
    end
    def invert
        h = {}
        keys.each { |k| h[ self.fetch( k ) ] = k }
        h
    end
    def replace( hsh )
        clear
        update( hsh )
    end
    def shift
        a = super
        a[1] = YAML::load( a[1] ) if a
        a
    end
    def select( *keys )
        if block_given?
            self.keys.collect { |k| v = self[k]; [k, v] if yield k, v }.compact
        else
            values_at( *keys )
        end
    end
    def store( key, val )
        super( key, val.to_yaml )
        val
    end
    def update( hsh )
        hsh.keys.each do |k|
            self.store( k, hsh.fetch( k ) )
        end
        self
    end
    def to_a
        a = []
        keys.each { |k| a.push [ k, self.fetch( k ) ] }
        a
    end
    def to_hash
        h = {}
        keys.each { |k| h[ k ] = self.fetch( k ) }
        h
    end
    alias :each :each_pair
end

end
module TZInfo
  module Definitions
    module Asia
      module Colombo
        include TimezoneDefinition
        
        timezone 'Asia/Colombo' do |tz|
          tz.offset :o0, 19164, 0, :LMT
          tz.offset :o1, 19172, 0, :MMT
          tz.offset :o2, 19800, 0, :IST
          tz.offset :o3, 19800, 1800, :IHST
          tz.offset :o4, 19800, 3600, :IST
          tz.offset :o5, 23400, 0, :LKT
          tz.offset :o6, 21600, 0, :LKT
          
          tz.transition 1879, 12, :o1, 17335550003, 7200
          tz.transition 1905, 12, :o2, 52211763607, 21600
          tz.transition 1942, 1, :o3, 116657485, 48
          tz.transition 1942, 8, :o4, 9722413, 4
          tz.transition 1945, 10, :o2, 38907909, 16
          tz.transition 1996, 5, :o5, 832962600
          tz.transition 1996, 10, :o6, 846266400
          tz.transition 2006, 4, :o2, 1145039400
        end
      end
    end
  end
end
require File.join(File.dirname(__FILE__), "..", "spec_helper")

include CodeObjects